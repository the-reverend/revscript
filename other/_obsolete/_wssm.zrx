/* REXX _wssm.zrx by the reverend (build 84)                                  */
/*-       built by rev-builder version 1.3a on 17 Oct 2003 at 12:12:40       -*/
/*- ------------------------------------------------------------------------ -*/
/*-                       Copyright (C) 2003 Ron Wilson                      -*/
/*-                                                                          -*/
/*- This script is free, and can be modified for your personal use, but you  -*/
/*- cannot copy or distribute this script or any derivative work based upon  -*/
/*- this script without the express permission of the author. Your use of    -*/
/*- this script is governed by the terms of the REV-LICENSE.                 -*/
/*-                                                                          -*/
/*- This program is provided to you WITHOUT ANY WARRANTY, even the implied   -*/
/*- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the -*/
/*- REV-LICENSE for more details.                                            -*/
/*-                                                                          -*/
/*-                A copy of the REV-LICENSE is available at:                -*/
/*-       http://thereverend.coastgames.com/tradewars/rev-license.html       -*/
/*- ------------------------------------------------------------------------ -*/
/*- ----------------------*/ _g.!sname="_wssm.zrx" /*----------------------- -*/
/*- --------------*/ _g.!sbuild=84; _g.!sdate="2003-10-17" /*--------------- -*/
/*- ------------------------------------------------------------------------ -*/
/* rev. 0 - pre release                                                       */
/* rev. 1 - fixed zero steal bug                                              */
/* rev. 2 - public release                                                    */

globals=_setglobals("sd alpha rylos")
call _timeout 60
call zocsynctime 250
call on halt name _halt
call _rseed

class0=1

if _synchronize()\="command" then call _error "please start at the command prompt."

/* load ini variables */
   load="cr ns sf bust_clear mname vname lname spath lpath dpath"
   sl=_ini_load_settings()
   do i=1 to _dwords(sl,";")
    s=_dword(sl,i,";")
    globals=globals||" !"||s
    interpret '!'||s||'="!"||s'
   end;
   f=0; l=""
   do i=1 to words(load)
    s=word(load,i)
    x="!"||s
    interpret s||"=_ini.!settings.x"
    interpret 'if '||s||'="##UNDEF##" then do; l=l s; f=1; end'
   end; if f then call _error "missing config variable(s):"||l; drop load s sl x f l

x="!red_ships"; red_ships=_ini.!settings.x
if _undef(red_ships) then red_ships=""
x="!last_rob"; last_rob=_ini.!settings.x
if _undef(last_rob) then lra=0; else lra=last_rob

x="!alpha"; alpha=_ini.!settings.x
x="!rylos"; rylos=_ini.!settings.x
x="!sd"; sd=_ini.!settings.x
if _undef(alpha) then alpha=0
if _undef(rylos) then rylos=0
if _undef(sd) then sd=0

   _ef.=0
   _et.=0
   _es.=0
   _ep.=0
   _f.=0
   _p.=""
   now=_getservertime("stamp")
   call _getvoids vname

   parse value _getinfo("shiptype;figs;shields;twarp;lrs;exp;aln;hlds;creds") with myshort ";" figs ";" shields ";" twarp ";" scanner ";" exp ";" align ";" holds ";" credits
   if lower(twarp)="no" then twarp=0
   else twarp=1
   if lower(scanner)="holo" then scanner=1
   else scanner=0
   if \scanner then call _error "a holoscanner is required"
/* myship=_ini_askstr("##DEFAULT##","##NA##",dname,"settings","short."||myshort) */
/* shipcat=_ini_askstr("##DEFAULT##","##NA##",dname,"settings","ship."||myship) */
   myship="##NA##"; shipcat="##NA##"
   if shipcat="##NA##" | myship="##NA##" | myshort="other" then do
    if _sendwait("c","<Computer activated>")=640 then call _error "timeout"
    call zocreceivebuf(3*1024)
    if _sendwait(";","Photon Missiles")=640 then call _error "timeout"
    if zocwait("(?=Help)?")=640 then call _error "timeout"
    shipcat=_parse_ship_desc(translate(zocreceivebuf(0),"  ",d2c(0)||d2c(10)))
    call zocsend "q"
   end /*if*/
   myshields=_dword(shipcat,11,";")
   myfigs=_dword(shipcat,5,";")
   mymaxattack=_dword(shipcat,2,";")
   myoffodds=_dword(shipcat,12,";")
   mydefodds=_dword(shipcat,13,";")
   mymaxholds=_dword(shipcat,3,";")
   myxportrange=_dword(shipcat,10,";")
   mytpw=_dword(shipcat,6,";")

_begin:

  _warpout:
    dest=random(ns-12)+11
    do while dest=sd | _bust.dest>0 | _v.dest
     dest=random(11,ns)
    end /*do*/
    parse value _ewarp(dest,mymaxattack,myoffodds,cr) with msg ";" current ";" last
    if current\=dest | verify(msg,"KST")\=0 then signal _danger

 /* findpair */
    pair=_findpair(mymaxattack,myoffodds,twarp,cr,current)
    if pair="##NOPAIR##" | pair="##DANGER##" then signal _refurb

 /* ssm */
    parse var pair sec1 ";" sec2
    sec.1=sec1
    sec.2=sec2
    ptype.1=_dword(_p.sec1,1,";")
    ptype.2=_dword(_p.sec2,1,";")
    portquant.1=0
    portquant.2=0
    i=1
    steal=min(trunc(exp/(.3*sf)),min(mymaxholds,holds))
    call zocsend "jyo 3"||steal%10+1||"^M q"
    signal _steal

    _sell:
      select
       when ptype.i="BBB" then call zocsend "pt^M^M"
       when ptype.i="SBB" then call zocsend "pt^M^M0^M"
       when ptype.i="BSB" then call zocsend "pt^M^M0^M"
       when ptype.i="SSB" then call zocsend "pt^M^M0^M0^M"
       otherwise call _error "bad port pair"
      end /*select*/

    _steal:
      t_lra=lra
      lra=shiploc.i
      parse value _portsteal_fast(steal,3) with msg ";" dexp ";" amount ";" portquant.i ";" holds ";" turns ";" fine
      select
       when msg="##SUCCESS##" then do
        exp=exp+dexp
        portquant.i=portquant.i-amount
        i2=i
        i=abs(i-2)+1
        steal=min(trunc(exp/(.3*sf)),min(mymaxholds,holds))
        call zocsend "<zn"
        idg=0

        _enemy:
          num2=sec.i
          num1=sec.i2
          ans=zocwaitmux("]:["||num2||"]", ,
                         "Your fighters: ", ,
                         "Fighter Attack!", ,
                         "An Interdictor Generator in", ,
                         "Traders :")
          select
           when ans=0 then nop
           when ans=1 then do
            call zocsend "r^^s"||num2||"^Mq"
            _v.num2=1
            signal _refurb
           end /*when*/
           when ans=2 then do
            call zocsend "<^^s"||num2||"^Mq"
            _v.num2=1
            signal _refurb
           end /*when*/
           when ans=3 then do
            if \idg then do
             call zocsend "^^s"||num1||"^Mq"
             figs=_getinfo("figs")
             _v.num1=1
            end /*if*/
            idg=1
            a=min(mymaxattack,figs)
            if a>0 then do
             call zocsend "ayy"||a||"^M"
             figs=figs-a
            end /*if*/
            call zocsend "<zn"
            signal _enemy
           end /*when*/
           when ans=4 then do
            call zocsend "<^^s"||num2||"^Mq"
            _v.num2=1
            ans2=zocwaitmux("not adjacent.","Sector  :")
            select
             when ans2=0 then do
              call zocsend "n"
              call _quit "POD"
             end /*when*/
             when ans2=1 then signal _refurb
             when ans2=640 then call _error "timeout"
             otherwise nop
            end /*select*/
           end /*when*/
           when ans=640 then call _error "timeout"
           otherwise nop
          end /*select*/

        if idg then signal _refurb
        signal _sell
       end /*when*/
       when msg="##BUST##" then do
        num=sec.i
        stamp=_getservertime("stamp")
        call _bust_tool "BUST_ADD", num, stamp, bname
        call _bust_memo "BUST_CLR", num, stamp
        _bust.num=stamp
       end /*when*/
       when msg="##FAKE##"  then lra=t_lra
       when msg="##HOLDS##" then do
        lra=t_lra
        call zocsend "o 3"||_roundup((steal-portquant.i)/10)+1||"^M q"
        signal _steal
       end /*when*/
       when msg="##ZERO##"  then do /* port maxed equip, mark as busted, warpout */
        lra=t_lra
        num=sec.i
        _bust.num=_getservertime("stamp")
        signal _warpout
       end /*when*/
       otherwise nop
      end /*select*/

  _refurb:
    dest=class0
    parse value _ewarp(dest,mymaxattack,myoffodds,cr) with msg ";" current ";" last

    _danger:
      select
       when verify(msg,"I","M")>0 then call _quit "IDG"
       when verify(msg,"P","M")>0 then call _quit "POD"
       when verify(msg,"Q","M")>0 then call _quit "QUASAR"
       when current=class0 then nop
       when verify(msg,"FR","M")>0 then do /* RETREAT or FLEE */
        call zocsend "^^s"||last||"^Mq"
        _v.last=1
        signal _refurb
       end /*when*/
       when verify(msg,"A","M")>0 then signal _refurb
       when verify(msg,"V","M")>0 then do /* VOID */
        call zocsend "cv^Myyq"
        _v.=0
        signal _refurb
       end /*when*/
       when current=dest then signal _refurb
       otherwise call _quit "UNKNOWN "||msg
      end /*select*/

    call zocsend "pty"
    if zocwait("Cargo holds     :")=640 then call _error "timeout"
    costperhold=_stripint(_grabit("credits"))
    if zocwait("Fighters        :")=640 then call _error "timeout"
    costperfig=_stripint(_grabit("credits"))
    if zocwait("Shield Points   :")=640 then call _error "timeout"
    costpershield=_stripint(_grabit("credits"))

    if \_ini_write(dname,"settings","last_rob",lra) then call _error "unable to write to "||dname
    parse value _getinfo("hlds;figs;shlds;exp;aln;creds") with holds ";" figs ";" shields ";" exp ";" align ";" credits

    buyholds=mymaxholds-holds
    do while _cost_holds(costperhold,buyholds)>credits
     buyholds=buyholds-1
    end /*do*/
    if buyholds>0 then do
     call zocsend "a"||buyholds||"^My"
     holds=holds+buyholds
     credits=credits-_cost_holds(costperhold,buyholds)
    end /*if*/

    buyshields=min(myshields-shields, (credits-600000)%costpershield)
    if buyshields>0 then do
     call zocsend "c"||buyshields||"^M"
     shields=shields+buyshields
     credits=credits-buyshields*costpershield
    end /*if*/

    buyfigs=min(myfigs-figs, (credits-200000)%costperfig)
    if buyfigs>0 then do
     call zocsend "b"||buyfigs||"^M"
     figs=figs+buyfigs
     credits=credits-buyfigs*costperfig
    end /*if*/

    call zocsend "q"

signal _begin

exit

_findpair: procedure expose (globals)
 maxa=arg(1)
 odds=arg(2)
 twarp=arg(3)
 cr=arg(4)
 current=arg(5)
 beenthere.=0
 xxb.=0

 w_base=1000
 w_warps=50
 w_beenthere=1000
 w_anom=200
 w_bust=200
 w_xxb=-700
 w_ef=100
 w_fed=1000
 w_1deepnomatch=1000
 w_enemy=3000
 w_void=3000

 if _sendwait("f20^Mco","<Drop/Take Fighters>")=640 then call _error "timeout"

 _find_start:
 ssm1=0
 ssm2=0
 danger=0
 warps=_ds()
 if _holoscan()="##NO HOLO##" then call _error "no holoscanner."

/* ADD ENEMY SHIP/PLAYER CHECK TO HOLO        */
/*  ON ENEMY FIND, VOID AND RETURN ##DANGER## */

 beenthere.current=beenthere.current+1
 xxb.current=_portmatch(_dword(_p.current,1,";"),"XXB")
 if xxb.current & _bust.current<=0 then ssm1=current

 best=_dword(warps,1,";")
 danger=0
 do i=1 to _dwords(warps,";")

  w=_dword(warps,i,";")
  xxb.w=_portmatch(_dword(_p.w,1,";"),"XXB")

  /* initial weight = base + warps factor + beenthere factor */
  wt.w=w_base-_dsinfo(w,"w")*w_warps+beenthere.w*w_beenthere

  /* if bust then add bust factor */
  if _bust.w>0                          then wt.w=wt.w+w_bust

  /* if anomaly then add anom factor */
  if _dsinfo(w,"a")                     then wt.w=wt.w+w_anom

  /* if xxb and not been there and not busted there then att xxb factor */
  if xxb.w & beenthere.w=0 & _bust.w<=0 then wt.w=wt.w+w_xxb

  /* if enemy figs then add ef factor and density minus port density */
  if _ef.w                              then wt.w=wt.w+w_ef+_dsinfo(w,"d")
  if _p.w\="" & _ef.w                   then wt.w=wt.w-100

  /* if fedspace then add fed factor */
  if w=sd | w<11                        then wt.w=wt.w+w_fed

  /* if 1-deep and no xxb pair then add nomatch factor */
  if _dsinfo(w,"w")=1 & \xxb.current    then wt.w=wt.w+w_1deepnomatch

  /* if enemy trader then add enemy trader weight */
  if _et.w | _es.w                      then wt.w=wt.w+w_enemy

  /* if enemy trader then void sector */
  if (_et.w | _es.w | _ep.w) & \(w=sd | w<11) then do
   call zocsend "^^s"||w||"^Mq"
   _v.w=1
  end /*if*/

  /* if voided sector then add void factor */
  if _v.w                               then wt.w=wt.w_void

  /* if weight less than best weight then new best found */
  if wt.w<wt.best | (wt.w=wt.best & random(100)>49) then best=w

  /* if enemy nearby then danger */
  if _ep.w | _et.w | _es.w | _dsinfo(w,"d")>4000 then do
   danger=1
   leave
  end /*if*/

 end /*do*/

 found=0
 if \danger then do
  if best<cr then crm="^M"
             else crm=""
  if best\=sd & best>10 then fmacro="f20^Mco"
                        else fmacro=""
  if _ef.best then amacro="az999^Mzn"
              else amacro="zn"
  if _sendwait(best||crm||amacro||fmacro,"<Move>")=640 then call _error "timeout"
  if zocwait("Warps to Sector(s) :")=640 then call _error "timeout"
  warps=_space(translate(_grabit("^M"),"  ;","()-"),0)
  current=best
  if ssm1>0 & xxb.current & _bust.current<=0 then do
   do i=1 to _dwords(warps,";")
    if _dword(warps,i,";")=ssm1 then found=1
    if found then leave
   end /*do*/
  end /*if*/
 end /*if*/

 select
  when danger then rslt="##DANGER##"
  when found then rslt=current||";"||ssm1
  when beenthere.current>2 then rslt="##NOPAIR##"
  otherwise signal _find_start
 end /*select*/

return rslt

/***                 THE REVEREND'S TW LIBRARY FOR ZOC/REXX                 ***/

/** _setglobals v.4 **/
    _setglobals: procedure expose _verbose _monthdays _monthnames _baseday. _g. _msg. (globals)

     _verbose=0
     _msg.=""; _msg.0=0
     _monthdays="31;28;31;30;31;30;31;31;30;31;30;31"
     _monthnames="jan;feb;mar;apr;may;jun;jul;aug;sep;oct;nov;dec"
     _baseday.2000=730118
     _baseday.2001=_baseday.2000+365+1
     _baseday.2002=_baseday.2001+365
     _baseday.2003=_baseday.2002+365
     _baseday.2004=_baseday.2003+365
     _baseday.2005=_baseday.2004+365+1
     _baseday.2006=_baseday.2005+365
     _baseday.2007=_baseday.2006+365
     _baseday.2008=_baseday.2007+365

     i=lastpos(".",_g.!sname)
     if i=0 then _g.!sname1=_g.!sname
            else _g.!sname1=left(_g.!sname,i-1)

     rslt="_g. _ini. _s. _p. _d. _v. _f. _m. _l. _q. _sl. _ex. _qs. "
     rslt=rslt||"_ef. _es. _et. _ep. "
     rslt=rslt||"_path. _dist. _dtomsl. _dfrmsl. "
     rslt=rslt||"_bg. _nwt. _nwi. _nwo. _nw. _nwt. _od. _sv. _pv. _bust. _vs. _vn. _vi. _mcic. "
     rslt=rslt||"_olist1. _olist2. _clvlist1. _clvlist2. _msg _msg. "
     rslt=rslt||"_verbose _monthdays _monthnames _baseday. "
     rslt=rslt||"globals lra "
     if arg(1,"E") then rslt=rslt||arg(1)

     rslt=_space(rslt)
    return rslt

/** _timeout v.1 **/
    _timeout: procedure expose (globals)
     if _g.!timeout="_G.!TIMEOUT" then _g.!timeout=60
     rslt=_g.!timeout
     nt=_stripint(arg(1))
     if arg(1,"E") & nt>0 then do
      call zoctimeout nt
      _g.!timeout=nt
     end /*if*/
    return rslt

/** _halt v.3 **/
    _halt: procedure expose (globals)
     call off halt
     call zocwriteln "^[[1;33m< user abort >^[[0m "
     exit
    return

/** _rseed v.7 **/
    _rseed: procedure expose (globals)
     if arg(1,"E") then width=min(max(arg(1),2),86400)
     else width=1000
     parse value time("L") with r1 ":" r2 ":" r3 "." r4
     r4=strip(left(r4,5))
     seed=r4||copies(0,5-length(r4))
     rslt=random(0, 99999, seed)//width
    return rslt

/** _synchronize v.5 **/
    _synchronize: procedure expose (globals)

     synchw=_synchronize_vars("w")
     synchr=_synchronize_vars("r")

     call zocsend "&&"
     ans=_waitmux("&&|Pausing is")
     select
      when ans=0 then return "unknown_text_entry"
      when ans=1 then nop
      when ans=640 then return "timeout"
      otherwise nop
     end /*select*/

     ans=_waitmux(synchw)
     select
      when ans=640 then rslt="timeout"
      when ans>0 then do
       if _wait("Pausing is")=640 then call _error "timeout"
      end /*when*/
      otherwise nop
     end /*select*/
     rslt=_dword(synchr,ans+1,";")

     select
      when rslt="computer" then do
       call zocsend "q"
       ans=_waitmux("Command [","Citadel command")
       select
        when ans=0 then nop
        when ans=1 then rslt="computer_cit"
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
       call zocsend "c"
      end /*when*/
      when rslt="corporate" then do
       call zocsend "q"
       ans=_waitmux("Command [","Citadel command")
       select
        when ans=0 then call zocsend "t"
        when ans=1 then do
         rslt="corporate_cit"
         call zocsend "x"
        end /*when*/
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*when*/
      otherwise nop
     end /*select*/

    return rslt

/** _error v.7 **/
    _error: procedure expose (globals)
     call off halt
     if zocgetinfo("CURSOR-X")>0 then call zocwriteln
     call zocwrite _ansi("bt;frd")||"< script error ("||_g.!sname||" b."||_g.!sbuild||")"
     if arg(1,"E") then call zocwrite " : "||arg(1)
     call zocwriteln " >"
     call zocwriteln _ansi("bt;fye")||"< if this is a serious problem, email me at: the.reverend@coastgames.com > "
     call zocwriteln "< SCRIPT "||_g.!sname||", BUILD "||_g.!sbuild||", DATE "||_g.!sdate||" > "
     call zocwriteln "< ZOC VERSION '"||zocgetinfo("VERSION")||"', OS '"||zocgetinfo("OSYS")||"', LOCATION '"||zocgetinfo("CONNECTEDTO")||"' >"
     if arg(2,"E") then call zocwriteln _ansi("bt;fgr")||"< "||arg(2)||" >"
     call zocwrite _ansi()
     call _beep "error.wav"
    exit

/** _ini_load_settings v.1 **/
    _ini_load_settings: procedure expose (globals)

     parse value zocgetoption("CaptDefaultName") with . '="' ldefault '"'
     parse value zocgetglobaloption("WindowTitle") with . '="' gname '"'

     lpath=_get_log_path()
     spath=_get_script_path()
     dpath=_get_download_path()

     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then gname=_setgame()
     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then exit
     dname=dosfname(lpath||gname||"_data.ini")

     _ini.="##UNDEF##"

     sectionlist=""
     if _fileopenr(dname) then do
      insection=0
      do while \_fileeof(dname)
       line=strip(linein(dname))
       if _ini_is_section(line) then do
        insection=1
        parse var line "[" section "]"
        section=strip(section)
        if sectionlist="" then sectionlist=section; else sectionlist=sectionlist||";"||section
       end /*if*/
       else do
        if insection then do
         parse var line k "=" v
         v=_ini_format_value(v)
         k="!"||section||".!"||strip(k)
         if k\="!"||section||".!" then _ini.k=strip(v)
        end /*if*/
       end /*else*/
      end /*while*/
      call _fileclose dname
     end /*if*/

     !settings="!settings"
     x="!ldefault"; _ini.!settings.x = ldefault
     x="!lpath";    _ini.!settings.x = lpath
     x="!spath";    _ini.!settings.x = spath
     x="!dpath";    _ini.!settings.x = dpath
     x="!dname";    _ini.!settings.x = dname
     x="!gname";    _ini.!settings.x = gname
     x="!lname";    _ini.!settings.x = lpath||gname||"_log.txt"
     x="!fname";    _ini.!settings.x = lpath||gname||"_figs.txt"
     x="!vname";    _ini.!settings.x = lpath||gname||"_voids.txt"
     x="!vwname";   _ini.!settings.x = lpath||gname||"_view.txt"
     x="!pname";    _ini.!settings.x = lpath||gname||".prt"
     x="!sname";    _ini.!settings.x = lpath||gname||".sct"
     x="!rpname";   _ini.!settings.x = lpath||gname||"_ref.prt"
     x="!rsname";   _ini.!settings.x = lpath||gname||"_ref.sct"
     x="!mname";    _ini.!settings.x = lpath||gname||".map"
     x="!zname";    _ini.!settings.x = lpath||gname||".ztm"
     x="!nfname";   _ini.!settings.x = lpath||gname||"_nearfig.txt"

    return sectionlist

/** _dwords v.2 **/
    _dwords: procedure expose (globals)
     rslt=words(translate(arg(1),arg(2)||" "," "||arg(2)))
    return rslt

/** _dword v.2 **/
    _dword: procedure expose (globals)
     rslt=translate(word(translate(arg(1),arg(3)||" "," "||arg(3)),arg(2))," "||arg(3),arg(3)||" ")
    return rslt

    _undef: procedure expose (globals)
     if arg(1)="##UNDEF##" then return 1; else return 0

/** _getservertime v.7 **/
    _getservertime: procedure expose (globals)

     /* get real date/time values */
        parse value date("N") with . . year
        parse value date("O") with . "/" month "/" day
        sod=time("S")
        parse value time("N") with hr ":" mn ":" sc
        doy=date("D")
        base=date("B")
        leapyear=abs((year//4=0)-1)
        base=base-_baseday.2000
        base_sec=base*86400+sod

     /* get game date/time values */
        if _g.!timediff="_G.!TIMEDIFF" then do
         if _sendwait("ct","(?=Help)? T")=640 then call _error "timeout"
         if _waitmux(", "||year+11||"|, "||year+12||"|, "||year+13)=640 then call _error "timeout"
         parse value _lastline() with g_hr ":" g_min ":" g_sec g_ampm . g_month g_day ", " g_year .
         call zocsend "q"
         g_year=g_year-12
         if g_ampm="PM" & g_hr\=12 then g_hr=g_hr+12
         g_month=lower(g_month)
         do i=12 to 1 by -1
          if g_month=_dword(_monthnames,i,";") then leave
         end /*do*/
         g_month=i
         parse value _calc_base_date(g_year, g_month, g_day, g_hr, g_min, g_sec) with g_base ";" g_doy ";" g_sod ";" g_base_sec
         _g.!timediff=base_sec-g_base_sec
        end /*if*/
        else do
         g_base_sec=base_sec-_g.!timediff
         g_sod=g_base_sec//86400
         g_base=g_base_sec%86400
         do i=2000 to 2008
          if (_baseday.i-_baseday.2000)<=g_base then g_year=i
         end /*do*/
         g_doy=g_base-_baseday.g_year+_baseday.2000
        end /*else*/

     select
      when arg(1)="seconds"   then rslt=g_sod
      when arg(1)="minutes"   then rslt=g_sod%60
      when arg(1)="hours"     then rslt=g_sod%3600
      when arg(1)="stamp_old" then rslt=g_year-2000||copies("0",3-length(g_doy))||g_doy||copies("0",5-length(g_sod))||g_sod
      when arg(1)="stamp"     then rslt=g_base_sec
      otherwise                    rslt=g_base_sec
     end /*select*/
    return rslt

/** _getbusts v.2 **/
    _getbusts: procedure expose (globals)
     fname=arg(1)
     if arg(2,"E") then safedate=arg(2)
                   else safedate=0
     _bust.=0
     max=0

     if _fileopenr(fname) then do
      do while \_fileeof(fname)
       line=linein(fname)
       parse var line cmd . sector . stamp .
       if lower(sector)\="all" & sector\="" then max=max(max,sector)
       select
        when cmd="BUST_CLR" & (lower(sector)="all" | sector=0) then do
         do i=1 to max
          if stamp>abs(_bust.i) & _bust.i\=0 then _bust.i=-stamp
         end /*do*/
        end /*when*/
        when abs(_bust.sector)>stamp then nop
        when cmd="BUST_ADD" & safedate=0     then _bust.sector=stamp
        when cmd="BUST_ADD" & safedate>stamp then _bust.sector=-stamp
        when cmd="BUST_CLR"                  then _bust.sector=-stamp
        otherwise nop
       end /*select*/
      end /*do*/
      call _fileclose fname
     end /*if*/

     call _newline _ansi("bt;fwh")
     call zocwriteln "BUST LIST:"
     count=0
     earliest=999999999
     do i=1 to max
      if _bust.i>0 then do
       count=count+1
       call zocwrite _pad(i,6,"R")
       earliest=min(earliest,_bust.i)
       if count//12=0 then call zocwriteln
      end /*if*/
     end /*do*/
     if count//12>0 then call zocwriteln

    return earliest

/** _getvoids v.7 **/
    _getvoids: procedure expose (globals)
     fname=arg(1)
     mode=arg(2)
     _v.=0
     c=0
     if lower(mode)="file" then do
      if _fileopenr(fname) then do
       call zocwrite _ansi("bt;fye")
       mon=_spinner(0,100,"VvVvV")
       do while \_fileeof(fname)
        n=linein(fname)
        if _stripint(n)\=0 then do
         _v.n=1
         c=c+1
         mon=_spinner(mon,100,"VvVvV")
        end /*if*/
       end /*do*/
       call _fileclose(fname)
       call zocwrite " ("||c||") "||_ansi("dl;fmg")
      end /*if*/
     end /*if*/
     else do
      buflen=16*1024
      call zocreceivebuf buflen
      if _sendwait("cx","<List Avoided Sectors>")=640 then call _error "timeout"
      if zocwait("Computer command")=640 then call _error "timeout"
      call zocsend "q"
      if zocwaitmux("Command [", "Citadel command")=640 then call _error "timeout"
      buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
      if length(buff)=buflen then call _error "buffer overflow"
      call zocwrite _ansi("bt;fye")

      s=0
      i=0
      j=0
      i=pos("<List Avoided Sectors>",buff)
      i=pos(d2c(13),buff,i)+1
      i=pos(d2c(13),buff,i)+1
      j=pos(d2c(13),buff,i)
      mon=_spinner(0,100,"VvVvV")
      do while j>0
       line=_space(substr(buff,i,j-i),1)
       if line="" then leave
       if line="No Sectors are currently being avoided." then leave
       do k=1 to words(line)
        s1=_stripint(word(line,k))
        if s1\="" then do
         _v.s1=1
         c=c+1
         s=max(s,s1)
        end /*if*/
       end /*do*/
       i=j+1
       j=pos(d2c(13),buff,i)
       mon=_spinner(mon,100,"VvVvV")
      end /*do*/
      call zocwrite " ("||c||") "||_ansi("dl;fmg")
      if fname\="" then do
       if _fileexists(fname) then call dosdel fname
       if _filenew(fname) then do
        call zocwrite _ansi("bt;fye")
        mon=_spinner(0,100,"VvVvV")
        do i=1 to s
         if _v.i then do
          call lineout fname, i
          mon=_spinner(mon,100,"VvVvV")
         end /*if*/
        end /*do*/
        call _fileclose(fname)
        call zocwriteln " "||_ansi("dl;fmg")
       end /*if*/
      end /*if*/
     end /*else*/

    return c

/** _getinfo v.5 **/
    _getinfo: procedure expose (globals)
     args=lower(arg(1))
     bufflen=32*1024
     call zocreceivebuf bufflen
     call zocsend "/"
     if _wait("Sect ")=640 then call _error "timeout"
     if _wait("Ship ")=640 then call _error "timeout"
     if _wait("^M")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)>=bufflen then call zocwrite "<buffer overflow>"
     i=pos("Sect ",buff)
     j=pos("Ship",buff,i)
     j=pos(d2c(13),buff,j)
     buff=substr(buff,i,j-i)
     buff=_space(translate(buff, "  ~;", d2c(0)||d2c(10)||d2c(13)||d2c(179)),1)
     buff=translate(_space(translate(buff,", "," ,"),0),", "," ,")

     buff2=strip(_dword(buff,1,"~"))
     do i=2 to _dwords(buff,"~")
      buff2=buff2||";"||strip(_dword(buff,i,"~"))
     end
     buff=buff2
     drop buff2

     /* analyze buffer */
     vr.=""
     vl.=""
     c=0
     do j=1 to _dwords(buff,";")
      c=c+1
      vr.c=strip(_dword(buff,j,";"))
      vl.c=word(vr.c,2)
      vr.c=lower(word(vr.c,1))
      if vr.c="ship" then do
       c=c+1
       vr.c=strip(_dword(buff,j,";"))
       vl.c=word(vr.c,3)
       vr.c="shiptype"
      end /*if*/
     end /*do*/
     c=c+1
     vr.c="all"
     vl.c=buff

     /* set gobal vars */
     _qs.!corp=0
     do i=1 to c
      tag="!"||upper(vr.i)
      _qs.tag=vl.i
     end /*do*/

     /* pass our requested stats */
     rslt=""
     do i=1 to _dwords(args,";")
      found=0
      do j=1 to c
       if vr.j=_dword(args,i,";") then do
        rslt=rslt||";"||vl.j
        found=1
       end /*if*/
      end /*do*/
      if \found then rslt=rslt||";"||"##NA##"
     end /*do*/
     if rslt\="" then rslt=substr(rslt,2)

    return rslt

/** _sendwait v.1 **/
    _sendwait: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _sendwait"
     call zocsend arg(1)
     rslt=_wait(arg(2))
     select
      when \arg(3,"E") | arg(3)=""             then nop
      when lower(arg(3))="timeout"  & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline" & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline"            then rslt=_lastline()
      otherwise nop
     end /*select*/
    return rslt

    /* _parse_ship_desc v.1 */
    _parse_ship_desc:  procedure expose (globals)
     buff=arg(1)
     rslt=""

     i=pos("Basic Hold Cost:",buff)
     j=pos(d2c(13),buff,i)
     line.1=strip(substr(buff,i,j-i))
     parse var line.1 ":" basicholdcost . ":" initialholds . ":" maximumshields .
     basicholdcost=_stripcomma(strip(basicholdcost))
     maximumshields=_stripcomma(strip(maximumshields))

     i=pos("Main Drive Cost:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.2=strip(substr(buff,i,j-i))
     parse var line.2 ":" maindrivecost . ":" maxfighters . ":" offensiveodds .
     maindrivecost=_stripcomma(strip(maindrivecost))
     maxfighters=_stripcomma(strip(maxfighters))
     offensiveodds=_dword(strip(offensiveodds),1,":")

     i=pos("Computer Cost:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.3=strip(substr(buff,i,j-i))
     parse var line.3 ":" computercost . ":" turnsperwarp . ":" defensiveodds .
     computercost=_stripcomma(strip(computercost))
     defensiveodds=_dword(strip(defensiveodds),1,":")

     i=pos("Ship Hull Cost:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.4=strip(substr(buff,i,j-i))
     parse var line.4 ":" shiphullcost . ":" minemax . ":" beaconmax .
     shiphullcost=_stripcomma(strip(shiphullcost))
     minemax=strip(minemax)
     beaconmax=strip(beaconmax)

     i=pos("Ship Base Cost:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.5=strip(substr(buff,i,j-i))
     parse var line.5 ":" shipbasecost . ":" genesismax . ":" longrangescan .
     shipbasecost=_stripcomma(strip(shipbasecost))
     genesismax=strip(genesismax)
     longrangescan=pos("Y",strip(longrangescan))

     i=pos("Max Figs Per Attack:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.6=strip(substr(buff,i,j-i))
     parse var line.6 ":" maxfigsperattack . ":" transwarpdrive . ":" planetscanner .
     maxfigsperattack=_stripcomma(strip(maxfigsperattack))
     transwarpdrive=pos("Y",strip(transwarpdrive))
     planetscanner=pos("Y",strip(planetscanner))

     i=pos("Maximum Holds:",buff,j+1)
     j=pos(d2c(13),buff,i)
     line.7=strip(substr(buff,i,j-i))
     parse var line.7 ":" maximumholds . ":" transportrange . ":" photonmissiles .
     maximumholds=strip(maximumholds)
     transportrange=strip(transportrange)
     photonmissiles=pos("Y",strip(photonmissiles))

     rslt=shipbasecost maxfigsperattack maximumholds initialholds maxfighters turnsperwarp minemax genesismax ,
          transwarpdrive transportrange maximumshields offensiveodds defensiveodds beaconmax longrangescan ,
          planetscanner photonmissiles
     rslt=translate(rslt,";"," ")

    return rslt

    /*

    Which ship are you interested in (?=List) ?
    You shut off the Vid Term.

    Computer command [TL=00:00:00]:[3156] (?=Help)? ;

                                  Corporate FlagShip

         Basic Hold Cost:   10,000   Initial Holds:     20 Maximum Shields: 1,500
         Main Drive Cost:    5,000    Max Fighters: 20,000  Offensive Odds: 1.2:1
           Computer Cost:  120,000  Turns Per Warp:      3  Defensive Odds: 1.2:1
          Ship Hull Cost:   28,500        Mine Max:    100      Beacon Max:   100
          Ship Base Cost:  163,500     Genesis Max:     10 Long Range Scan:   Yes
     Max Figs Per Attack:     6000 TransWarp Drive:    Yes  Planet Scanner:   Yes
           Maximum Holds:       85 Transport Range:     10 Photon Missiles:    No

    Computer command [TL=00:00:00]:[3156] (?=Help)?
    */

/** _ewarp v.2 **/
    _ewarp: procedure expose (globals)

     /* handle arguments */
        do i=1 to 3
         if \arg(i,"E") | (_stripint(arg(i))=0 & _msg="##NAN##") then call _error "invalid or missing parameter in _ewarp"
        end /*do*/
        dest=_stripint(arg(1))
        maxa=_stripint(arg(2))
        odds=_stripnum(arg(3))
        if \arg(4,"E") then crnum=99999
                       else crnum=_stripint(arg(4))
        if crnum=99999 then m="m"
                       else m=""

     /* modes */
        pay=0
        minevoid=0

     /* crm */
        if dest<crnum then crm="^M"
                      else crm=""

     pflag.=1
     figtype="def"
     msg="S"
     done=0

     /* move */
        if _sendwait(m||dest||crm,"<Move>")=640 then call _error "timeout"

     do while \done
      ans=zocwaitmux("Your fighters:", ,
                     "Mined Sector:", ,
                     "*** Error - No route within", ,
                     "Stop in this sector", ,
                     "An Interdictor Generator in", ,
                     "Command [", ,
                     "[Toll]", ,
                     "Sector  :", ,
                     "Engage the Autopilot?", ,
                     "engage the TransWarp drive?", ,
                     "Quasar Blast!", ,
                     "[Pause]", ,
                     "Life Support knocked out!", ,
                     "You fled from", ,
                     "You fled in your Escape Pod", ,
                     "Shipboard Computers")
      select

       /* Your fighters: */
          when ans=0 & figtype="toll" & pay=1 then do
            call zocsend "py"
            figtype="def"
            msg=msg||"T"
          end /*when*/

          when ans=0 then do
            line=_grabit("^M")
            parse var line f1 . . f2
            f1=_stripint(f1)
            f2=_stripint(f2)
            if f1\="" & f2\="" then do
             a=f2%odds+1
             select
               when a>f1 then do
                call zocsend "r"
                msg=msg||"R"
               end /*when*/
               when a>maxa then do
                call zocsend "a"||maxa||"^M"
                f1=f1-maxa
                msg=msg||"K"
               end /*when*/
               otherwise do
                call zocsend "a"||min(maxa,f1)||"^M"
                f1=f1-a
                msg=msg||"K"
               end /*otherwise*/
             end /*select*/
             /* if f1<maxa then msg=msg||"L" */
            end /*if*/
          end /*when*/

       /* Mined Sector: */
          when ans=1 & minevoid then do
            call zocsend "y"
            _v.curremt=1
          end /*when*/
          when ans=1            then call zocsend "n"

       /* *** Error - No route within ... Clear Avoids? */
          when ans=2 then do
            parse value _grabit("to sector") with . . . . current
            current=_stripint(current)
            call zocsend "n"
            msg=msg||"V"
          end /*when*/

       /* Stop in this sector */
          when ans=3 & pflag.3 then do
           call zocsend "n"
           pflag.3=0
          end /*when*/

       /* An Interdictor Generator in */
          when ans=4 then msg=msg||"I"

       /* Command [ */
          when ans=5 then done=1

       /* [Toll] */
          when ans=6 then figtype="toll"

       /* Sector  : */
          when ans=7 then do
           temp=_stripint(_grabit("in"))
           if temp\=current then last=current
           current=temp
           figtype="def"
           pflag.=1
          end /*when*/

       /* Engage the Autopilot? */
          when ans=8 & pflag.1 then do
           call zocsend "e"
           pflag.1=0
          end /*when*/

       /* engage the TransWarp drive? */
          when ans=9 & pflag.2 then do
           call zocsend "n"
           pflag.2=0
          end /*when*/

       /* Quasar Blast! */
          when ans=10 then msg=msg||"Q"

       /* [Pause] */
          when ans=11 then call zocsend "^M"

       /* You fled from */
          when ans=13 then msg=msg||"F"

       /* You fled in your Escape Pod / Life Support knocked out! */
          when ans=14 | ans=12 then msg=msg||"P"

       /* Shipboard Computers */
          when ans=15 then msg=msg||"A"

          when ans=640 then call _error "timeout"
          otherwise nop

      end /*select*/
     end /*do*/

     msg=msg||";"||current||";"||last

    return msg

/** _portsteal_fast v.3 **/
    _portsteal_fast: procedure expose (globals)
     if arg(1,"E") then amount=_stripint(arg(1))
     else amount=0
     if amount="" then amount=0
     if amount<0 then amount=0
     if arg(2,"E") then prod=_stripint(arg(2))
     else prod=3
     if prod\=1 | prod\=2 | prod\=3 then prod=3

     prodn=_dword("Fuel Ore;Organics;Equipment",prod,";")

     buflen=8*1024
     call zocreceivebuf buflen
     call zocsend "pr^Msz"||prod||amount||"^M"

     done=0
     do while \done
      ans=zocwaitmux(" Success!", ,
                     " Busted!", ,
                     " at this port!", ,
                     "You leave the port.")
      line=strip(_lastline())
      select
       when ans=0 & line="You start your droids loading the cargo and Success!" then do
        msg="##SUCCESS##"
        done=1
       end /*when*/
       when ans=1 & line="You start your droids loading the cargo and Suddenly you're Busted!" then do
        msg="##BUST##"
        done=1
       end /*when*/
       when ans=1 & line="Suddenly you're Busted!" then do
        if zocwait("Do you want instructions (Y/N) [N]?")=640 then call _error "timeout"
        msg="##FAKE##"
        done=1
       end /*when*/
       when ans=2 & line="There aren't that many holds of "||prodn||" at this port!" then do
        msg="##HOLDS##"
        done=1
       end /*when*/
       when ans=3 & line="You leave the port." then do
        msg="##ZERO##"
        done=1
       end /*when*/
       when ans=640 then call _error "timeout"
       otherwise nop
      end /*select*/
     end /*do*/

     if zocwait("Command [")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0), "  ", d2c(0)||d2c(10))
     if length(buff)=buflen then call _error "buffer overflow"

     exp=0
     amount=0
     avail=0
     holds=0
     fine=0
     turns=9999

     /* GET TURNS */
     k=max(pos("<Thievery>",buff),1)
     i=pos("One turn deducted, ",buff,k)+19
     if i>19 then do
      j=pos(" turns left.",buff,i)
      if j>0 then turns=substr(buff,i,j-i)
     end /*if*/
     else j=k

     select
      when msg="##SUCCESS##" then do
       i=pos(prodn,buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with . . avail .
       i=pos("to swipe? [",buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with holds "] " amount .
       i=pos("and you receive ",buff,j)+16
       if i>16 then j=pos(" experience",buff,i)
       else j=0
       if j>0 then exp=substr(buff,i,j-i)
      end /*when*/

      when msg="##BUST##" then do
       i=pos(prodn,buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with . . avail .
       i=pos("to swipe? [",buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with holds "] " amount .
       i=pos("fines you ",buff,j)+10
       j=pos(" Cargo Holds",buff,i)
       fine=substr(buff,i,j-i)
       i=pos("and you LOSE ",buff,j)+13
       j=pos(" experience",buff,i)
       exp=substr(buff,i,j-i)
      end /*when*/

      when msg="##FAKE##" then do
       i=pos("fines you ",buff,j)+10
       j=pos(" Cargo Holds",buff,i)
       fine=substr(buff,i,j-i)
       i=pos("and you LOSE ",buff,j)+13
       j=pos(" experience",buff,i)
       exp=substr(buff,i,j-i)
      end /*when*/

      when msg="##HOLDS##" then do
       i=pos(prodn,buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with . . avail .
       i=pos("to swipe? [",buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with holds "] " amount .
       amount=0
      end /*when*/

      when msg="##ZERO##" then do
       i=pos(prodn,buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with . . avail .
       i=pos("to swipe? [",buff,j)+11
       j=pos(d2c(13),buff,i)
       parse value substr(buff,i,j-i) with holds "] " amount .
       amount=0
      end /*when*/

      otherwise nop

     end /*select*/

     rslt=msg||";"||exp||";"||amount||";"||avail||";"||holds||";"||turns||";"||fine

    return rslt

/** _quit v.7 **/
    _quit: procedure expose (globals)
     lcpy=1
     arg1=""
     do i=1 to 2 /* manage arguments */
      select
       when arg(i,"E") & lower(arg(i))="nocopy" then lcpy=0
       when arg(i,"E") & arg1="" then arg1=arg(i)
       otherwise nop
      end /*select*/
     end /*do*/
     line=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
     select /* define message */
      when  lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m^M^J"||line
      when \lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m "
      when  lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m^M^J"||line
      when \lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m "
      otherwise nop
     end /*select*/
     call zocwrite msg
     select /* choose a beep */
      when lower(arg1)="script cancelled by user." then call _beep "cancel.wav"
      otherwise call _beep "quit.wav"
     end /*select*/
     exit
    return 1

/** _bust_tool v.1 **/
    _bust_tool: procedure expose (globals)
     cmd=arg(1)
     sector=arg(2)
     stamp=arg(3)
     fname=arg(4)
     note=arg(5)
     msg=upper(cmd)||" : "||_pad(sector,5,"R")||" : "||stamp
     if note\="" then msg=msg||" : "||note
     if _fileopenw(fname) then do
      call lineout fname, msg
      call _fileclose fname
     end /*if*/
     else call _error "unable to open file "||fname||"."
    return

/** _bust_memo v.1 **/
    _bust_memo: procedure expose (globals)
     cmd=arg(1)
     sector=arg(2)
     stamp=arg(3)
     msg="REV-CMD : "||cmd||" : "||_pad(sector,5,"R")||" : "||stamp||" ::"
     call zocsend "tt"||msg||"^M^Mq"
     if zocwait("Corporate M.A.I.L. Server.")=640 then call _error "timeout"
     if zocwait("(?=Help)? :")=640 then call _error "timeout"
    return

/** _roundup v.2 **/
    _roundup: procedure expose (globals)
     if arg(1,"E") then num=arg(1); else call _error "missing parameter in _roundup"
     if arg(2,"E") then digits=arg(2); else digits=0
     num=num*(10**digits)
     if num>trunc(num) then num=trunc(num)+1
     else num=trunc(num)
     num=num/(10**digits)
    return num

/** _stripint v.4 **/
    _stripint: procedure expose (globals)
     mask=_space(translate(arg(1)," ","-0123456789,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripint"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if length(rslt)>9 then rslt=left(rslt,9)
      rslt=neg||rslt
     end /*else*/
    return rslt

/** _grabit v.2 **/
    _grabit: procedure expose (globals)
     if _wait(arg(1))=640 then call _error "timeout"
     rslt=_lastline()
     if lower(arg(2))="s" then rslt=reverse(substr(reverse(rslt),length(arg(1))+1))
    return rslt

/** _ini_write v.3 **/
    /*_ v.3 tested -*/
    _ini_write: procedure expose (globals)
     /* argument check */
     do i=1 to 4
      if \arg(i,"E") | arg(i,"O") then call _error "missing arguments in _ini_write."
     end /*do*/

     /* name arguments */
     fname=arg(1)
     s=strip(arg(2))
     k=strip(arg(3))
     v=strip(arg(4))

     tname=fname||".tmp"
     written=0

     rslt=0
     if _fileopenr(fname) then do
      if _fileexists(tname) then if \dosdel(tname) then call _error "file delete failed."
      if _fileopenw(tname) then do
       insection=0
       linenum=0
       do while \_fileeof(fname)
        line=strip(linein(fname))
        linenum=linenum+1
        select
         when line="["||s||"]" then do
          insection=1
          if linenum>1 then call lineout tname, ""
          call lineout tname, line
          call charout tname, k||"="||v
          written=1
         end /*when*/
         when insection & left(line,length(k)+1)=k||"=" then nop
         when insection & left(line,1)="[" then do
          if linenum>1 then call lineout tname, ""
          call charout tname, line
          insection=0
         end /*when*/
         when line="" then do
          if linenum>1 then call lineout tname, ""
          call charout tname, ""
         end /*when*/
         otherwise do
          if linenum>1 then call lineout tname, ""
          call charout tname, line
         end /*otherwise*/
        end /*select*/
       end /*do*/
       if \written then do
        if linenum>1 then call lineout tname, ""
        call lineout tname, "["||s||"]"
        call charout tname, k||"="||v
        written=1
       end /*if*/
       call _fileclose(tname)
      end /*if*/
      call _fileclose(fname)
     end /*if*/
     if written then do
      if \dosdel(fname) then call _error "file delete failed."
      if \dosrename(tname,fname) then call _error "file rename failed."
     end /*if*/
     else do
      if \_fileexists(fname) then do
       if _filenew(fname) then do
        call lineout fname, "["||s||"]"
        call charout fname, k||"="||v
        call _fileclose(fname)
        written=1
       end /*if*/
      end /*if*/
     end /*else*/
    return written

/** _cost_holds v.1 **/
    _cost_holds: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _calc_holds"
     cost=arg(1)
     num=arg(2)
     rslt=0
     do i=1 to num
      rslt=rslt+cost
      cost=cost+20
     end /*do*/
    return rslt

/** _ds v.3 **/
    _ds: procedure expose (globals)
     if _d.1="_D.1" then _d.=""
     line.=""
     i=0
     done=0
     dsin=0
     rslt=""

     select
      when \arg(1,"E") then call zocsend "sd"
      when arg(1)=0 then call _error "no holoscanner"
      when arg(1)=1 then call zocsend "s"
      when arg(1)=2 then call zocsend "sd"
      when arg(1)=3 then call zocsend arg(2)
      otherwise call zocsend "sd"
     end /*select*/
     do while \done
      ans=zocwaitmux("No",,
                     "Yes",,
                     "You don't have a long range scanner.",,
                     "Relative Density Scan",,
                     "(?=Help)? :")
      select
       when ans<2 & dsin then do
        i=i+1
        line.i=translate(strip(_lastline()),"  ","()")
       end /*when*/
       when ans=2 then done=1
       when ans=3 then dsin=1
       when ans=4 & dsin then done=1
       when ans=4 then nop
       otherwise nop
      end /*select*/
     end /*do*/
     max=i

     rslt=""
     do i=1 to max
      parse var line.i . adj . dens . . nw . . haz . . anom .
      dens=_stripcomma(dens)
      haz=strip(translate(haz," ","%"))
      if anom="No" then anom=0
                   else anom=1
      parse var _d.adj last ";" .
      _d.adj=dens||","||nw||","||haz||","||anom||";"||last
      rslt=rslt||";"||adj
     end /*do*/
     rslt=substr(rslt,2)
    return rslt

/** _holoscan v.3 **/
    _holoscan: procedure expose (globals)
     call zocsend "sh"
     if zocwait("Long Range Scan")=640 then call _error "timeout"
     done=0
     rslt=""
     success=1
     do while \done
      ans=zocwaitmux("Sector  :",,
                     "Ports   :",,
                     "Fighters:",,
                     "Traders :",,
                     "Ships   :",,
                     "Planets :",,
                     "Relative Density Scan",,
                     "(?=Help)? :")
      select
       when success & ans=0 then do
        cs=_stripint(_grabit("in"))
        if rslt="" then rslt=cs
        else rslt=rslt||";"||cs
        _sv.cs=1
       end /*when*/
       when success & ans=1 & _p.cs="" then _p.cs=left(right(_grabit(")"),4),3)||";"
       when success & ans=2 then do
        line=_grabit("^M")
        parse var line figs "(" owner ")"
        _f.cs=0
        _ef.cs=0
        select
         when owner="yours" then               _f.cs=1
         when owner="belong to your Corp" then _f.cs=1
         otherwise                             _ef.cs=1
        end /*select*/
       end/*when*/
       when success & ans=3 then _et.cs=1
       when success & ans=4 then _es.cs=1
       when success & ans=5 then _ep.cs=1
       when ans=6 then do
        call zocsend "^M"
        success=0
       end /*when*/
       when ans=7 then done=1
       when ans=640 then call _error "timeout"
       otherwise nop
      end /*select*/
     end /*do*/
     if success then rslt=left(rslt,lastpos(";",rslt)-1)
     else rslt="##NO HOLO##"
    return rslt

/** _portmatch v.1 **/
    _portmatch: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _portmatch"
     m1=lower(strip(arg(1)))
     m2=lower(strip(arg(2)))
     rslt=0
     select
      when length(m1)\=3 then nop
      when length(m2)\=3 then nop
      when m1=m2 then rslt=1
      otherwise do
       mm1=0
       if left(m1,1)="x" then mm1=1
       if left(m2,1)="x" then mm1=1
       if left(m1,1)=left(m2,1) then mm1=1
       mm2=0
       if substr(m1,2,1)="x" then mm2=1
       if substr(m2,2,1)="x" then mm2=1
       if substr(m1,2,1)=substr(m2,2,1) then mm2=1
       mm3=0
       if substr(m1,3,1)="x" then mm3=1
       if substr(m2,3,1)="x" then mm3=1
       if substr(m1,3,1)=substr(m2,3,1) then mm3=1
       if mm1 & mm2 & mm3 then rslt=1
      end /*otherwise*/
     end /*select*/
    return rslt

/** _dsinfo v.2 **/
    _dsinfo: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _dsinfo"
     ds1=arg(1)
     param=lower(arg(2))
     parse var _d.ds1 dens "," nw "," haz "," anom ";" .
     select
      when param="d" then rslt=dens
      when param="w" then rslt=nw
      when param="n" then rslt=haz
      when param="a" then rslt=anom
      otherwise rslt=0
     end /*select*/
    return rslt

/** _space v.1 **/
    _space: procedure expose (globals)
     str=strip(arg(1))
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then pad=arg(3); else pad=" "
     rslt=word(str,1)
     do i=2 to words(str)
      rslt=rslt||copies(pad,n)||word(str,i)
     end /*do*/
    return rslt

/** _synchronize_vars v.1 **/
    _synchronize_vars: procedure expose (globals)
     select
      when arg(1)="w" then rslt="Pausing",
                              ||"|Command [",
                              ||"|Citadel command",
                              ||"|Planet command",
                              ||"|<StarDock>",
                              ||"|ship to sell",
                              ||"|Still interested ?",
                              ||"|wish to buy? (A,B,C,Q,?)",
                              ||"|<Galactic Bank>",
                              ||"|<Hardware Emporium>",
                              ||"|<Shipyards>",
                              ||"|<Tavern>",
                              ||"|Enter your choice [T] ?",
                              ||"|do you want to sell [",
                              ||"|do you want to buy [",
                              ||"|Computer command",
                              ||"|Corporate command",
                              ||"|Colonists? [T]",
                              ||"|Stop in this sector (Y,N,E,I,R,S,D,P,?) (?=Help) [N]",
                              ||"|`",
                              ||"|F: ",
                              ||"|'",
                              ||"|S: ",
                              ||"|M: ",
                              ||"|P: "
      when arg(1)="r" then rslt="unknown;command;citadel;planet;stardock;ship_sell;ship_sell_interested;class_0",
                             ||";bank;hardware;shipyards;tavern;port_menu;port_haggle;port_haggle;computer",
                             ||";corporate;terra;stop_in_this_sector?;fedcom_text_entry_1;fedcom_text_entry_2",
                             ||";subspace_text_entry_1;subspace_text_entry_2;mail_text_entry;private_text_entry",
                             ||";corporate_cit;computer_cit;unknown_text_entry" /* <-- these unmatched in the wait string above */
      when arg(1)="command" then rslt=" ; ;qq;q;q;qqq;nqq;q;qq;qq;qq;qq;q;0^Mz0^Mz0^M;0^Mz0^Mz0^M;q;q;q;y;^H;^M;^H;^M;^M;^M;qqq;qqq; "
      when arg(1)="computer" then rslt=" ;c;c;qc;qc;qqqc;nqqc;qc;qqc;qqc;qqc;qqc;qc;0^Mz0^Mz0^Mc;0^Mz0^Mz0^Mc; ;qc;qc;yc;^Hc;^Mc;^Hc;^Mc;^Mc;^Mc;qc;qc; "
      otherwise call _error "unknown argument in _synchronize_vars"
     end /*select*/
    return rslt

/** _waitmux v.1 **/
    _waitmux: procedure expose (globals)
     rslt=zocwaitmux(arg(1))
    return rslt

/** _wait v.1 **/
    _wait: procedure expose (globals)
     rslt=zocwait(arg(1))
    return rslt

/** _ansi v.3 **/
    _ansi: procedure expose (globals)
     rslt="0"
     pre=""
     do i=1 to _dwords(arg(1),";")
      w=_dword(arg(1),i,";")
      select
       when w="clearline" then pre=pre||"^[[100D^[[K"
       when w="dl"  then rslt=rslt||";"||0  /* dull               */
       when w="bt"  then rslt=rslt||";"||1  /* bright             */
       when w="ul"  then rslt=rslt||";"||4  /* underlined         */
       when w="blk" then rslt=rslt||";"||5  /* blinking           */
       when w="fbk" then rslt=rslt||";"||30 /* black foreground   */
       when w="frd" then rslt=rslt||";"||31 /* red foreground     */
       when w="fgr" then rslt=rslt||";"||32 /* green foreground   */
       when w="fye" then rslt=rslt||";"||33 /* yellow foreground  */
       when w="fbl" then rslt=rslt||";"||34 /* blue foreground    */
       when w="fmg" then rslt=rslt||";"||35 /* magenta foreground */
       when w="fcy" then rslt=rslt||";"||36 /* cyan foreground    */
       when w="fwh" then rslt=rslt||";"||37 /* white foreground   */
       when w="bbk" then rslt=rslt||";"||40 /* black background   */
       when w="brd" then rslt=rslt||";"||41 /* red background     */
       when w="bgr" then rslt=rslt||";"||42 /* green background   */
       when w="bye" then rslt=rslt||";"||43 /* yellow background  */
       when w="bbl" then rslt=rslt||";"||44 /* blue background    */
       when w="bmg" then rslt=rslt||";"||45 /* magenta background */
       when w="bcy" then rslt=rslt||";"||46 /* cyan background    */
       when w="bwh" then rslt=rslt||";"||47 /* white background   */
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=pre||"^[["||rslt||"m"
    return rslt

/** _beep v.2 **/
    _beep: procedure expose (globals)
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then d=arg(3); else d=0
     select
      when arg(1,"O") then call zocwrite copies(d2c(7),n)
      when _fileexists(arg(1)) then do
       do i=1 to n
        call zocplaysound arg(1)
        if i\=n & d>0 then call zocdelay d
       end /*do*/
      end /*when*/
      otherwise call zocwrite copies(d2c(7),n)
     end /*select*/
    return

/** _get_log_path v.2 **/
    _get_log_path: procedure expose (globals)
     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid path in _get_log_path"
    return lpath

/** _get_script_path v.1 **/
    _get_script_path: procedure expose (globals)
     parse value zocgetglobaloption("ScriptPath") with . '="' spath '"'
     spath=dosfname(spath)
     if right(spath,1)\="\" then spath=spath||"\"
     if \dosisdir(spath) then call _error "invalid path in _get_script_path"
    return spath

/** _get_download_path v.2 **/
    _get_download_path: procedure expose (globals)
     parse value zocgetglobaloption("DownloadAltPath") with . '="' dpath '"'
     dpath=dosfname(dpath)
     if right(dpath,1)\="\" then dpath=dpath||"\"
     if \dosisdir(dpath) then call _error "invalid path in _get_download_path"
    return dpath

/** _setgame v.6 **/
    _setgame: procedure expose (globals)

     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid log path in _setgame"

     if arg(1,"E") then gname=arg(1)
     else do
      list=_ini_list_games(lpath)
      if c=0 then gname="CLEAR"
      else gname=_drequestlist("select a game:", list||";CLEAR", ";", "c")
     end /*if*/
     if gname="CLEAR" | gname="" then gname="%ZOCORHOST% %OPTIONS%"
     call zocsetglobaloption 'WindowTitle="'||gname||'"'
    return gname

/** _fileopenr v.4 **/
    _fileopenr: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenr"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN READ"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

/** _fileeof v.4 **/
    _fileeof: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileeof"
      when arg(1)="" then rslt=0
      otherwise rslt=\lines(arg(1))
     end /*select*/
    return rslt

    _ini_is_section: procedure expose (globals)
     s=strip(arg(1))
     if left(s,1)="[" & left(reverse(s),1)="]" then return 1
    return 0

/** _ini_format_value **/
    _ini_format_value: procedure expose (globals)
     v=arg(1)
     if _dwords(v,"=")=2 then do
      t=lower(_dword(v,1,"="))
      v=_dword(v,2,"=")
      select
       when t="i" then v=_stripint(v)
       when t="f" then v=_stripnum(v)
       when t="b" then do; v=_stripint(v); if v>0 then v=1; else v=0; end
       when t="s" then nop
       otherwise nop
      end /*select*/
     end /*if*/
    return v

/** _fileclose v.3 **/
    _fileclose: procedure expose (globals)
     if \arg(1,"E") then call _error "missing argument in _fileclose"
     select
      when arg(1)="" then nop
      otherwise call stream arg(1), "C", "CLOSE"
     end /*select*/
    return

/** _lastline v.3 **/
    _lastline: procedure expose (globals)
     rslt=zoclastline()
     select
      when lower(arg(1))="raw" then nop
      when pos(d2c(7),rslt)>0  then rslt=translate(zocstring("REMOVE", rslt, d2c(7)),"  ",d2c(0)||d2c(10))
      otherwise                     rslt=translate(rslt,"  ",d2c(0)||d2c(10))
     end /*select*/
    return rslt

/** _calc_base_date v.3 **/
    /* v.3 tested */
    _calc_base_date: procedure expose (globals)

     yr=arg(1); mm=arg(2); dd=arg(3); hr=arg(4); mn=arg(5); sc=arg(6)

     /* leapyear? */
        leapyear=abs((yr//4=0)-1)

     /* day of year */
        doy=dd-1
        do i=1 to mm-1
         doy=doy+_dword(_monthdays,i,";")
        end /*do*/
        if mm>2 & leapyear then doy=doy+1

     /* base day since 2000 */
        base=_baseday.yr-_baseday.2000+doy

     /* seconds of day */
        sod=((hr*60)+mn)*60+sc

     /* base day in seconds */
        base_sec=base*86400+sod

     rslt=base||";"||doy||";"||sod||";"||base_sec

    return rslt

/** _newline v.3 **/
    _newline: procedure expose (globals)
     if zocgetinfo("CURSOR-X")>0 then call zocwriteln
     if arg(1,"E") then call zocwrite arg(1)
    return

/** _pad v.2 **/
    _pad: procedure expose (globals)
     rslt=arg(1)
     if arg(2,"E") then w=arg(2); else return rslt
     if \arg(3,"E") then m="L"; else m=lower(arg(3))
     if \arg(4,"E") then p=" "; else p=left(arg(4),1)
     select
      when m="l" then rslt=left(rslt,w,p)
      when m="r" then rslt=reverse(left(reverse(rslt),w,p))
      when m="c" then rslt=center(rslt,w,p)
      otherwise       rslt=left(rslt,w,p)
     end /*select*/
    return rslt

/** _spinner v.3 **/
    _spinner: procedure expose (globals)
     if arg(1,"E") then count=arg(1)
                   else call _error "missing parameter in _spinner"
     if arg(2,"E") then width=arg(2)
                   else width=100
     if arg(3,"E") & length(arg(3))=5 then chs=arg(3)
                                      else chs="-\|/."
    /* bs="^H" */
     bs=d2c(27)||"[1D"
     select
      when count=-1        then call zocwrite bs||substr(chs,5,1)
      when count<0         then count=-1
      when count=0         then call zocwrite left(chs,1)
      when count=width     then call zocwrite bs||substr(chs,2,1)
      when count=(width*2) then call zocwrite bs||substr(chs,3,1)
      when count=(width*3) then call zocwrite bs||substr(chs,4,1)
      when count=(width*4) then do
       call zocwrite bs||left(chs,1)
       count=0
      end /*when*/
      otherwise nop
     end /*select*/
     count=count+1
    return count

/** _fileexists v.4 **/
    _fileexists: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileexists"
      when arg(1)="" then rslt=0
      when stream(arg(1), "C", "QUERY EXISTS")="" then rslt=0
      otherwise rslt=1
     end /*select*/
    return rslt

/** _filenew v.4 **/
    _filenew: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _filenew"
      when arg(1)="" then rslt=0
      otherwise do
       if arg(2,"E") & lower(arg(2))="delete" then call dosdel arg(1)
       if _fileexists(arg(1)) then rslt=0
       else do
        call stream arg(1), "C", "OPEN WRITE"
        rslt=_fileready(arg(1))
        if \rslt then call _fileclose arg(1)
       end /*else*/
      end /*otherwise*/
     end /*select*/
    return rslt

/** _stripcomma v.1 **/
    _stripcomma: procedure expose (globals)
     rslt=translate(_space(translate(arg(1),", "," ,"),0)," ",",")
    return rslt

/** _stripnum v.3 **/
    _stripnum: procedure expose (globals)
     w=9
     mask=_space(translate(arg(1)," ","-0123456789.,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripnum"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if left(rslt,1)="." then rslt="0"||rslt
      r=_dword(rslt,1,".")
      m=_dword(rslt,2,".")
      select
       when r=0 & length(m)>w then m=left(m,w)
       when length(r)>w then do; r=left(r,w); m=""; end
       when length(r)=w then m=""
       when length(m)>(w-length(r)) then m=left(m,w-length(r))
       otherwise nop
      end /*select*/
      if m="" then rslt=neg||r; else rstl=neg||r||"."||m
     end /*else*/
    return rslt

/** _fileopenw v.3 **/
    _fileopenw: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenw"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN WRITE"
       call stream arg(1), "C", "SEEK <0"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

    _set_msg: procedure expose (globals)
     i=_msg.0
     if i="_MSG.0" then do; _msg.=""; _msg.0=0; i=0; end
     i=i+1; _msg.0=i; _msg=""
     if arg(1,"E") then do; _msg.i=arg(1); _msg=arg(1); end;
     if arg(2,"E") then _msg.i.!source=arg(2)
     if arg(3,"E") then _msg.i.!comment=arg(3)
    return i

/** _ini_list_games v.1 **/
    _ini_list_games: procedure expose (globals)
     lpath=arg(1)
     parse value zoclistfiles(lpath||"*_data.ini", ";") with c list
     if c=0 then rslt=""
     else do
      n=_dword(list,1,";")
      rslt=left(n,lastpos("_data.ini",n)-1)
      do i=2 to c
       n=_dword(list,i,";")
       rslt=rslt||";"||left(n,lastpos("_data.ini",n)-1)
      end /*do*/
     end /*else*/
    return rslt

/** _drequestlist v.3 **/
    _drequestlist: procedure expose (globals)
     i=zocrequestlist(arg(1),translate(arg(2),"|"||arg(3),arg(3)||"|"))
     select
      when i<0 & lower(arg(4))="c" then call _quit "script cancelled by user.", "nocopy"
      when i<0 then rslt="##CANCEL##"
      otherwise rslt=_dword(arg(2),i+1,arg(3))
     end /*select*/
    return rslt

/** _fileready v.2 **/
    _fileready: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileready"
      when arg(1)="" then rslt=0
      when stream(arg(1), "S")\="NOTREADY" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt
