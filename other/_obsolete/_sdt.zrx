/* REXX _sdt.zrx by the reverend (build 117)                                  */
/*-       built by rev-builder version 1.3a on 17 Oct 2003 at 13:37:32       -*/
/*- ------------------------------------------------------------------------ -*/
/*-                       Copyright (C) 2003 Ron Wilson                      -*/
/*-                                                                          -*/
/*- This script is free, and can be modified for your personal use, but you  -*/
/*- cannot copy or distribute this script or any derivative work based upon  -*/
/*- this script without the express permission of the author. Your use of    -*/
/*- this script is governed by the terms of the REV-LICENSE.                 -*/
/*-                                                                          -*/
/*- This program is provided to you WITHOUT ANY WARRANTY, even the implied   -*/
/*- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the -*/
/*- REV-LICENSE for more details.                                            -*/
/*-                                                                          -*/
/*-                A copy of the REV-LICENSE is available at:                -*/
/*-       http://thereverend.coastgames.com/tradewars/rev-license.html       -*/
/*- ------------------------------------------------------------------------ -*/
/*- -----------------------*/ _g.!sname="_sdt.zrx" /*----------------------- -*/
/*- --------------*/ _g.!sbuild=117; _g.!sdate="2003-10-17" /*-------------- -*/
/*- ------------------------------------------------------------------------ -*/
/* description:  this script will ask you for ship numbers and planet numbers.*/
/*               if you put zero (0) for the planet number, then it will just */
/*               sst at that ship. you can use unlimited ships, and it will   */
/*               steal according to your experience level if you enter the    */
/*               right steal factor. the only limitations are that it won't   */
/*               check to see if ships are close enough - you have to do that */
/*               yourself before running the script. it will steal in your    */
/*               current ship first, and you have to start with your sst ships*/
/*               full of equipment and your sdt ships empty. the script will  */
/*               run until you have only one ship left.                       */
/* rev. 0 - initial release                                                   */

globals=_setglobals()
call _timeout 120
call zocsynctime 500
call on halt name _halt

if _synchronize()\="command" then call _error "please start at the command prompt."

maxsdt=2000 /* holds */

/* load ini variables */
   load="sf"
   sl=_ini_load_settings()
   do i=1 to _dwords(sl,";")
    s=_dword(sl,i,";")
    globals=globals||" !"||s
    interpret '!'||s||'="!"||s'
   end;
   f=0; l=""
   do i=1 to words(load)
    s=word(load,i)
    x="!"||s
    interpret s||"=_ini.!settings.x"
    interpret 'if '||s||'="##UNDEF##" then do; l=l s; f=1; end'
   end; if f then call _error "missing config variable(s):"||l; drop load s sl x f l

parse value _getinfo("hlds;ore;org;equ;col;exp;ship") with holds ";" ore ";" org ";" equ ";" colos ";" exp ";" ship1
if zocwait("Command [")=640 then call _error "timeout"

if trunc(exp/((sf/100)*30))<30 then call zocmsgbox "warning:  stealing less than 30 holds"

/* get ships */
ship.=0
ship.1=_stripint(ship1)
planet.=0
negship.=0
negotiate.=0
i=1
ship.i=_asknum("ship #"||i||"?", ship.i, "c")
if ship.i=0 then call _quit "script canceled by user."
do while ship.i>0
 planet.i=_asknum("planet #"||i||"? (0 to SST this ship)", planet.i, "c")
 if planet.i>0 then do
  negship.i=_asknum("negotiate ship #"||i||"? (0 to use same ship)", negship.i, "c")
 end /*if*/
 i=i+1
 ship.i=_asknum("ship #"||i||"? (0 to end list)", ship.i, "c")
end /*do*/
if i<=2 then call _error "you need at least 2 ships."
maxship=i-1

/* ask about planet negotiation */
pf=0
do i=1 to maxship
 if planet.i>0 then pf=1
end /*do*/
if pf then do
 neg=_yesno("start with planetary negotiation?")
 if neg then do
  do i=1 to maxship
   if planet.i>0 then negotiate.i=1
  end /*do*/
 end /*if*/
end /*if*/

watch=_yesno("would you like to watch who is online?")
hagg=_yesno("would you like to haggle at the SST ports?")

if watch then do
 call _onlineinit
 if zocwait("Command [")=640 then call _error "timeout"
end /*if*/

turncost.=3
turnsleft.=0
turnsleft2.=0
bustlist="none"
busted.=0
bsum=0
i=1
done=0
do while \done

 if planet.i=0 then do
  call zocrespond "Organics do you want to sell [", "0^M"
  call zocrespond "Fuel Ore do you want to sell [", "0^M"
  call zocrespond "Organics do you want to buy [", "0^M"
  call zocrespond "Fuel Ore do you want to buy [", "0^M"
  tdone=0
  do while \tdone
   call zocsend "pt"
   ans=zocwaitmux("Equipment do you want to sell [", "You don't have anything they want")
   select
    when ans=0 then do
     if zocwait("]?")=640 then call _error "timeout"
     quantity=_stripint(_lastline())
    end /*when*/
    when ans=1 then call _quit "you need some equipment"
    when ans=640 then call _error "timeout"
   end /*select*/
   call zocsend quantity||"^M"
   if zocwait("Your offer [")=640 then call _error "timeout"
   if zocwait("]")=640 then call _error "timeout"
   offer=_stripint(_lastline())
   if watch then if \_watchcontinue("Your offer [") then call _quit "script cancelled by user."
   if hagg then tdone=_sellhaggle2(offer)
   else tdone=_sellnohaggle(offer)
   if zocwait("Command [")=640 then call _error "timeout"
  end /*do*/
  call zocrespond "Organics do you want to sell ["
  call zocrespond "Fuel Ore do you want to sell ["
  call zocrespond "Organics do you want to buy ["
  call zocrespond "Fuel Ore do you want to buy ["
 end /*if*/

 /* planet negotiate */
 if negotiate.i then do
  if negship.i>0 then do
   if \_transport(negship.i) then call _error "transport unsuccessful."
  end /*if*/
  call zocrespond "Organics do you want to sell [", "0^M"
  call zocrespond "Fuel Ore do you want to sell [", "0^M"
  ndone=0
  do while \ndone
   call zocsend "pn"||planet.i||"^M"
   if zocwait("Equipment do you want to sell [")=640 then call _error "timeout"
   if zocwait("]?")=640 then call _error "timeout"
   quantity=_stripint(_lastline())
   quantity=min(quantity, maxsdt)
   call zocsend quantity||"^M"
   if zocwait("Your offer [")=640 then call _error "timeout"
   if zocwait("]")=640 then call _error "timeout"
   offer=_stripint(_lastline())
   if watch then if \_watchcontinue("Your offer [") then call _quit "script cancelled by user."
   ndone=_sellhaggle2(offer)
   if zocwait("Command [")=640 then call _error "timeout"
  end /*do*/
  call zocrespond "Organics do you want to sell ["
  call zocrespond "Fuel Ore do you want to sell ["
  negotiate.i=0
  if negship.i>0 then do
   if \_transport(ship.i, "quiet") then call _error "transport unsuccessful."
  end /*if*/
 end /*if*/

 /* port steal */
 ps=_portsteal(3,trunc(exp/((sf/100)*30)))
 parse var ps pm ";" pexp ";" pam ";" pav ";" ph ";" turnsleft.i
 select
  when pm="##OK##" then do
   if planet.i>0 & pav<=min(ph,trunc(exp/((sf/100)*30)))*2 then negotiate.i=1
   exp=exp+pexp
  end /*when*/
  when pm="##FAKE##" then do
   exp=exp-pexp
   busted.i=1
   bsum=bsum+1
   if bsum=1 then bustlist="F"||ship.i
   else bustlist=bustlist||",F"||ship.i
  end /*when*/
  when pm="##BUST##" then do
   exp=exp-pexp
   busted.i=1
   bsum=bsum+1
   if bsum=1 then bustlist=ship.i
   else bustlist=bustlist||","||ship.i
  end /*when*/
  when pm="##HOLDS##" then call _error "DEBUG _portsteal holds problem"
 end /*select*/
 call zocwrite _ansi("bt;fcy")||"<<ships busted: "||bustlist||">> "||_ansi("fmg")
 if bsum=maxship-1 then call _quit "busted "||bsum||" times."
 if watch then if \_watchcontinue("Command [") then call _quit "script cancelled by user."

 /* planet dump */
 if planet.i>0 then call _planet planet.i, "tnl3^M"

 /* check turns */
 if turncost.i=0 then turncost.i=turnsleft2.i-turnsleft.i
 turnsleft2.i=turnsleft.i
 if turnsleft.i<61 & turnsleft.i//10<turncost.i then do
  call _beep "alert.wav"
  cont=_yesno("you have "||turnsleft.i||" turns remaining.  Continue?")
  if \cont then call _quit "script cancelled by user."
 end /*if*/
 turncost.i=0

 /* xport to next ship */
 xdone=0
 do while \xdone
  if i=maxship then i=1
  else i=i+1
  if \busted.i then xdone=1
 end /*do*/
 if \_transport(ship.i) then call _error "transport unsuccessful."

end /*do*/

exit

/***                 THE REVEREND'S TW LIBRARY FOR ZOC/REXX                 ***/

/** _setglobals v.4 **/
    _setglobals: procedure expose _verbose _monthdays _monthnames _baseday. _g. _msg. (globals)

     _verbose=0
     _msg.=""; _msg.0=0
     _monthdays="31;28;31;30;31;30;31;31;30;31;30;31"
     _monthnames="jan;feb;mar;apr;may;jun;jul;aug;sep;oct;nov;dec"
     _baseday.2000=730118
     _baseday.2001=_baseday.2000+365+1
     _baseday.2002=_baseday.2001+365
     _baseday.2003=_baseday.2002+365
     _baseday.2004=_baseday.2003+365
     _baseday.2005=_baseday.2004+365+1
     _baseday.2006=_baseday.2005+365
     _baseday.2007=_baseday.2006+365
     _baseday.2008=_baseday.2007+365

     i=lastpos(".",_g.!sname)
     if i=0 then _g.!sname1=_g.!sname
            else _g.!sname1=left(_g.!sname,i-1)

     rslt="_g. _ini. _s. _p. _d. _v. _f. _m. _l. _q. _sl. _ex. _qs. "
     rslt=rslt||"_ef. _es. _et. _ep. "
     rslt=rslt||"_path. _dist. _dtomsl. _dfrmsl. "
     rslt=rslt||"_bg. _nwt. _nwi. _nwo. _nw. _nwt. _od. _sv. _pv. _vs. _vn. _vi. _mcic. "
     rslt=rslt||"_olist1. _olist2. _clvlist1. _clvlist2. _msg _msg. "
     rslt=rslt||"_verbose _monthdays _monthnames _baseday. "
     rslt=rslt||"globals "
     if arg(1,"E") then rslt=rslt||arg(1)

     rslt=_space(rslt)
    return rslt

/** _timeout v.1 **/
    _timeout: procedure expose (globals)
     if _g.!timeout="_G.!TIMEOUT" then _g.!timeout=60
     rslt=_g.!timeout
     nt=_stripint(arg(1))
     if arg(1,"E") & nt>0 then do
      call zoctimeout nt
      _g.!timeout=nt
     end /*if*/
    return rslt

/** _halt v.3 **/
    _halt: procedure expose (globals)
     call off halt
     call zocwriteln "^[[1;33m< user abort >^[[0m "
     exit
    return

/** _synchronize v.5 **/
    _synchronize: procedure expose (globals)

     synchw=_synchronize_vars("w")
     synchr=_synchronize_vars("r")

     call zocsend "&&"
     ans=_waitmux("&&|Pausing is")
     select
      when ans=0 then return "unknown_text_entry"
      when ans=1 then nop
      when ans=640 then return "timeout"
      otherwise nop
     end /*select*/

     ans=_waitmux(synchw)
     select
      when ans=640 then rslt="timeout"
      when ans>0 then do
       if _wait("Pausing is")=640 then call _error "timeout"
      end /*when*/
      otherwise nop
     end /*select*/
     rslt=_dword(synchr,ans+1,";")

     select
      when rslt="computer" then do
       call zocsend "q"
       ans=_waitmux("Command [","Citadel command")
       select
        when ans=0 then nop
        when ans=1 then rslt="computer_cit"
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
       call zocsend "c"
      end /*when*/
      when rslt="corporate" then do
       call zocsend "q"
       ans=_waitmux("Command [","Citadel command")
       select
        when ans=0 then call zocsend "t"
        when ans=1 then do
         rslt="corporate_cit"
         call zocsend "x"
        end /*when*/
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*when*/
      otherwise nop
     end /*select*/

    return rslt

/** _error v.7 **/
    _error: procedure expose (globals)
     call off halt
     if zocgetinfo("CURSOR-X")>0 then call zocwriteln
     call zocwrite _ansi("bt;frd")||"< script error ("||_g.!sname||" b."||_g.!sbuild||")"
     if arg(1,"E") then call zocwrite " : "||arg(1)
     call zocwriteln " >"
     call zocwriteln _ansi("bt;fye")||"< if this is a serious problem, email me at: the.reverend@coastgames.com > "
     call zocwriteln "< SCRIPT "||_g.!sname||", BUILD "||_g.!sbuild||", DATE "||_g.!sdate||" > "
     call zocwriteln "< ZOC VERSION '"||zocgetinfo("VERSION")||"', OS '"||zocgetinfo("OSYS")||"', LOCATION '"||zocgetinfo("CONNECTEDTO")||"' >"
     if arg(2,"E") then call zocwriteln _ansi("bt;fgr")||"< "||arg(2)||" >"
     call zocwrite _ansi()
     call _beep "error.wav"
    exit

/** _ini_load_settings v.1 **/
    _ini_load_settings: procedure expose (globals)

     parse value zocgetoption("CaptDefaultName") with . '="' ldefault '"'
     parse value zocgetglobaloption("WindowTitle") with . '="' gname '"'

     lpath=_get_log_path()
     spath=_get_script_path()
     dpath=_get_download_path()

     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then gname=_setgame()
     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then exit
     dname=dosfname(lpath||gname||"_data.ini")

     _ini.="##UNDEF##"

     sectionlist=""
     if _fileopenr(dname) then do
      insection=0
      do while \_fileeof(dname)
       line=strip(linein(dname))
       if _ini_is_section(line) then do
        insection=1
        parse var line "[" section "]"
        section=strip(section)
        if sectionlist="" then sectionlist=section; else sectionlist=sectionlist||";"||section
       end /*if*/
       else do
        if insection then do
         parse var line k "=" v
         v=_ini_format_value(v)
         k="!"||section||".!"||strip(k)
         if k\="!"||section||".!" then _ini.k=strip(v)
        end /*if*/
       end /*else*/
      end /*while*/
      call _fileclose dname
     end /*if*/

     call _iniv "!settings", "!ldefault", ldefault
     call _iniv "!settings", "!lpath",  lpath
     call _iniv "!settings", "!spath",  spath
     call _iniv "!settings", "!dpath",  dpath
     call _iniv "!settings", "!dname",  dname
     call _iniv "!settings", "!gname",  gname
     call _iniv "!settings", "!lname",  lpath||gname||"_log.txt"
     call _iniv "!settings", "!fname",  lpath||gname||"_figs.txt"
     call _iniv "!settings", "!vname",  lpath||gname||"_voids.txt"
     call _iniv "!settings", "!vwname", lpath||gname||"_view.txt"
     call _iniv "!settings", "!pname",  lpath||gname||".prt"
     call _iniv "!settings", "!sname",  lpath||gname||".sct"
     call _iniv "!settings", "!rpname", lpath||gname||"_ref.prt"
     call _iniv "!settings", "!rsname", lpath||gname||"_ref.sct"
     call _iniv "!settings", "!mname",  lpath||gname||".map"
     call _iniv "!settings", "!zname",  lpath||gname||".ztm"
     call _iniv "!settings", "!nfname", lpath||gname||"_nearfig.txt"

    return sectionlist

/** _dwords v.2 **/
    _dwords: procedure expose (globals)
     rslt=words(translate(arg(1),arg(2)||" "," "||arg(2)))
    return rslt

/** _dword v.2 **/
    _dword: procedure expose (globals)
     rslt=translate(word(translate(arg(1),arg(3)||" "," "||arg(3)),arg(2))," "||arg(3),arg(3)||" ")
    return rslt

/** _getinfo v.5 **/
    _getinfo: procedure expose (globals)
     args=lower(arg(1))
     bufflen=32*1024
     call zocreceivebuf bufflen
     call zocsend "/"
     if _wait("Sect ")=640 then call _error "timeout"
     if _wait("Ship ")=640 then call _error "timeout"
     if _wait("^M")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)>=bufflen then call zocwrite "<buffer overflow>"
     i=pos("Sect ",buff)
     j=pos("Ship",buff,i)
     j=pos(d2c(13),buff,j)
     buff=substr(buff,i,j-i)
     buff=_space(translate(buff, "  ~;", d2c(0)||d2c(10)||d2c(13)||d2c(179)),1)
     buff=translate(_space(translate(buff,", "," ,"),0),", "," ,")

     buff2=strip(_dword(buff,1,"~"))
     do i=2 to _dwords(buff,"~")
      buff2=buff2||";"||strip(_dword(buff,i,"~"))
     end
     buff=buff2
     drop buff2

     /* analyze buffer */
     vr.=""
     vl.=""
     c=0
     do j=1 to _dwords(buff,";")
      c=c+1
      vr.c=strip(_dword(buff,j,";"))
      vl.c=word(vr.c,2)
      vr.c=lower(word(vr.c,1))
      if vr.c="ship" then do
       c=c+1
       vr.c=strip(_dword(buff,j,";"))
       vl.c=word(vr.c,3)
       vr.c="shiptype"
      end /*if*/
     end /*do*/
     c=c+1
     vr.c="all"
     vl.c=buff

     /* set gobal vars */
     _qs.!corp=0
     do i=1 to c
      tag="!"||upper(vr.i)
      _qs.tag=vl.i
     end /*do*/

     /* pass our requested stats */
     rslt=""
     do i=1 to _dwords(args,";")
      found=0
      do j=1 to c
       if vr.j=_dword(args,i,";") then do
        rslt=rslt||";"||vl.j
        found=1
       end /*if*/
      end /*do*/
      if \found then rslt=rslt||";"||"##NA##"
     end /*do*/
     if rslt\="" then rslt=substr(rslt,2)

    return rslt

/** _stripint v.4 **/
    _stripint: procedure expose (globals)
     mask=_space(translate(arg(1)," ","-0123456789,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripint"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if length(rslt)>9 then rslt=left(rslt,9)
      rslt=neg||rslt
     end /*else*/
    return rslt

/** _asknum v.4 **/
    _asknum: procedure expose (globals)
     do i=1 to 3
      select
       when i=1 & arg(i,"E") then msg=arg(i)
       when i=1              then msg="enter an number:"
       when i=2 & arg(i,"E") then default=arg(i)
       when i=2              then default=""
       when i=3 & arg(i,"E") then cflag=min(verify(lower(arg(i)),"c","M"),1)
       when i=3              then cflag=0
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=strip(zocask(msg, default))
     do while _stripnum(rslt)\=rslt | rslt=""
      default=rslt||" [please enter a number or ESC to cancel.]"
      if rslt="##CANCEL##" then leave
      else rslt=strip(zocask(msg, default))
     end /*do*/
     if cflag & rslt="##CANCEL##" then call _quit "script cancelled by user.", "nocopy"
    return rslt

/** _quit v.7 **/
    _quit: procedure expose (globals)
     lcpy=1
     arg1=""
     do i=1 to 2 /* manage arguments */
      select
       when arg(i,"E") & lower(arg(i))="nocopy" then lcpy=0
       when arg(i,"E") & arg1="" then arg1=arg(i)
       otherwise nop
      end /*select*/
     end /*do*/
     line=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
     select /* define message */
      when  lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m^M^J"||line
      when \lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m "
      when  lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m^M^J"||line
      when \lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m "
      otherwise nop
     end /*select*/
     call zocwrite msg
     select /* choose a beep */
      when lower(arg1)="script cancelled by user." then call _beep "cancel.wav"
      otherwise call _beep "quit.wav"
     end /*select*/
     exit
    return 1

/** _yesno v.3 **/
    _yesno: procedure expose (globals)
     if arg(1,"E") then msg=arg(1)
     else msg="yes or no"
     if arg(2)="yn" then rslt=zocrequest(msg||" (ESC=no)", "yes", "no")
                    else rslt=zocrequest(msg, "yes", "no", "cancel")
     select
      when rslt="cancel" then call _quit "script cancelled by user.", "nocopy"
      when rslt="##CANCEL##" & arg(2)\="yn" then call _quit "script cancelled by user.", "nocopy"
      when rslt="yes" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt

/** _onlineinit v.2 **/
    _onlineinit: procedure expose (globals)
     _olist1.=""
     _olist1.0=0
     call _onlineget
    return

/** _lastline v.3 **/
    _lastline: procedure expose (globals)
     rslt=zoclastline()
     select
      when lower(arg(1))="raw" then nop
      when pos(d2c(7),rslt)>0  then rslt=translate(zocstring("REMOVE", rslt, d2c(7)),"  ",d2c(0)||d2c(10))
      otherwise                     rslt=translate(rslt,"  ",d2c(0)||d2c(10))
     end /*select*/
    return rslt

/** _watchcontinue v.2 **/
    _watchcontinue: procedure expose (globals)
     pmpt=arg(1)
     if pmpt="" then pmpt="Command ["
     cont=1
     call _onlineget
     if zocwait(pmpt)=640 then call _error "timeout"
     if _onlinereport() then do
      call _beep "alert.wav"
      cont=_yesno("online status changed - continue?")
     end /*if*/
    return cont

/** _sellhaggle2 v.2 **/
    _sellhaggle2: procedure expose (globals)
     portoffer=arg(1)
     offer=trunc(portoffer*1.06)

     success=1
     iter=1

     call zocsend offer||"^M"

     done=0
     do while \done

      ans=zocwaitmux("We'll buy them for", ,
                       "Our final offer", ,
                       "We're not interested.", ,
                       "You have")
      select

       when ans=0 then do
        if zocwait("Your offer [")=640 then call _error "timeout"
        if zocwait("]")=640 then call _error "timeout"
        newportoffer=_stripint(_lastline())
        iter=iter+1
        newoffer=trunc(offer/max(1.003,(newportoffer/portoffer)))
        if newoffer>=offer then newoffer=offer-1
        offer=newoffer
        portoffer=newportoffer
        call zocsend offer||"^M"
       end /*when*/

       when ans=1 then do
        if zocwait("Your offer [")=640 then call _error "timeout"
        if zocwait("]")=640 then call _error "timeout"
        finalportoffer=_stripint(_lastline())
        iter=iter+1
        factor=0.5
        if iter<3 then factor=0.6
        offer=trunc(offer*(1-factor) + finalportoffer*factor)
        call zocsend offer||"^M"
       end /*when*/

       when ans=2 then do
        done=1
        success=0
       end /*when*/

       when ans=3 then do
        done=1
       end /*when*/

       when ans=640 then call _error "timeout"

       otherwise nop

      end /*select*/

     end /*while*/

    return success

/** _sellnohaggle v.2 **/
    _sellnohaggle: procedure expose (globals)
     offer=arg(1)
     call zocsend "^M"
     if zocwait("You have")=640 then call _error "timeout"
    return 1

/** _transport v.4 **/
    _transport: procedure expose (globals)
     ship=arg(1)
     if arg(2)="quiet" then quiet=1
     else quiet=0
     success=1

     if quiet then call zocsend "x "
     else call zocsend "x"

     if zocwait("<Transport to Ship>")=640 then call _error "timeout"

     done=0
     do while \done
      ans=zocwaitmux("[Pause]", "ship to beam to (Q=Quit)", "WARNING!")
      select
       when ans=0 then do
        if quiet then call zocsend "  "
        else call zocsend "^M"
       end /*when*/
       when ans=1 then done=1
       when ans=2 then nop
       when ans=640 then call _error "timeout"
       otherwise nop
      end /*select*/
     end /*do*/

     if quiet then call zocsend ship||"^M "
     else call zocsend ship||"^M"

     ans=zocwaitmux("Security code accepted", "not an available ship")
     select
      when ans=0 then success=1
      when ans=1 then success=0
      when ans=640 then call _error "timeout"
      otherwise nop
     end /*select*/

     done=0
     do while \done
      ans=zocwaitmux("[Pause]", "ship to beam to (Q=Quit)")
      select
       when ans=0 then do
        if quiet then call zocsend "  "
        else call zocsend "^M"
       end /*when*/
       when ans=1 then done=1
       when ans=640 then call _error "timeout"
       otherwise nop
      end /*select*/
     end /*do*/
     call zocsend "q"
     if zocwait("Command [")=640 then call _error "timeout"

    return success

/** _portsteal v.3 **/
    _portsteal: procedure expose (globals)
     prod=arg(1)
     max=arg(2)

     msg="##OK##"
     exp=0
     amount=0
     avail=0
     holds=0
     turns=0

     if prod="" then call _error "specify product to steal [1,2,3]"
     if \_in("123",prod) then call _error "specify product to steal [1,2,3]"
     if max="" then call _error "specify # holds to steal"
     if max<=0 then call _error "specify # holds to steal"

     select
      when prod=1 then prodn="Fuel Ore "
      when prod=2 then prodn="Organics "
      when prod=3 then prodn="Equipment"
     end /*select*/

     call zocsend "pr"

     prans=zocwaitmux("One turn deducted, ", "[Pause]")
     select
      when prans=0 then do
       if zocwait(" turns left.")=640 then call _error "timeout"
       turns=_stripint(_lastline())
      end /*when*/
      when prans=1 then turns=10000
      when prans=640 then call _error "timeout"
      otherwise nop
     end /*select*/

     call zocsend "^Ms"
     fake=zocwaitmux(prodn, "Suddenly you're Busted!")
     if prod=3 then prodn="Equipment "
     select
      when fake=0 then do

       if zocwait("^M")=640 then call _error "timeout"
       avail=_stripint(substr(_lastline(),17,8))

       call zocsend prod
       if zocwait(prodn||"to swipe? [")=640 then call _error "timeout"
       if zocwait("]")=640 then call _error "timeout"
       holds=_stripint(_lastline())

       amount=min(holds, max, avail)
       call zocsend amount||"^M"

       ans=zocwaitmux("Success!", "Busted!", "There aren't that many holds")
       select
        when ans=0 then do
         if zocwait("and you receive ")=640 then call _error "timeout"
         if zocwait("experience point(s).")=640 then call _error "timeout"
         exp=_stripint(_lastline())
        end /*when*/
        when ans=1 then do
         if zocwait("and you LOSE ")=640 then call _error "timeout"
         if zocwait("experience point(s).")=640 then call _error "timeout"
         exp=_stripint(_lastline())
         amount=0
         msg="##BUSTED##"
        end /*when*/
        when ans=2 then msg="##HOLDS##"
        when ans=640 then call _error "timeout"
       end /*select*/

      end /*when*/

      when fake=1 then do
       if zocwait("and you LOSE ")=640 then call _error "timeout"
       if zocwait("experience point(s).")=640 then call _error "timeout"
       exp=_stripint(_lastline())
       msg="##FAKE##"
      end /*when*/

      when fake=640 then call _error "timeout"

      otherwise nop

     end /*select*/

     if zocwait("Command [")=640 then call _error "timeout"
     rslt=msg||";"||exp||";"||amount||";"||avail||";"||holds||";"||turns

    return rslt

/** _ansi v.3 **/
    _ansi: procedure expose (globals)
     rslt="0"
     pre=""
     do i=1 to _dwords(arg(1),";")
      w=_dword(arg(1),i,";")
      select
       when w="clearline" then pre=pre||"^[[100D^[[K"
       when w="dl"  then rslt=rslt||";"||0  /* dull               */
       when w="bt"  then rslt=rslt||";"||1  /* bright             */
       when w="ul"  then rslt=rslt||";"||4  /* underlined         */
       when w="blk" then rslt=rslt||";"||5  /* blinking           */
       when w="fbk" then rslt=rslt||";"||30 /* black foreground   */
       when w="frd" then rslt=rslt||";"||31 /* red foreground     */
       when w="fgr" then rslt=rslt||";"||32 /* green foreground   */
       when w="fye" then rslt=rslt||";"||33 /* yellow foreground  */
       when w="fbl" then rslt=rslt||";"||34 /* blue foreground    */
       when w="fmg" then rslt=rslt||";"||35 /* magenta foreground */
       when w="fcy" then rslt=rslt||";"||36 /* cyan foreground    */
       when w="fwh" then rslt=rslt||";"||37 /* white foreground   */
       when w="bbk" then rslt=rslt||";"||40 /* black background   */
       when w="brd" then rslt=rslt||";"||41 /* red background     */
       when w="bgr" then rslt=rslt||";"||42 /* green background   */
       when w="bye" then rslt=rslt||";"||43 /* yellow background  */
       when w="bbl" then rslt=rslt||";"||44 /* blue background    */
       when w="bmg" then rslt=rslt||";"||45 /* magenta background */
       when w="bcy" then rslt=rslt||";"||46 /* cyan background    */
       when w="bwh" then rslt=rslt||";"||47 /* white background   */
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=pre||"^[["||rslt||"m"
    return rslt

/** _planet v.11 **/
    _planet: procedure expose (globals)
     planet=arg(1)
     if planet="" then planet=0
     comm=arg(2)
     msg=arg(3)
     if msg="" then msg="which planet?"
     mode=arg(4)

    /* MESSAGES TO ACCOUNT FOR:                          */
    /* They don't have room for that many on the planet! */
    /* Planetary Attack Command [Q] */

     list=""
     scanner=0

     call zocsend "l"
     rslt="l"

     done=0
     prompt=0
     do while \done
      ans=zocwaitmux("Planet command", ,
                     "Land on which planet", ,
                     "   <", ,
                     "There isn't a planet in this sector.", ,
                     "Citadel RLvl Fighters", ,
                     "couldn't possibly stand the stress", ,
                     " in sector ")
      select
       when ans=0 then done=1
       when ans=1 & prompt then nop
       when ans=1 then do
        prompt=1
        if planet=0 then do
         if pos(";",list)>0 then planet=_drequestlist(msg, list, ";", "c")
         else planet=list
         parse var planet planet "-" .
         planet=strip(planet)
        end /*if*/
        if comm="" then do
         call zocsend "q^M"
         rslt=rslt||"q^M"
         done=1
        end /*if*/
        else do
         call zocsend planet||"^M"
         rslt=rslt||planet||"^M"
        end /*else*/
       end /*when*/
       when ans=2 then do
        if planet=0 then do
         if scanner then do
          if zocwait("%")=640 then call _error "timeout"
         end /*if*/
         else if zocwait("^M")=640 then call _error "timeout"
         line=strip(_lastline())
         parse var line num "> " name
         name=strip(left(name,36))
         if list="" then list=num||copies(" ",2*(4-length(num)))||" - "||name
         else list=list||";"||num||copies(" ",2*(4-length(num)))||" - "||name
        end /*if*/
       end /*when*/
       when ans=3 then do
        planet=0
        done=1
       end /*when*/
       when ans=4 then scanner=1
       when ans=5 then do
        planet=0
        done=1
       end /*when*/
       when ans=6 then do
        if planet=0 then do
         parse value _lastline() with . "#" planet " in sector" .
        end /*if*/
       end /*when*/
       when ans=640 then call _error "timeout"
       otherwise nop
      end /*select*/
     end /*do*/

     if ans=0 then do
      if mode="quant" then do
       buflen=3*1024
       call zocreceivebuf buflen
       call zocsend "d"
       if zocwait("Planet #")=640 then call _error "timeout"
       if zocwait("Fighters")=640 then call _error "timeout"
       buff=translate(zocreceivebuf(0),"  ",d2c(0)||d2c(10))
       if length(buff)=buflen then call _error "buffer overflow"
       i=pos("Fuel Ore",buff)
       if i>0 then j=pos(d2c(13),buff,i)
       else j=0
       if i>0 & j>0 then parse value substr(buff,i,j-i) with "Fuel Ore" . . . ore .
       else ore=0
       ore=_space(translate(ore," ",","),0)

       i=pos("Organics",buff)
       if i>0 then j=pos(d2c(13),buff,i)
       else j=0
       if i>0 & j>0 then parse value substr(buff,i,j-i) with "Organics" . . . org .
       else org=0
       org=_space(translate(org," ",","),0)

       i=pos("Equipment",buff)
       if i>0 then j=pos(d2c(13),buff,i)
       else j=0
       if i>0 & j>0 then parse value substr(buff,i,j-i) with "Equipment" . . . equ .
       else equ=0
       equ=_space(translate(equ," ",","),0)
      end /*if*/

      if comm="" then do
       call zocsend "q"
       rslt=rslt||"q"
       if zocwait("Command [")=640 then call _error "timeout"
      end /*if*/
      else do
       do while comm\=""
        parse var comm c1 ";" comm
        call zocsend c1||"@"
        rslt=rslt||c1
        if zocwait("Average Interval Lag:")=640 then call _error "timeout"
       end /*do*/
       ans2=zocwaitmux("Planet command", "Command [")
       select
        when ans2=0 then do
         call zocsend "q"
         rslt=rslt||"q"
         if zocwait("Command [")=640 then call _error "timeout"
        end /*when*/
        when ans2=1 then nop
        when ans2=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*else*/

     end /*if*/

     /* if not learn mode then return planet number */
     select
      when lower(mode)="learn" then rslt=planet||";"||rslt
      when lower(mode)="quant" then rslt=planet||";"||ore||";"||org||";"||equ
      otherwise rslt=planet
     end /*select*/

    return rslt

/** _beep v.2 **/
    _beep: procedure expose (globals)
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then d=arg(3); else d=0
     select
      when arg(1,"O") then call zocwrite copies(d2c(7),n)
      when _fileexists(arg(1)) then do
       do i=1 to n
        call zocplaysound arg(1)
        if i\=n & d>0 then call zocdelay d
       end /*do*/
      end /*when*/
      otherwise call zocwrite copies(d2c(7),n)
     end /*select*/
    return

/** _space v.1 **/
    _space: procedure expose (globals)
     str=strip(arg(1))
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then pad=arg(3); else pad=" "
     rslt=word(str,1)
     do i=2 to words(str)
      rslt=rslt||copies(pad,n)||word(str,i)
     end /*do*/
    return rslt

/** _synchronize_vars v.1 **/
    _synchronize_vars: procedure expose (globals)
     select
      when arg(1)="w" then rslt="Pausing",
                              ||"|Command [",
                              ||"|Citadel command",
                              ||"|Planet command",
                              ||"|<StarDock>",
                              ||"|ship to sell",
                              ||"|Still interested ?",
                              ||"|wish to buy? (A,B,C,Q,?)",
                              ||"|<Galactic Bank>",
                              ||"|<Hardware Emporium>",
                              ||"|<Shipyards>",
                              ||"|<Tavern>",
                              ||"|Enter your choice [T] ?",
                              ||"|do you want to sell [",
                              ||"|do you want to buy [",
                              ||"|Computer command",
                              ||"|Corporate command",
                              ||"|Colonists? [T]",
                              ||"|Stop in this sector (Y,N,E,I,R,S,D,P,?) (?=Help) [N]",
                              ||"|`",
                              ||"|F: ",
                              ||"|'",
                              ||"|S: ",
                              ||"|M: ",
                              ||"|P: "
      when arg(1)="r" then rslt="unknown;command;citadel;planet;stardock;ship_sell;ship_sell_interested;class_0",
                             ||";bank;hardware;shipyards;tavern;port_menu;port_haggle;port_haggle;computer",
                             ||";corporate;terra;stop_in_this_sector?;fedcom_text_entry_1;fedcom_text_entry_2",
                             ||";subspace_text_entry_1;subspace_text_entry_2;mail_text_entry;private_text_entry",
                             ||";corporate_cit;computer_cit;unknown_text_entry" /* <-- these unmatched in the wait string above */
      when arg(1)="command" then rslt=" ; ;qq;q;q;qqq;nqq;q;qq;qq;qq;qq;q;0^Mz0^Mz0^M;0^Mz0^Mz0^M;q;q;q;y;^H;^M;^H;^M;^M;^M;qqq;qqq; "
      when arg(1)="computer" then rslt=" ;c;c;qc;qc;qqqc;nqqc;qc;qqc;qqc;qqc;qqc;qc;0^Mz0^Mz0^Mc;0^Mz0^Mz0^Mc; ;qc;qc;yc;^Hc;^Mc;^Hc;^Mc;^Mc;^Mc;qc;qc; "
      otherwise call _error "unknown argument in _synchronize_vars"
     end /*select*/
    return rslt

/** _waitmux v.1 **/
    _waitmux: procedure expose (globals)
     rslt=zocwaitmux(arg(1))
    return rslt

/** _wait v.1 **/
    _wait: procedure expose (globals)
     rslt=zocwait(arg(1))
    return rslt

/** _get_log_path v.2 **/
    _get_log_path: procedure expose (globals)
     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid path in _get_log_path"
    return lpath

/** _get_script_path v.1 **/
    _get_script_path: procedure expose (globals)
     parse value zocgetglobaloption("ScriptPath") with . '="' spath '"'
     spath=dosfname(spath)
     if right(spath,1)\="\" then spath=spath||"\"
     if \dosisdir(spath) then call _error "invalid path in _get_script_path"
    return spath

/** _get_download_path v.2 **/
    _get_download_path: procedure expose (globals)
     parse value zocgetglobaloption("DownloadAltPath") with . '="' dpath '"'
     dpath=dosfname(dpath)
     if right(dpath,1)\="\" then dpath=dpath||"\"
     if \dosisdir(dpath) then call _error "invalid path in _get_download_path"
    return dpath

/** _setgame v.6 **/
    _setgame: procedure expose (globals)

     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid log path in _setgame"

     if arg(1,"E") then gname=arg(1)
     else do
      list=_ini_list_games(lpath)
      if c=0 then gname="CLEAR"
      else gname=_drequestlist("select a game:", list||";CLEAR", ";", "c")
     end /*if*/
     if gname="CLEAR" | gname="" then gname="%ZOCORHOST% %OPTIONS%"
     call zocsetglobaloption 'WindowTitle="'||gname||'"'
    return gname

/** _fileopenr v.4 **/
    _fileopenr: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenr"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN READ"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

/** _fileeof v.4 **/
    _fileeof: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileeof"
      when arg(1)="" then rslt=0
      otherwise rslt=\lines(arg(1))
     end /*select*/
    return rslt

    _ini_is_section: procedure expose (globals)
     s=strip(arg(1))
     if left(s,1)="[" & left(reverse(s),1)="]" then return 1
    return 0

/** _ini_format_value **/
    _ini_format_value: procedure expose (globals)
     v=arg(1)
     if _dwords(v,"=")=2 then do
      t=lower(_dword(v,1,"="))
      v=_dword(v,2,"=")
      select
       when t="i" then v=_stripint(v)
       when t="f" then v=_stripnum(v)
       when t="b" then do; v=_stripint(v); if v>0 then v=1; else v=0; end
       when t="s" then nop
       otherwise nop
      end /*select*/
     end /*if*/
    return v

/** _fileclose v.3 **/
    _fileclose: procedure expose (globals)
     if \arg(1,"E") then call _error "missing argument in _fileclose"
     select
      when arg(1)="" then nop
      otherwise call stream arg(1), "C", "CLOSE"
     end /*select*/
    return

    _iniv: procedure expose (globals)
     s=arg(1); v=arg(2)
     if arg(3,"E") then _ini.s.v=arg(3)
    return _ini.s.v

/** _stripcomma v.1 **/
    _stripcomma: procedure expose (globals)
     rslt=translate(_space(translate(arg(1),", "," ,"),0)," ",",")
    return rslt

    _set_msg: procedure expose (globals)
     i=_msg.0
     if i="_MSG.0" then do; _msg.=""; _msg.0=0; i=0; end
     i=i+1; _msg.0=i; _msg=""
     if arg(1,"E") then do; _msg.i=arg(1); _msg=arg(1); end;
     if arg(2,"E") then _msg.i.!source=arg(2)
     if arg(3,"E") then _msg.i.!comment=arg(3)
    return i

/** _stripnum v.3 **/
    _stripnum: procedure expose (globals)
     w=9
     mask=_space(translate(arg(1)," ","-0123456789.,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripnum"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if left(rslt,1)="." then rslt="0"||rslt
      r=_dword(rslt,1,".")
      m=_dword(rslt,2,".")
      select
       when r=0 & length(m)>w then m=left(m,w)
       when length(r)>w then do; r=left(r,w); m=""; end
       when length(r)=w then m=""
       when length(m)>(w-length(r)) then m=left(m,w-length(r))
       otherwise nop
      end /*select*/
      if m="" then rslt=neg||r; else rstl=neg||r||"."||m
     end /*else*/
    return rslt

/** _onlineget v.7 **/
    _onlineget: procedure expose (globals)

     if _g.RED.0="_G.RED.0" then call _load_rank_names

     bufsize=5*1024
     call zocreceivebuf bufsize
     blanklines=0

     if _sendwait("#","  Who's Playin")=640 then call _error "timeout"
     do while blanklines<2
      if zocwaitmux("e","a","^M")=640 then call _error "timeout"
      line=strip(_lastline())
      if line="" then blanklines=blanklines+1
     end /*do*/
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)=bufsize then call _error "buffer overflow in _onlineget"

     _olist2.=""
     do i=1 to _olist1.0
      _olist2.i=_olist1.i
     end /*do*/
     _olist2.0=_olist1.0
     _olist1.=""
     _olist1.0=0

     i=max(pos("Who's Playing",buff),1)
     i=pos(d2c(13),buff,i)+1
     c=0
     do while i>1
      j=pos(d2c(13),buff,i)
      if j>0 then line=strip(substr(buff,i,j-i))
      i=j+1
      if line\="" then do
       c=c+1
       line.c=line
      end /*if*/
     end /*do*/

     do i=1 to c

      /* split rank and name */
      do j=1 to 23
       k=word(_g.BLUE.0,j)
       if left(line.i,length(_g.BLUE.k))=_g.BLUE.k then leave
      end /*do*/
      if j<24 then do
       rank.i=k-1
       name.i=substr(line.i,length(_g.BLUE.k)+2)
      end /*if*/
      else do
       do j=1 to 22
        k=word(_g.RED.0,j)
        if left(line.i,length(_g.RED.k))=_g.RED.k then leave
       end /*do*/
       if j<23 then do
        rank.i=-k
        name.i=substr(line.i,length(_g.RED.k)+2)
       end /*if*/
       else k=0
      end /*else*/

      /* split name and corp */
      parse value reverse(name.i) with temp1 "]" num "[" temp2
      corp.i=0
      if num="" then ,
       if _stripint(num)=num & temp1="" & strip(temp2)\="" then do
        corp.i=reverse(num)
        name.i=reverse(substr(reverse(name.i),4+length(num)))
       end /*if*/

      _olist1.i=name.i||";"||corp.i||";"||rank.i

     end /*do*/
     _olist1.0=c

    return

/** _onlinereport v.3 **/
    _onlinereport: procedure expose (globals)

     msg.=""
     if _verbose then msg.1="REV-SCRIPT:  online update^M"
                 else msg.1=""
     newtag="IN"
     gonetag="OUT"

     do i=1 to _olist1.0
      found=0
      do j=1 to _olist2.0
       if _dword(_olist1.i,1,";")=_dword(_olist2.j,1,";") then do
        found=1
        leave
       end /*if*/
      end /*do*/
      if \found then msg.2=msg.2||" "||newtag||": "||_dword(_olist1.i,1,";")||"^M"
     end /*do*/

     do i=1 to _olist2.0
      found=0
      do j=1 to _olist1.0
       if _dword(_olist2.i,1,";")=_dword(_olist1.j,1,";") then do
        found=1
        leave
       end /*if*/
      end /*do*/
      if \found then msg.3=msg.3||" "||gonetag||": "||_dword(_olist2.i,1,";")||"^M"
     end /*do*/

     rslt=1
     select
      when msg.2="" & msg.3="" then rslt=0
      when msg.2\="" & msg.3\="" then call zocsend "'^M"||msg.1||msg.2||msg.3||"^M"
      when msg.3="" then call zocsend "'^M"||msg.1||msg.2||"^M"
      when msg.2="" then call zocsend "'^M"||msg.1||msg.3||"^M"
      otherwise rslt=0
     end /*select*/

    return rslt

/** _in v.3 **/
    _in: procedure expose (globals)
     if arg(1,"E") & arg(2,"E") & length(arg(1))>0 & verify(arg(2),arg(1),"N")=0 then rslt=1
     else rslt=0
    return rslt

/** _drequestlist v.3 **/
    _drequestlist: procedure expose (globals)
     i=zocrequestlist(arg(1),translate(arg(2),"|"||arg(3),arg(3)||"|"))
     select
      when i<0 & lower(arg(4))="c" then call _quit "script cancelled by user.", "nocopy"
      when i<0 then rslt="##CANCEL##"
      otherwise rslt=_dword(arg(2),i+1,arg(3))
     end /*select*/
    return rslt

/** _fileexists v.4 **/
    _fileexists: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileexists"
      when arg(1)="" then rslt=0
      when stream(arg(1), "C", "QUERY EXISTS")="" then rslt=0
      otherwise rslt=1
     end /*select*/
    return rslt

/** _ini_list_games v.1 **/
    _ini_list_games: procedure expose (globals)
     lpath=arg(1)
     parse value zoclistfiles(lpath||"*_data.ini", ";") with c list
     if c=0 then rslt=""
     else do
      n=_dword(list,1,";")
      rslt=left(n,lastpos("_data.ini",n)-1)
      do i=2 to c
       n=_dword(list,i,";")
       rslt=rslt||";"||left(n,lastpos("_data.ini",n)-1)
      end /*do*/
     end /*else*/
    return rslt

/** _fileready v.2 **/
    _fileready: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileready"
      when arg(1)="" then rslt=0
      when stream(arg(1), "S")\="NOTREADY" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt

/** _filenew v.4 **/
    _filenew: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _filenew"
      when arg(1)="" then rslt=0
      otherwise do
       if arg(2,"E") & lower(arg(2))="delete" then call dosdel arg(1)
       if _fileexists(arg(1)) then rslt=0
       else do
        call stream arg(1), "C", "OPEN WRITE"
        rslt=_fileready(arg(1))
        if \rslt then call _fileclose arg(1)
       end /*else*/
      end /*otherwise*/
     end /*select*/
    return rslt

/** _load_rank_names v.1 **/
    _load_rank_names: procedure expose (globals)
     _g.RED.0="12 10 7 8 9 11 22 13 1 2 3 15 4 5 6 14 21 17 18 19 20 16"
     _g.RED.1="Nuisance 3rd Class"
     _g.RED.2="Nuisance 2nd Class"
     _g.RED.3="Nuisance 1st Class"
     _g.RED.4="Menace 3rd Class"
     _g.RED.5="Menace 2nd Class"
     _g.RED.6="Menace 1st Class"
     _g.RED.7="Smuggler 3rd Class"
     _g.RED.8="Smuggler 2nd Class"
     _g.RED.9="Smuggler 1st Class"
     _g.RED.10="Smuggler Savant"
     _g.RED.11="Robber"
     _g.RED.12="Terrorist"
     _g.RED.13="Pirate"
     _g.RED.14="Infamous Pirate"
     _g.RED.15="Notorious Pirate"
     _g.RED.16="Dread Pirate"
     _g.RED.17="Galactic Scourge"
     _g.RED.18="Enemy of the State"
     _g.RED.19="Enemy of the People"
     _g.RED.20="Enemy of Humankind"
     _g.RED.21="Heinous Overlord"
     _g.RED.22="Prime Evil"

     _g.BLUE.0="11 21 7 10 6 20 3 2 14 16 15 4 8 23 13 5 19 17 1 12 18 22 9"
     _g.BLUE.1="Civilian"
     _g.BLUE.2="Private"            /* match 2 */
     _g.BLUE.3="Private 1st Class"  /* match 1 */
     _g.BLUE.4="Lance Corporal"
     _g.BLUE.5="Corporal"
     _g.BLUE.6="Sergeant"           /* match 9 */
     _g.BLUE.7="Staff Sergeant"
     _g.BLUE.8="Gunnery Sergeant"
     _g.BLUE.9="1st Sergeant"
     _g.BLUE.10="Sergeant Major"     /* match 5 */
     _g.BLUE.11="Warrant Officer"
     _g.BLUE.12="Chief Warrant Officer"
     _g.BLUE.13="Ensign"
     _g.BLUE.14="Lieutenant J.G."      /* match 14 */
     _g.BLUE.15="Lieutenant"           /* match 13,15 */
     _g.BLUE.16="Lieutenant Commander" /* match 14 */
     _g.BLUE.17="Commander"
     _g.BLUE.18="Captain"
     _g.BLUE.19="Commodore"
     _g.BLUE.20="Rear Admiral"
     _g.BLUE.21="Vice Admiral"
     _g.BLUE.22="Admiral"
     _g.BLUE.23="Fleet Admiral"
    return

    /*
    Nuisance 3rd Class
    Nuisance 2nd Class
    Nuisance 1st Class
    Menace 3rd Class
    Menace 2nd Class
    Menace 1st Class
    Smuggler 3rd Class
    Smuggler 2nd Class
    Smuggler 1st Class
    Smuggler Savant
    Robber
    Terrorist
    Pirate
    Infamous Pirate
    Notorious Pirate
    Dread Pirate
    Galactic Scourge
    Enemy of the State
    Enemy of the People
    Enemy of Humankind
    Heinous Overlord
    Prime Evil

    Private
    Private 1st Class
    Lance Corporal
    Corporal
    Sergeant
    Staff Sergeant
    Gunnery Sergeant
    1st Sergeant
    Sergeant Major
    Warrant Officer
    Chief Warrant Officer
    Ensign
    Lieutenant J.G.
    Lieutenant
    Lieutenant Commander
    Commander
    Captain
    Commodore
    Rear Admiral
    Vice Admiral
    Admiral
    Fleet Admiral
    */

/** _sendwait v.1 **/
    _sendwait: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _sendwait"
     call zocsend arg(1)
     rslt=_wait(arg(2))
     select
      when \arg(3,"E") | arg(3)=""             then nop
      when lower(arg(3))="timeout"  & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline" & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline"            then rslt=_lastline()
      otherwise nop
     end /*select*/
    return rslt
