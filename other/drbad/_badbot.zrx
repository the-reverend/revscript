/* Tiny Bot */

call on error name errTrap
call zoctimeout 60
call zocsend "'BadBot v1.0...^M "/*send commands with ![macro] ... e.g. ![cbn] makes badbot very afraid ;) use ^^M for enter.^M" */

Emergency1="Quasar Cannon on NOTHING"
Emergency2="Limpet mine in NOWHERE"
Refill="Shipboard Computers DIDNOTHING" /* Dr. Bad2 destroyed 48 fighters. */

SafeToReconnect=1

timeoutMins=0

do forever
	res=zocwaitmux("INACTIVITY","R Kemper ^G^G ![","R tweety ^G^G ![","R presto ^G^G ![", "R the re ^G^G ![", "R Hollyw ^G^G ![",Emergency1, Emergency2, Refill)
		
	if res == 640 then do	
	/* NOTHING */

/*		if (ZocGetInfo("ONLINE") == "##NO##") then do
			call zocbeep 10
			if SafeToReconnect then call "script\tw\twgsLogin.zrx"
		end
		timeoutMins=timeoutMins+1
		if timeoutMins > 20 then do
			res =0; /* Timeout */
			timeoutMins=0
		end
*/
	end

	if res==0 then do
		call zocsend "'BadBot v1.0...^M " /*send commands with ![macro] ... e.g. ![cbn] makes badbot very afraid ;) use ^^M for enter.^M"*/
	end

	if (res > 0) & (res <= 5) then do
		res2=zocwaitmux("^M","]")
		if res2==1 then do
			ln=zoclastline()
			ln=left(ln, length(ln)-1)
			
			if left(ln,1)="{" then do
				/* RUN a script */
				scrToRun=right(ln, length(ln)-1)
				
				call zocfiledelete "ScrToRun.zrx"
				CALL STREAM "ScrToRun.zrx", "C", "OPEN WRITE"
					CALL LINEOUT "ScrToRun.zrx","/* REXX */"
					CALL LINEOUT "ScrToRun.zrx", "signal on syntax name errTrap"
					CALL LINEOUT "ScrToRun.zrx", "CALL ""script\tw\"scrToRun""""
					CALL LINEOUT "ScrToRun.zrx", "exit"
					CALL LINEOUT "ScrToRun.zrx", "errTrap:"
					CALL LINEOUT "ScrToRun.zrx", "CALL zocsend ""'Error. Probably script doesn't exist^M"""
					CALL LINEOUT "ScrToRun.zrx", "exit"
					CALL LINEOUT "ScrToRun.zrx", "return(0)"
				CALL STREAM "ScrToRun.zrx", "C", "CLOSE"
				call "ScrToRun.zrx"
			end; else do
				call zocsend ln
				call zocsend "'done. Glad to be of service^M"
			end
		end; else call zocsend "'unmatched []. Try again dickhead.^M"			
	end
	
	if (res >= 6) & (res <= 7) then do
		call zocbeep 5
		call quickstats
		if stats.shiptype=="ThoSen" then call zocsend "QQQQ^M^M"
		if res==5 then SafeToReconnect=0
		call "script\tw\QuasarReset.zrx"
	end
	
	if res == 8 then do
		call quickstats
		if stats.figs < 20000 then call zocsend "L3^MMNT^MQ"
	end
end

exit


/* Dr. Bad's library v1.38*/

/* globals */

/* CurrPrompt - the current prompt- sector, planet, citadel, computer, corporate */

ErrTrap: procedure expose IsSubControlled
	if IsSubControlled then call zocsend "'An error occured, resuming^M"; else call zocmsgbox("An error occured, resuming")
return(0)

Askk: procedure expose IsSubControlled
Askk_here:
	if IsSubControlled then do
		call zocsend "'"arg(1)" (e.g. "arg(2)")^M"
		call zocwait "^G^G !{"
		res=zocwaitmux("^M","}")
		if res==640 then exit
		if res==1 then do
			res=zoclastline()
			res=left(res,length(res)-1)
			return(res)
		end; else do
			call zocsend "'Brackets Brackets Brackets... don't u get it???^M"
			signal Askk_here
		end
	end
return(ZocAsk(arg(1),arg(2)))

FirstOtherShipInSector: procedure expose stats. numships shipnum. shipsect. shiptype. /* only from sector or cit menus */
	call quickstats
	call shipscan
	do i = 1 to numships
		if (shipsect.i==stats.sect) & (shipnum.i \= stats.shipnum) then return shipnum.i
	end
return(-1) /* no ship found */


MoveToPrompt: procedure expose CurrPrompt
	DestPrompt=arg(1)	
	Select
		When DestPrompt="sector" then do
			select
				When CurrPrompt="planet" then do
					call zocsend "Q"
					CurrPrompt="sector"
					return(0)
				end
				When CurrPrompt="citadel" then do
					call zocsend "QQ"
					CurrPrompt="sector"
					return(0)
				end
				When CurrPrompt="sector" then return(0)
				When CurrPrompt="computer" then call errorr "MoveToPrompt: not implemented"
				When CurrPrompt="corporate" then call errorr "MoveToPrompt: not implemented"
				otherwise call errorr "How'd I get here?"
			end
		end
		When DestPrompt=="citadel" then do
			select
				when CurrPrompt="planet" then do
					call zocsend "C"
					CurrPrompt=DestPrompt
					return(0)
				end
				otherwise call errorr "How'd I get here?"
			end
		end
		otherwise call errorr "MoveToPrompt: not implemented"
	end			
return(0)

errorr: procedure expose IsSubControlled
	if IsSubControlled then call zocsend "'"arg(1)"^M"; else call zocmsgbox arg(1)
	exit
return(0)

Land: procedure expose plnts. plnts.str
	if arg(1)=0 then do 
		Call GetSectorPlanets "Q"
		selplanet=ZocRequestList("Pick A Planet", plnts.str)
		if selplanet=0 then exit
		planet= plnts.selplanet
	end; else planet=arg(1)
	
	call zocsend "L"planet"^M"
return(planet)


Steal: procedure expose stats. steal.status.notenough   /*usage Steal <holddiv> */
	steal.status.notenough=0
				  	
	holddiv=arg(1)

	holds = stats.holds
	if stats.exp / holddiv < holds then holds=trunc(stats.exp/holddiv)

	call zocsend "PR^MS3"holds"^M"
	success=zocwaitmux("and you LOSE ","and you receive ","that many holds")
	
	if success==2 then do
		steal.status.notenough=1
		return(0)
	end

	call zocwait(" experience point(s)")
	parse value zoclastline() with xtraXP" experience point(s)"
	
	if success then stats.exp=stats.exp+xtraXP; else stats.exp=stats.exp-xtraXP
return(success)



GetWarps: procedure
/*Sector 1234 has warps to sector(s) :  2271 - 2782 - 3140 - 4014*/
/*You have never visited sector 2563.*/

	call zocsend "CI"arg(1)"^MQ"
	
	res=zocwaitmux("never visited", "has warps to sector(s) : ")
	if res==0 then return("")
	
	call zocwait "^M"
	ln=zoclastline()
	
return(ln)

GetLimpets: procedure
	l.=0

	call zocsend "K2"
	call zocwait "Deployed  Limpet  Scan"
	call zocwait "="
	call zocgetline
	i=0
	
	do while i<2
		i=zocwaitmux("Corporate","Personal","Total")
		if i<2 then do
			ln=zoclastline()
			parse var ln with " "sector number ownership
			l.sector=number
		end
	end
	
	/* OutToFile */
	call dosdel "LIMPET.TXT"
	CALL STREAM "LIMPET.TXT", "C", "OPEN WRITE"
	
	do i = 1 to 5000
		if l.i > 0 then call lineout "LIMPET.TXT", i
	end
	CALL STREAM "LIMPET.TXT", "C", "CLOSE"

return(0)


ShipScan: procedure expose numships shipnum. shipsect. shiptype.
	call zocsend "CZ"
	Call zocwait "Ship  Sect"
	call zocwait "-"
	call ZocGetLine

	Call Zocwait "^M"
	line=zocLastLine()
	numships=0
	do while length(line)>4
		numships=numships+1
		shipnum.numships=strip(substr(line,1,4))
		shipsect.numships=strip(substr(line,5,6))
		shiptype.numships=strip(substr(line,56))
	
		Call Zocwait "^M"
		line=zocLastLine()
	end
	
	Call Zocsend "Q"
	/* For testing now display things */
	
return(0)	


Negotiate: procedure /* <planet> <product- {"fuel","org","eq"}> */
	call zocsend "PN"arg(1)"^M"
	
	if arg(2)=="fuel" then do 
		call zocsend "^M^M0^M0^M"
		return(0)
	end
	if arg(2)=="org" then do
		res = zocwaitmux("Fuel Ore do you want", "Organics do you want")
		if res = 0 then call zocsend "0^M"
		call zocsend "^M^M0^M"
		return(0)
	end
	res = zocwaitmux("Fuel Ore do you want", "Organics do you want","Equipment do you want")
	if res = 0 then do 
		call zocsend "0^M"
		res=zocwaitmux("asdfafdsasfg", "Organics do you want","Equipment do you want")
	end
	if res = 1 then call zocsend "0^M"
	call zocsend "^M^M"
return(0)

GetCurrPrompt: procedure expose CurrPrompt
	call StreamSync
	res=zocwaitmux("Command", "Planet command", "Citadel command", "Computer command", "Corporate command")
	
	Select;
		When res=0 then CurrPrompt="sector"
		When res=1 then CurrPrompt="planet"
		When res=2 then CurrPrompt="citadel"
		When res=3 then CurrPrompt="computer"
		When res=4 then CurrPrompt="corporate"
	end		
return(0)

StreamSync:
	call zocsend "@"
	call zocwait "Interval Lag"
return(0)

GetplanetInfo: procedure expose onhand.fuel onhand.orgs currplanet.class
	call zocsend "L"arg(1)"^MQ"
	res=zocwaitmux("Planet #","That planet is not in this sector.")
	if res=1 then return(0)
	
	call zocwait "Class "
	call zocwait ","
	currplanet.class = left(zoclastline(),1)

	call zocwait "Fuel Ore"
	Call zocwait "^M"
	ln=zoclastline()
	parse var ln with " "colos.fuel ignored prod.fuel onhand.fuel ignored2 ignored3
	onhand.fuel=badcommas(onhand.fuel)

	call zocwait "Organics"
	Call zocwait "^M"
	ln=zoclastline()
	parse var ln with " "colos.orgs ignored prod.orgs onhand.orgs ignored2 ignored3
	onhand.orgs=badcommas(onhand.orgs)
return(1)

GetSectorPlanets: procedure expose plnts. plnts.str plnts.count CurrPrompt
	/* If you've a scanner, also put planet types in */
/*

   <  10> .                                    None    0%       0    None    O
          Owned by: asdf [1]

*/

	pln=arg(1)
	i=0
	
	if CurrPrompt="citadel" then call zocsend "QQ"
	if CurrPrompt="planet" then call zocsend "Q"
	
	if pln\="Q" then call zocsend "L"pln"^MC^M"; else call zocsend "L"
	if pln\="Q" then CurrPrompt="citadel"; else CurrPrompt="sector"


	call zocwait "Registry#"

	plnts.str="cancel"
	do while 1
		call zocwait "<"
		call zocwait ">"
		i=i+1
		plnts.i=zoclastline()
		plnts.i = left(plnts.i, length(plnts.i)-1)
		if left(plnts.i,1)=="Q" then do
			plnts.count = i-1
			if pln=="Q" then call zocsend "Q^M"
			return(0)
		end
		plnts.str=plnts.str||"|"||plnts.i
		
		res=zocwaitmux("None","Level 1","Level 2","Level 3", "Level 4", "Level 5", "Level 6")
		call zocwait "^M"
		
		parse value zoclastline() with plnts.mre.i"%" plnts.figs.i plnts.qcan.i plnts.cls.i
		plnts.cls.i=strip(plnts.cls.i)
	end		
return (0)

quickStats: procedure expose stats. /* quickStats [DoSend] */
	if arg(1,"O") then DoSend=1; else DoSend=arg(1)
		
	if DoSend then call zocsend "/"
	call zocwait "Sect "
	call zocwaitmux d2c(179), "^M"
	
	stats.sect=zoclastline()
	stats.sect = left(stats.sect, length(stats.sect)-1)
	stats.sect=BADCOMMAS(stats.sect)

	call zocwait "Creds "
	call zocwaitmux d2c(179), "^M"
	
	stats.creds=zoclastline()
	stats.creds = left(stats.creds, length(stats.creds)-1)
	stats.creds=BADCOMMAS(stats.creds)
	
	call zocwait "Figs "
	call zocwaitmux d2c(179), "^M"
	
	stats.figs=zoclastline()
	stats.figs = left(stats.figs, length(stats.figs)-1)
	stats.figs=BADCOMMAS(stats.figs)

	call zocwait "Hlds "
	call zocwaitmux d2c(179), "^M"
	
	stats.holds=zoclastline()
	stats.holds = left(stats.holds, length(stats.holds)-1)
	stats.holds=BADCOMMAS(stats.holds)

	call zocwait "Phot "
	call zocwaitmux d2c(179), " "
	stats.ptorps=zoclastline()
	stats.ptorps= left(stats.ptorps, length(stats.ptorps)-1)

	call zocwait "GTorp "
	call zocwaitmux d2c(179), " "
	stats.gtorps=zoclastline()
	stats.gtorps= left(stats.gtorps, length(stats.gtorps)-1)

	call zocwait "EPrb "
	call zocwaitmux d2c(179), " "
	stats.eprb=zoclastline()
	stats.eprb= left(stats.eprb, length(stats.eprb)-1)

	call zocwait "Exp "
	call zocwaitmux d2c(179), " "
	stats.exp=zoclastline()
	stats.exp = left(stats.exp, length(stats.exp)-1)
	stats.exp=BADCOMMAS(stats.exp)

	call zocwait "Ship "
	call zocwait "^M"
	
	ln=strip(zoclastline())
	parse value ln with stats.shipnum stats.shiptype

return(0)

plntnum: procedure expose CurrPrompt
	ZocSend "^M"
	Call ZocWait "command"
	plnt=zoclastline()
	if plnt="Citadel command" then do
	   ZocSend "q"
	   end
	ZocSend "^M"
	Call ZocWait "Planet #"
	Call ZocWait " "
	plnt=zoclastline()
	plntl=length(plnt)
	plntl=plntl - 1
	plnt=substr(plnt,1,plntl)
	CurrPrompt="planet"
RETURN (plnt)

A_uppa: procedure
	val=arg(1)
	translate(val)	
return(val)

warpsOutToWarpsIn: procedure expose numWarpsIn. warpsIn. s.
	
	numWarpsIn.=0
	warpsIn.=0
	do i = 1 to 5000
		do j = 1 to 6
			wt=_warp(s.i,j)
			if wt \= 0 then do
				numWarpsIn.wt=numWarpsIn.wt+1
				nwi=numWarpsIn.wt
				warpsIn.wt.nwi=i
			end
		end
	end
return(0)


choose_adj_sector:
	if CurrPrompt== "citadel" then call zocsend "s"; else call zocsend "d"
	
	if zocwait("Warps to Sector(s) :")=640 then call errorr "timeout"
	if zocwait("^M")=640 then call errorr "timeout"
	wlist=zoclastline()
	if zocwait("ommand")=640 then call errorr "timeout"
	
	sect.2=_chooselist("which sector to trade with?", wlist, "-")
	if sect.2="##CANCEL##" then call _quit "script cancelled by user."
	sect.2=_stripint(sect.2)
return(sect.2)


calc_zeros:
	cz_this_sec_pt=arg(1)
	cz_other_sec_pt=arg(2)

	zeros=""

	/* Are we selling anything? */

	selling=0
	
	if cz_this_sec_pt.fuel=="B" & cz_other_sec_pt.fuel="S" then selling=1
	if cz_this_sec_pt.org=="B" & cz_other_sec_pt.org="S" then selling=1
	if cz_this_sec_pt.eq=="B" & cz_other_sec_eq.fuel="S" then selling=1

	buying=0
	
	if cz_this_sec_pt.fuel=="S" & cz_other_sec_pt.fuel="B" then buying=1
	if cz_this_sec_pt.org=="S" & cz_other_sec_pt.org="B" then buying=2
	if cz_this_sec_pt.eq=="S" & cz_other_sec_eq.fuel="B" then buying=3
	
	if selling then zeros="^M^M"

	if (buying=3 | buying=2) & cz_this_sec_pt.fuel=="S" then zeros=zeros||"0^M"
	if buying=3 & cz_this_sec_pt.org=="S" then zeros=zeros||"0^M"
	
	if buying > 0 then zeros=zeros||"^M^M"
return(zeros)

LandFirstPlanetScanner:
	call zocsend "L"
	call zocwait "Registry#"
	call zocwait "<"
	call zocwait ">"
	pln=zoclastline()
	pln=left(pln,length(pln)-1)
	call zocsend pln || "^M"
return(0)

LandFirstL1Scanner: procedure
	/* If there's no L1 in the sector you get what you deserve */

	call zocsend "L"
	res=0
	call zocwait "Registry#"
	do while res = 0 
		call zocwait "<"	
		call zocwait ">"
		pln=zoclastline()
		pln=left(pln,length(pln)-1)
		res=zocwaitmux("None","Level")
	end
	call zocsend pln || "^M"
return(pln)

GetAdjacentFuel:
	i=0
	call dscan
	Fnd=0
	DO WHILE (Fnd=0) & (i<g_numadjsecs)
		i=i+1
		call PortType(g_adjsec.i)
		if q_porttype.fuel="S" then Fnd=1
	END
	if Fnd=1 then do
		call zocsend "M" g_adjsec.i "^M"
		call zocsend "PT^M^M"
		return(1)
	end
RETURN(0)

PortType: /* sector [Use PT (rather tham CR^MQ)] */
	if arg(2) then call zocsend "PT" 
	else call zocsend "CR" arg(1) "^MQ"
	res=ZocWaitMux("Commerce","You have never", "have no information")
	q_porttype.Visited=1
	
	if res==1 | res == 2 then do
		q_porttype.fuel="N"
		q_porttype.org="N"
		q_porttype.eq="N"
		
		if res==1 then q_porttype.Visited=0
		return(q_porttype)
	end
	q_porttype.fuel="B"
	q_porttype.org="B"
	q_porttype.eq="B"

	Call ZocWait "Fuel Ore"
	res=ZocWaitMux("Buying", "Selling")
	if res = 1 then q_porttype.fuel="S"
	call zocwait "%"
	parse value zoclastline() with " "q_porttype.fuel_amount q_porttype.fuel_perc"%"

	Call ZocWait "Organics"
	res=ZocWaitMux("Buying", "Selling")
	if res = 1 then q_porttype.org="S"
	call zocwait "%"
	parse value zoclastline() with " "q_porttype.org_amount q_porttype.org_perc"%"

	Call ZocWait "Equip"
	res=ZocWaitMux("Buying", "Selling")
	if res = 1 then q_porttype.eq="S"	
	call zocwait "%"
	parse value zoclastline() with " "q_porttype.eq_amount q_porttype.eq_perc"%"
return(0)

getFirstShipContaining:
	Fnd=0
	DO WHILE Fnd=0
		Fnd=ZocWaitMux("Pause",arg(1))
		if Fnd=0 then Call ZocSend "^M"
	END
	
	ShipNum = left(ZocLastLine(),4)
return(ShipNum)

bwarp: /* ONLY FROM CIT PROMPT */
	call zocsend "B" arg(1) 
	result=zocwaitmux("ARE YOU SURE","Beam to what")
	call zocsend "^M"
	if result = 0 then do 
		call zocsend "N"
		exit
	end
	if arg(1) < 11 then call zocwait "Federation Beacon"
bwarp_sa:
	result=zocwaitmux("lind", "Locked","You have marked sector")
	if result = 2 then do
		call zocsend "Y"
		signal bwarp_sa
	end
	if result=0 then do
		call zocsend "N"
		exit
	end
	call zocsend "Y^M" /* ^M deals with possible mine avoid prompt */
RETURN(0)

twarp: /* ONLY FROM COMMAND PROMPT */
	call zocsend "M" arg(1) "^MY"
	call zocwait "TransWarp drive?"
	result=zocwaitmux("lind", "Locked")
	if result=0 then do
		call zocsend "N"
		exit
	end
	call zocsend "Y"
return(0)

pwarp: procedure /* <destination> */ /* ONLY FROM CIT PROMPT */
	call zocsend "P"arg(1)"^MY"
	res = zocwaitmux("Blind Jump", "shall we engage", "You are already in that sector!")		
	if res==2 then res = 1
RETURN(res)

GetSectorInfo: /* ONLY FROM COMMAND PROMPT */
	call zocsend "D"
	Call ZocWait "Re-Display"
		
	call ZocWait("Sector  :")
	call ZocWait("in")
	g_CurrentSector=zoclastline()
	g_CurrentSector=left(g_CurrentSector, length(g_CurrentSector)-2)

	thing=0
	
	/* ultimately this will be a while loop */	
	
	thing=zocwaitmux("Warps", "Traders :", "Ports", "Alien Tr:", "Ferrengi:") 
		
	if thing=2 then do /* port */
		call zocwait "Class"
		call zocwait "("
		call zocwait ")"
		g_porttype=zoclastline()
		g_porttype=left(g_porttype, length(g_porttype)-1)
		g_hasFuel=0
		if left(g_porttype,1)="S" then g_hasFuel=1
	end
	
return(0)

BADCOMMAS:
stin=arg(1)
rv=""
DO addchar=1 to length(stin)
        holdsit=substr(stin,addchar,1)
        if holdsit<>"," then rv=rv||holdsit
END
RETURN rv

hscan_figs: procedure expose hscan.HasPlanets. hscan.Figs.Amt. /* Hscans, looking at the sector arg(1), returns the corp that owns the figs*/
	call zocsend "SH"
	g_numadjsecs=0
	res=3
	call zocwait("Long Range Scan")
	call zocwait("Sector  : "||arg(1))	
	
	
	hscan.HasPlanets.arg(1)=0
	hscan.Figs.Amt.arg(1)=0
	
	do while res > 1
		res= zocwaitmux("Warps to Sector(s) :","Sector  : ","Planets : ","Fighters: ")
		if res==2 then hscan.HasPlanets.arg(1)=1
		
		/* Fighters: 999,601,980 (belong to space ghost) [Defensive] */
		if res==3 then do
			call zocwait "(belong to "
			nf=zoclastline()
			nf=strip(nf)
			nf=strip(nf,",")
			nf=left(nf,length(nf)-5)
			hscan.Figs.Amt.arg(1)=nf

			res2=zocwaitmux("your Corp","Corp#",")")
			if res2 == 2 then do
				call zocbeep 1
				call zocwriteln "Personal figs encountered"
				exit
			end
			if res2== 0 then return(0)
			call zocwait(",")
			figown=zoclastline()
			figown=left(figown, length(figown)-1)
			return(figown)	
		end
	end
return(0)
	

dscan:
	dscan_send=1
	if arg(1,"E") then dscan_send = arg(1)
	if dscan_send then call zocsend "SD"
	
	g_numadjsecs=0
	res=0
	call zocwait("Density Scan")
	call zocwait("Sector")
	
	dscand.=0
	dscand.sector.=0
	DO while res == 0
		g_numadjsecs=g_numadjsecs+1
		call zocwait("==>")
		sec = zoclastline()
		sec=left(sec,length(sec)-3)
		sec=strip(strip(sec),,"(")
		adjsec=strip(sec,,")")
		
		g_adjsec.g_numadjsecs=adjsec
		
		/* ok, now density */
		
		call zocwait("Warps")
		sec=zocLastLine()
		sec=left(sec,length(sec)-5)
		sec=strip(BADCOMMAS(sec)*1)
		dscand.g_numadjsecs=sec

		
		dscand.sector.adjsec=sec
		
		/* msgbox dscand.sector.adjsec */

		call zocwait("Anom")
		dscana.g_numadjsecs=zocwaitmux("No","Yes")
		dscana.sector.adjsec=dscana.g_numadjsecs
		res = zocWaitMux("Sector", "ommand")			
	end
return(0)

/* ttp wrappers */

sendln:
    call ZocSend arg(1) "^M"
return(0)

send:
    call ZocSend(arg(1))
return(0)

wait:
	Call ZocWait(arg(1))
return(0)

setAbortAllKeys:
	call zocsend "CCCQ  " /* Put you in the computer from wherever; may also put you in cit... */
	
	call zocsend "N"
	call zocwait "Computer command"
	call zocwait "Abort display on keys    -"	
	res =zocwaitmux("ALL KEYS", "SPACE")
	if res=1 then call zocsend "9"
	call zocsend "^MQ"
	call zocwait "Computer command"
	
return(0)

setAbortSpace:
	call zocsend "CCCQ  " /* Put you in the computer from wherever; may also put you in cit... */
	
	call zocsend "N"
	call zocwait "Computer command"
	
	call zocwait "Abort display on keys    -"
	res =zocwaitmux("SPACE", "ALL KEYS")
	if res=1 then call zocsend "9"
	call zocsend "^MQ"
	call zocwait "Computer command"
	
return(0)

BADHAGGLE:
               
	offer1=arg(1)
	haggle=offer1*(138/100)-1
	haggle=trunc(haggle,0)
	
	call zocsend haggle
	call zocsend "^M"

RETURN(0) 



/*_____________ Stuff from the rev's library */


/*** THE REVEREND'S TW LIBRARY FOR ZOC/REXX ***/
/*     last updated: 4 May 2001, 14:52:46     */

/** _logcim v.1 **/

_logcim:

 lcpath=arg(1)
 lcname=arg(2)
 lctasks=arg(3)
 lcdefault=arg(4)

 call zoclogging 0
 call zocsend "^^"
 if zocwait(":")=640 then call _error "timeout"
 call zocrespond "[Pause]", " "
 call zoctimeout 60

 do while lctasks\=""

  parse var lctasks lctask ";" lctasks
  select
   when lctask="portcim" then lcext=".prt"
   when lctask="sectorcim" then lcext=".sct"
   otherwise lctask=""
  end /* select */

  if lctask\="" then do
   if _fileexists(lcpath||lcname||lcext) then call dosdel lcpath||lcname||lcext
   call zoclogname lcname||lcext
   call zoclogging 1
   call zoctimeout 3000
   select
    when lctask="portcim" then call zocsend "r"
    when lctask="sectorcim" then call zocsend "i"
   end /* select */
   if zocwait(":")=640 then call _error "timeout"
   call zoclogging 0
  end /* if */

 end /* do */

 call zoctimeout 60
 call zocsend "q"
 if zocwait("ENDINTERROG")=640 then call _error "timeout"
 call zocrespond "[Pause]"
 call zoclogname lcdefault
 call zoclogging 1

return

/** _ansi v.1 **/

_ansi:
 b=0
 if arg(1)="b" then do
  b=1
  c=arg(2)
 end /* if */
 else c=arg(1)
 select
  when c="gray" then ansi=30
  when c="red" then ansi=31
  when c="green" then ansi=32
  when c="yellow" then ansi=33
  when c="blue" then ansi=34
  when c="magenta" then ansi=35
  when c="cyan" then ansi=36
  when c="white" then ansi=37
  otherwise ansi=37
 end /* select */
 ansi="^[["||b||";"||ansi||"m"
return ansi

/** _askinistr v.2 **/

_askinistr:
 aipmt=arg(1)
 aidef=arg(2)
 aifname=arg(3)
 aisect=arg(4)
 aivar=arg(5)
 aiflag=0

 if aigame="##EOF##" then aiflag=1
 if \aiflag then aistr=_getinivar(aifname, aisect, aivar)
 if aistr="##EOF##" then aiflag=1
 if aiflag then do
  if aipmt="##DEFAULT##" then aistr=aidef
  else aistr=zocask(aipmt,aidef)
 end /* if */
 else do
  parse var aistr aitemp "^" .
  if length(aitemp)>17 then aitemp=left(aitemp,20)
  if aitemp\=aistr then aitemp=aitemp||"..."
  call zocwriteln "<< using "||aifname||" - "||aivar||"="||aitemp||" >>"
 end /* else */
 if aistr="##CANCEL##" then call _quit "script cancelled by user."
return aistr

/** _askininum v.1 **/

_askininum:
 aipmt=arg(1)
 aidef=arg(2)
 aifname=arg(3)
 aisect=arg(4)
 aivar=arg(5)
 aiflag=0

 if aisect="##EOF##" then aiflag=1
 if \aiflag then ainum=_getinivar(aifname, aisect, aivar)
 if ainum="##EOF##" then aiflag=1
 ainum=_stripint(ainum)
 if ainum="" then aiflag=1
 if aiflag then do
  if aipmt="##DEFAULT##" then ainum=aidef
  else ainum=_asknum(aipmt,aidef)
 end /* if */
 else call zocwriteln "<< using "||aifname||" - "||aivar||"="||ainum||" >>"
 if ainum="##CANCEL##" then call _quit "script cancelled by user."
return ainum

/** _asknum v.3 **/

_asknum:
 aninit=arg(2)
 andone=0
 do while \andone
  anans=zocask(arg(1), aninit)
  if anans="##CANCEL##" then andone=1
  else do
   anans=_stripint(anans)
   if anans\="" then andone=1
  end /* else */
  if \andone then aninit="please enter a number or ESC to cancel."
 end /* do */
 if lower(arg(3))="c" & anans="##CANCEL##" then call _quit "script cancelled by user."
return anans

/** _yesno v.2 **/

_yesno:
 select
  when arg(2)="yn" then yn=zocrequest(arg(1)||" (ESC=no)", "yes", "no")
  otherwise yn=zocrequest(arg(1), "yes", "no", "cancel")
 end /* select */
 select
  when yn="cancel" then call _quit "script cancelled by user."
  when yn="##CANCEL##" & arg(2)\="yn" then call _quit "script cancelled by user."
  when yn="yes" then yn=1
  otherwise yn=0
 end /* select */
return yn

/** _ini v.4 **/

_getinivar:
 ininame=arg(1)
 inihead=arg(2)
 inivar=arg(3)

 if ininame="" then call _error "no filename"
 if inihead="" then call _error "no heading"
 if inivar="" then call _error "no variable"

 if stream(ininame, "C", "QUERY EXISTS")="" then inival="##EOF##"
 else do
  call stream ininame, "C", "OPEN READ"
 
  inidone=0
  inieof=0
  if stream(ininame, "S")\="READY" then inieof=1
 
  do while \(inidone | inieof)
   iniline=linein(ininame)
   if left(iniline,1)=="[" then do
    if substr(iniline,2,length(iniline)-2)==inihead then inidone=1
   end /* if */
   if stream(ininame, "S")\="READY" then inieof=1
  end /* do */
 
  inidone=0
 
  do while \(inidone | inieof)
   iniline=linein(ininame)
   if left(iniline,1)="[" then inieof=1
   inieq=pos("=",iniline)
   if inieq>0 then do
    if left(iniline,inieq-1)==inivar then inidone=1
   end /* if */
   if stream(ininame, "S")\="READY" then inieof=1
  end /* do */
 
  call stream ininame, "C", "CLOSE"
 
  if inieof then inival="##EOF##"
  else inival=substr(iniline,inieq+1)
 end /* else */

return inival

_getiniheadings:
 ininame=arg(1)
 if ininame="" then call _error "no filename"
 if stream(ininame, "C", "QUERY EXISTS")="" then inilist="##EOF##"
 else do
  call stream ininame, "C", "OPEN READ"
 
  inilist=""
  inieof=0
  if stream(ininame, "S")\="READY" then inieof=1
 
  do while \inieof
   iniline=linein(ininame)
   if left(iniline,1)=="[" then do
    inilist=inilist||substr(iniline,2,length(iniline)-2)||";"
   end /* if */
   if stream(ininame, "S")\="READY" then inieof=1
  end /* do */
 
  if length(inilist)=0 then inilist="##EOF##"
  call stream ininame, "C", "CLOSE"
 end /* else */
return inilist

/** _chooselist v.4 **/

_chooselist:
 clprompt=arg(1)
 cllist=arg(2)
 if cllist="" then call _error "no list"
 cldelim=arg(3)
 if cldelim=""        then call _error "missing delimiter"
 if length(cldelim)>1 then call _error "long delimiter"
 clch.=""

 cldone=0
 cli=0
 cld=pos(cldelim, cllist)
 if cld=0 then do
  clch.1=cllist
  cldone=1
 end /* if */

 do while \cldone
  cli=cli+1
  clch.cli=left(cllist, cld-1)
  cllist=substr(cllist, cld+1)
  cld=pos(cldelim, cllist)
  if cld=0 then cldone=1
 end /* while */
 if length(cllist)>0 then do
  cli=cli+1
  clch.cli=cllist
 end /* if */
 if cli<7 then clmax=1
 if cli<5 then clmax=0
 if cli>=7 then clmax=(cli-5)%2+1

 cldone=0
 clpos=0
 do while \cldone
  if clpos<0 then clpos=0
  if clpos>clmax then clpos=clmax

  select
   when clpos=0 then do
    if clmax=0 then clans=zocrequest(clprompt, clch.1, clch.2, clch.3, clch.4)
    else clans=zocrequest(clprompt, clch.1, clch.2, clch.3, "next")
   end /* when */
   when clpos=clmax then do
    clp1=(clpos-1)*2+4
    clp2=clp1+1
    clp3=clp1+2
    clans=zocrequest(clprompt, "back", clch.clp1, clch.clp2, clch.clp3)
   end /* when */
   otherwise do
    clp1=(clpos-1)*2+4
    clp2=clp1+1
    clans=zocrequest(clprompt, "back", clch.clp1, clch.clp2, "next")
   end /* otherwise */
  end /* select */

  select
   when clans="next" then clpos=clpos+1
   when clans="back" then clpos=clpos-1
   when clans="##CANCEL##" then cldone=1
   when clans="" then donothing=1
   otherwise cldone=1
  end /* select */

 end /* do */

 if lower(arg(4))="c" & clans="##CANCEL##" then call _quit "script cancelled by user."

return clans

/** _quit v.3 **/

_quit:
 if arg(1)=="" then qmsg="<< script ended. >>"
 else qmsg="<< script ended:  "||arg(1)||" >>"

 qline=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
 if length(qline)>0 then call zocwriteln
 call zocwriteln "^[[1;32m"||qmsg||"^[[0;35m"
 if length(qline)>0 then call zocwrite qline
 exit
return 1

/** _error v.3 **/

_error:
 if arg(1)="" then call zocterminate
 else errmsg="<< script error:  "||arg(1)||" >>"
 errmail="<< if this is a serious problem, email me at: tw.the_reverend@excite.com >> "

 eline=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
 if length(eline)>0 then call zocwriteln
 call zocwriteln "^[[1;31m"||errmsg||"^[[0;35m"
 if arg(1)\="timeout" then call zocwriteln "^[[1;33m"||errmail||"^[[0;35m"
 if length(eline)>0 then call zocwrite eline
 call zocbeep 1
 exit
return

/** _stripint v.1 **/

_stripint:
 stint=""
 sttemp=strip(arg(1))
 if bdflag=1 then call _error
 if datatype(sttemp,"W") then stint=sttemp
 else do
  do sti=1 to length(sttemp)
   stchar=substr(sttemp,sti,1)
   if length(stint)=0 then do
    if verify(stchar,"1234567890-")=0 then stint=stint||stchar
   end /* if */
   else if verify(stchar,"1234567890")=0 then stint=stint||stchar
  end /* do */
  if \datatype(stint,"W") then stint=""
 end /* do */
return stint

/** _getgameinfo v.1 **/

_getgameinfo:
 parse value zocgetglobaloption("ScriptPath") with . '="' ggpath '"'
 ggpath=ggpath||"\"
 ggini=ggpath||"script.ini"
 
 parse value zocgetglobaloption("WindowTitle") with . '="' gggame '"'
 if gggame="" then do
  gglist=_getiniheadings(ggini)
  if gglist="##EOF##" then gggame="##EOF##"
  else gggame=_chooselist("select a game:", gglist, ";", "c")
 end /* do */

 call zocwriteln "<< using "||ggini||" - ["||gggame||"] >>"

 ggr=ggpath||";"||ggini||";"||gggame
return ggr

/** _newline v.1.01 **/
/* Revised DB - Attac Compatibility */

_newline:
 if ATTAC=1 then do
 	call zocwrite arg(1)
 	return
 end
 if zocgetinfo("CURSOR-X")>0 then call zocwriteln arg(1)
 else call zocwrite arg(1)
return

/** _file v.2 **/

_fileclose:
 call stream arg(1), "C", "CLOSE"
return

_fileeof:
 if stream(arg(1), "S")="READY" then feofr=0
 else feofr=1
return feofr

_fileexists:
 if stream(arg(1), "C", "QUERY EXISTS")="" then fer=0
 else fer=1
return fer

_fileopenr:
 for=1
 foname=arg(1)
 if foname="" then call _error "no filename"
 for=_fileexists(foname)
 if for then do
  call stream foname, "C", "OPEN READ"
  for=\_fileeof(foname)
  if \for then call _fileclose foname
 end /* if */
return for

_fileopenw:
 for=1
 foname=arg(1)
 if foname="" then call _error "no filename"
 for=_fileexists(foname)
 if for then do
  call stream foname, "C", "OPEN WRITE"
  call stream foname, "C", "SEEK <0"
 end /* if */
 else for=_filenew(foname)
return for

_filenew:
 fnr=1
 fnname=arg(1)
 if fnname="" then call _error "no filename"
 if \_fileexists(fnname) then call stream fnname, "C", "OPEN WRITE"
 else do
  if lower(arg(2))="delete" then do
   call dosdel fnname
   if \_fileexists(fnname) then call stream fnname, "C", "OPEN WRITE"
   else fnr=0
  end /* if */
  else fnr=0
 end /* else */
return fnr

/** _get_log_info v.1.1 **/
/* Revised DB- Attac compatibility */

_get_log_info:

 if Attac=1 then return "####NOT YET COMPATIBLE"
 parse value zocgetoption("CaptDefaultName") with . '="' gldefault '"'
 parse value zocgetglobaloption("CapturePath") with . '="' glpath '"'
 glpath=glpath||"\"
 glr=glpath||";"||gldefault
return glr

/** _buildmap v.1 **/

_buildmap:
 bmpath=arg(1)
 bmname=arg(2)
 bmns=arg(3)

 bmmapname=bmpath||bmname||".map"

 call _newline
 call zocwrite _ansi("b", "cyan")||"loading map data for "||bmmapname||":"

 bmsr.=""
 
 call _loadsectorcim bmpath||bmname||".sct"
 
 bmpr.=""
 if _fileexists(bmpath||bmname||".prf") then do
  call _loadportcim bmpath||bmname||".prf"
  do bmi=1 to bmns
   bmpr.bmi=p.bmi
  end /* do */
  call _loadportcim bmpath||bmname||".prt"
 end /* if */
 else call _loadportcim bmpath||bmname||".prt"
 
 bmreclen=22
 
 call _newline
 call zocwrite _ansi("b", "cyan")||"constructing map "||bmmapname||"."

 if \_filenew(bmmapname, "delete") then call _error "unable to create file:  "||bmmapname
 
 call charout bmmapname, d2c(bmreclen) /* record length   */
 
 bmmon=1
 do bmi=1 to bmns
 
  bmrec.=0
 
  /* set flags in record #1 */
  if s.bmi\="" then bmrec.1=32                        /* sector explored */
  if p.bmi\="" | bmpr.bmi\="" then bmrec.1=bmrec.1+16 /* port exists     */
  if p.bmi\="" then bmrec.1=bmrec.1+8                 /* port available  */
 
  /* set port type in record #1 */
  if p.bmi="" then bmportinfo=bmpr.bmi
  else bmportinfo=p.bmi
 
  /* set port info in records #2-10 */
  if bmportinfo\="" then do
   if substr(bmportinfo,3,1)="B" then bmrec.1=bmrec.1+1 /* buy ore */
   if substr(bmportinfo,2,1)="B" then bmrec.1=bmrec.1+2 /* buy org */
   if substr(bmportinfo,1,1)="B" then bmrec.1=bmrec.1+4 /* buy equ */
   parse var bmportinfo . ";" bmpq.1 "," bmpp.1 ";" bmpq.2 "," bmpp.2 ";" bmpq.3 "," bmpp.3
   do bmj=1 to 3
    bmk=2+(bmj-1)*3
    bmrec.bmk=abs(bmpq.bmj)//256
    bmk=bmk+1
    bmrec.bmk=abs(bmpq.bmj)%256
    bmk=bmk+1
    bmrec.bmk=bmpp.bmj
   end /* do */
  end /* else */
 
  /* set warp info in records #11-22 */
  if s.bmi="" then bmseclist=bmsr.bmi
  else bmseclist=s.bmi
  bmj=11
  do while bmseclist\="" & bmj<=22
   parse var bmseclist bmsector ";" bmseclist
   if bmsector\="" then do
    bmrec.bmj=bmsector//256
    bmj=bmj+1
    bmrec.bmj=bmsector%256
    bmj=bmj+1
   end /* if */
  end /* do */
 
  do bmj=1 to bmreclen
   call charout bmmapname, d2c(bmrec.bmj) 
  end /* do */
 
  bmmon=bmmon+1
  if bmmon//500=0 then call zocwrite "."

 end /* do */
 
 call _fileclose bmmapname
 
 call zocwriteln

return

/** _loadsectorcim v.2 **/

_loadsectorcim:
 lcname=arg(1)

 call _newline
 call zocwrite _ansi("b", "cyan")||"reading "||lcname||"."
 if _fileopenr(lcname) then do

  lceof=_fileeof(lcname)

  s.=""
  lcmon=0
  do while \lceof
  
   lcline=linein(lcname)
   parse var lcline lcrow lcline
   lcrow=strip(lcrow)
   if lcline\="" & lcrow\="" then do

    parse var lcline s.lcrow lcline
    s.lcrow=_stripint(s.lcrow)
  
    do while lcline\=""
     parse var lcline lctemp lcline
     lctemp=_stripint(lctemp)
     s.lcrow=s.lcrow||";"||lctemp
    end /* do */
  
    lcmon=lcmon+1
    if lcmon//500=0 then call zocwrite "."
   end /* if */
  
   lceof=_fileeof(lcname)
  
  end /* do */
  
  call _fileclose lcname

 end /* if */
 else call zocwrite "x"

return

/** _loadportcim v.3 **/

	/* Loads a cim into memory:
	
	port_type.<i> = the type of port i e.g. BBS, SSB etc.
	
	*/


    _loadportcim:
     lcname=arg(1)

     call _newline
     call zocwrite _ansi("b", "cyan")||"reading "||lcname||" "
     if _fileopenr(lcname) then do

      lceof=_fileeof(lcname)

      p.=""
      lcmon=0
      do while \lceof
  
       lcline=strip(linein(lcname))
       parse var lcline lcrow " " lcline  /* lcrow is the sector number */
       lcline=" "||lcline
       if lcline\="" & lcrow\="" then do

        lcneg1=0
        lcneg2=0
        lcneg3=0
        lcp1=pos("%",lcline) /* lcpi point to the end of the port % */
        lcp2=pos("%",substr(lcline,lcp1+1))+lcp1
        lcp3=pos("%",substr(lcline,lcp2+1))+lcp2
        
        if pos("-",substr(lcline,1,3))>0 then lcneg1=1  
        if pos("-",substr(lcline,lcp1+1,3))>0 then lcneg2=1
        if pos("-",substr(lcline,lcp2+1,3))>0 then lcneg3=1
  
        if lcneg1 then p.lcrow="B"
        else p.lcrow="S"
        if lcneg2 then p.lcrow=p.lcrow||"B"
        else p.lcrow=p.lcrow||"S"
        if lcneg3 then p.lcrow=p.lcrow||"B"
        else p.lcrow=p.lcrow||"S"
  
  	port_type.lcrow=p.lcrow
  
  	lctemp=_stripint(substr(lcline,3,lcp1-7))
        if lcneg1 then lctemp=-lctemp
        p.lcrow=p.lcrow||";"||lctemp||","||_stripint(substr(lcline,lcp1-4,4))
  
        lctemp=_stripint(substr(lcline,lcp1+3,lcp2-lcp1-7))
        if lcneg2 then lctemp=-lctemp
        p.lcrow=p.lcrow||";"||lctemp||","||_stripint(substr(lcline,lcp2-4,4))
  
        lctemp=_stripint(substr(lcline,lcp2+3,lcp3-lcp2-7))
        if lcneg3 then lctemp=-lctemp
        p.lcrow=p.lcrow||";"||lctemp||","||_stripint(substr(lcline,lcp3-4,4))
  
        lcmon=_spinner(lcmon,500)
       end /* if */
  
       lceof=_fileeof(lcname)
  
      end /* do */
  
      call _fileclose lcname

     end /* if */
     else call zocwrite "x"

    return

/** _file v.2 **/

_fileclose:
 call stream arg(1), "C", "CLOSE"
return

_fileeof:
 if stream(arg(1), "S")="READY" then feofr=0
 else feofr=1
return feofr

_fileexists:
 if stream(arg(1), "C", "QUERY EXISTS")="" then fer=0
 else fer=1
return fer

_fileopenr:
 for=1
 foname=arg(1)
 if foname="" then call _error "no filename"
 for=_fileexists(foname)
 if for then do
  call stream foname, "C", "OPEN READ"
  for=\_fileeof(foname)
  if \for then call _fileclose foname
 end /* if */
return for

_fileopenw:
 for=1
 foname=arg(1)
 if foname="" then call _error "no filename"
 for=_fileexists(foname)
 if for then do
  call stream foname, "C", "OPEN WRITE"
  call stream foname, "C", "SEEK <0"
 end /* if */
 else for=_filenew(foname)
return for

_filenew:
 fnr=1
 fnname=arg(1)
 if fnname="" then call _error "no filename"
 if \_fileexists(fnname) then call stream fnname, "C", "OPEN WRITE"
 else do
  if lower(arg(2))="delete" then do
   call dosdel fnname
   if \_fileexists(fnname) then call stream fnname, "C", "OPEN WRITE"
   else fnr=0
  end /* if */
  else fnr=0
 end /* else */
return fnr

/** _mergeportcim v.1 **/

_mergeportcim:
 mcname=arg(1)

 call _newline
 call zocwrite _ansi("b", "cyan")||"merging "||mcname||"."
 if _fileopenr(mcname) then do

  mceof=_fileeof(mcname)
  
  mcmon=0
  do while \mceof
  
   mcline=strip(linein(mcname))
   parse var mcline mcrow " " mcline
   mcline=" "||mcline
   if mcline\="" & mcrow\="" then do

    mcp=""
    mcneg1=0
    mcneg2=0
    mcneg3=0
    mcp1=pos("%",mcline)
    mcp2=pos("%",substr(mcline,mcp1+1))+mcp1
    mcp3=pos("%",substr(mcline,mcp2+1))+mcp2
    if pos("-",substr(mcline,1,3))>0 then mcneg1=1
    if pos("-",substr(mcline,mcp1+1,3))>0 then mcneg2=1
    if pos("-",substr(mcline,mcp2+1,3))>0 then mcneg3=1
  
    if mcneg1 then mcp="B"
    else mcp="S"
    if mcneg2 then mcp=mcp||"B"
    else mcp=mcp||"S"
    if mcneg3 then mcp=mcp||"B"
    else mcp=mcp||"S"
  
    mctemp=_stripint(substr(mcline,3,mcp1-7))
    if mcneg1 then mctemp=-mctemp
    mcp=mcp||";"||mctemp||","||_stripint(substr(mcline,mcp1-4,4))
  
    mctemp=_stripint(substr(mcline,mcp1+3,mcp2-mcp1-7))
    if mcneg2 then mctemp=-mctemp
    mcp=mcp||";"||mctemp||","||_stripint(substr(mcline,mcp2-4,4))
  
    mctemp=_stripint(substr(mcline,mcp2+3,mcp3-mcp2-7))
    if mcneg3 then mctemp=-mctemp
    mcp=mcp||";"||mctemp||","||_stripint(substr(mcline,mcp3-4,4))
  
    p.mcrow=mcp
 
    mcmon=mcmon+1
    if mcmon//500=0 then call zocwrite "."
   end /* if */
  
   mceof=_fileeof(mcname)
  
  end /* do */
  
  call _fileclose mcname
 
 end /* if */
 else call zocwrite "x"

return

/** _mergesectorcim v.2 **/

_mergesectorcim:
 mcname=arg(1)

 call _newline
 call zocwrite _ansi("b", "cyan")||"merging "||mcname||"."
 if _fileopenr(mcname) then do

  mceof=_fileeof(mcname)

  mcmon=0
  do while \mceof
  
   mcline=linein(mcname)
   parse var mcline mcrow mcline
   mcrow=strip(mcrow)
   if mcline\="" & mcrow\="" then do
 
    mcs=""
    parse var mcline mcs mcline
    mcs=_stripint(mcs)
  
    do while mcline\=""
     parse var mcline mctemp mcline
     mctemp=_stripint(mctemp)
     mcs=mcs||";"||mctemp
    end /* do */
  
    mcold=s.mcrow
    do while mcs\=""
     parse var mcs mctemp ";" mcs
     s.mcrow=_listadd(mctemp,s.mcrow)
    end /* do */
    if s.mcrow\=mcold then s.mcrow=_listsort(s.mcrow)
 
    mcmon=mcmon+1
    if mcmon//500=0 then call zocwrite "."
   end /* if */
  
   mceof=_fileeof(mcname)
  
  end /* do */
  
  call _fileclose mcname

 end /* if */
 else call zocwrite "x"

return

/** _list v.2 **/

_listadd:
 laadd=arg(1)
 lalist=arg(2)
 latemp1=lalist
 lafound=0
 if lalist="" then lalist=laadd
 else do
  do while latemp1\=""
   parse var latemp1 latemp2 ";" latemp1
   if latemp2=laadd then lafound=1
   if lafound then latemp1=""
  end /* do */
  if \lafound then lalist=lalist||";"||laadd
 end /* else */
return lalist

_listsort:
 lslist=arg(1)
 lsa.=""
 lsi=0
 do while lslist\=""
  lsi=lsi+1
  parse var lslist lsa.lsi ";" lslist
 end /* do */
 do lsk=lsi-1 to 1 by -1
  do lsj= 1 to lsk
   lsj2=lsj+1
   if lsa.lsj>lsa.lsj2 then do
    lstemp=lsa.lsj
    lsa.lsj=lsa.lsj2
    lsa.lsj2=lstemp
   end /* if */
  end /* do */
 end /* do */
 lslist=lsa.1
 lsi=2
 do while lsa.lsi\=""
  lslist=lslist||";"||lsa.lsi
  lsi=lsi+1
 end /* do */
return lslist

_listinstr:
 lilist=arg(1)
 listr=arg(2)
 if listr="" then lr=1
 limode=arg(3)
 if limode\="cs" then do
  lilist=lower(lilist)
  listr=lower(listr)
 end /* if */

 lr=0
 if listr="" then lr=1
 else do
  do while lilist\=""
   parse var lilist liitem ";" lilist
   if pos(liitem, listr)>0 then do
    lr=1
    lilist=""
   end /* if */
  end /* do */
 end /* else */
return lr

_listin:
 lilist=arg(2)
 lir=0
 do while lilist\=""
  parse var lilist litemp ";" lilist
  if litemp==arg(1) then do
   lir=1
   lilist=""
  end /* if */
 end /* do */
return lir

/** _savesectorcim v.1 **/

_savesectorcim:
 scname=arg(1)
 scns=arg(2)
 if scns="" then call _error "number of sectors missing."

 if \_filenew(scname, "delete") then call _error "unable to create "||scname||"."

 call zocwriteln
 call zocwrite _ansi("b", "cyan")||"writing "||scname||"."

 scmon=0
 scwns=length(scns)
 do sci = 1 to scns
  if s.sci\="" then do
   sclist=s.sci
   scline=_space(scwns-length(sci))||sci
   do while sclist\=""
    parse var sclist sctemp ";" sclist
    scline=scline||_space(scwns+1-length(sctemp))||sctemp
   end /* do */
   call lineout scname, scline
   scmon=scmon+1
   if scmon//500=0 then call zocwrite "."
  end /* if */
 end /* do */

 call _fileclose scname
return

/** _saveportcim v.1 **/

_saveportcim:
 scname=arg(1)
 scns=arg(2)
 if scns="" then call _error "number of sectors missing."
 scw=length(scns)

 if \_filenew(scname, "delete") then call _error "unable to create "||scname||"."

 call zocwriteln
 call zocwrite _ansi("b", "cyan")||"writing "||scname||"."

 scmon=0
 scwns=length(scns)
 do sci = 1 to scns
  if p.sci\="" then do
   parse var p.sci sctype ";" scq.1 "," scp.1 ";" scq.2 "," scp.2 ";" scq.3 "," scp.3
   scline=copies(" ",scw-length(sci))||sci||" "
   scneg.=" "
   if left(sctype,1)="B" then scneg.1="-"
   if substr(sctype,2,1)="B" then scneg.2="-"
   if right(sctype,1)="B" then scneg.3="-"
   do scj=1 to 3
    scline=scline||scneg.scj||copies(" ",5-length(abs(scq.scj)))||abs(scq.scj)||copies(" ",4-length(scp.scj))||scp.scj||"% "
   end /* do */
   call lineout scname, scline
   scmon=scmon+1
   if scmon//500=0 then call zocwrite "."
  end /* if */
 end /* do */

 call _fileclose scname
return

/** _space v.2 **/

_space:
 spw=arg(1)
 spr=""
 if spw>0 then spr=copies(" ",spw)
return spr

/** _spinner v.1 **/
    _spinner:
     spincount=arg(1)
     if arg(2)="" then spinwidth=50
     else spinwidth=arg(2)
     select
      when spincount=0 then call zocwrite "-"
      when spincount=spinwidth then call zocwrite d2c(27)||"[1D\"
      when spincount=(spinwidth*2) then call zocwrite d2c(27)||"[1D|"
      when spincount=(spinwidth*3) then call zocwrite d2c(27)||"[1D/"
      when spincount=(spinwidth*4) then do
       call zocwrite d2c(27)||"[1D-"
       spincount=0
      end /* when */
      otherwise nop
     end /* select */
     spincount=spincount+1
    return spincount

/** _getinfo v.1 **/
    /*
     Sect 263|Turns 820|Creds 799,881|Figs 5,000|Shlds 400|Hlds 12|Ore 0|Org 0     
     Equ 0|Col 0|Phot 7|Armd 0|Lmpt 0|GTorp 0|TWarp No|Clks 0|Beacns 0|AtmDt 0     
     Crbo 0|EPrb 0|MDis 0|PsPrb No|PlScn No|LRS None|Aln -4,496,437|Exp 0|Corp 5   
     Ship 102 MisFri                                                               
    
     Sect 4695|Turns 72|Creds 629,278|Figs 999|Shlds 1,250|Hlds 125|Ore 116|Org 0
     Equ 0|Col 0|Phot 0|Armd 91|Lmpt 95|GTorp 10|TWarp 2|Clks 5|Beacns 20|AtmDt 5
     Crbo 0|EPrb 25|MDis 8|PsPrb No|PlScn Yes|LRS Holo|Aln -4,500,000|Exp 39,211
     Corp 5|Ship 63 CorFla
    */
    _getinfo:
     giargs=lower(arg(1))
    
     gii=1
     giline.=""
     gidone=0
     call zocsend "/"
     if zocwait("Sect ")=640 then call _error "timeout"
     do while \gidone
      if zocwait("^M")=640 then call _error "timeout"
      giline.gii=strip(zoclastline())||d2c(179)
      
/*      if length(giline.gii) < 5 then do 
      	say "/" giline.gii "/"
      	exit
      end 
      
      say "Processed " gii " lines" */
      
      if giline.gii=d2c(179) then gidone=1
      gii=gii+1
     end /* do */
     giline.1="Sect "||giline.1
    
     givar.=""
     gival.=""
     gii=1
     gij=1
     do while giline.gii\=""
      gipos=pos(d2c(179),giline.gii)
      givar.gij=left(giline.gii,gipos-1)
      parse var givar.gij givar.gij gival.gij
      givar.gij=lower(givar.gij)
      select
       when givar.gij="sect" then gival.gij=_stripint(gival.gij)
       when givar.gij="turns" then gival.gij=_stripint(gival.gij)
       when givar.gij="creds" then gival.gij=_stripint(gival.gij)
       when givar.gij="figs" then gival.gij=_stripint(gival.gij)
       when givar.gij="shlds" then gival.gij=_stripint(gival.gij)
       when givar.gij="crbo" then gival.gij=_stripint(gival.gij)
       when givar.gij="aln" then gival.gij=_stripint(gival.gij)
       when givar.gij="exp" then gival.gij=_stripint(gival.gij)
       otherwise nop
      end /* select */
      giline.gii=substr(giline.gii,gipos+1)
      gij=gij+1
      if giline.gii="" then gii=gii+1
     end /* do */
    
     gir=""
     do while giargs\=""
      parse var giargs giarg ";" giargs
      gii=1
      gif=""
      gidone=0
      do while givar.gii\="" & \gidone
       if giarg=givar.gii then do
        gif=gival.gii
        gidone=1
       end /* if */
       else gii=gii+1
      end /* do */
      if gir="" then gir=gif
      else gir=gir||";"||gif
     end /* do */
    
    return gir

_warp:
 wl=arg(1)
 wn=arg(2)

 do wi=1 to wn
  parse var wl wr ";" wl
  if wr="" then leave
 end /* do */
 if wr="" then wr=0
return wr

/** _pcheck v.2 **/
    _pcheck:
     pc1=arg(1)
     pc2=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
     pcr=0
     pci=1
     do while pc1\=""
      parse var pc1 pc1a ";" pc1
      if _instr(pc1a,pc2,"cs") then pcr=pci
      pci=pci+1
     end /* do */
    return pcr

/** _instr v.2 **/
    _instr:
     ifind=arg(1)
     istr=arg(2)
     if lower(arg(3))\="cs" then do
      ifind=lower(ifind)
      istr=lower(istr)
     end /* if */
     if pos(ifind,istr)>0 then ir=1
     else ir=0
    return ir

/** _drequestlist v.2 **/
    _drequestlist: procedure expose (globals)
     i=zocrequestlist(arg(1),translate(arg(2),"|",arg(3)))
     select
      when i<0 & lower(arg(4))="c" then call _quit "script cancelled by user."
      when i<0 then rslt="##CANCEL##"
      otherwise rslt=_dword(arg(2),i+1,arg(3))
     end /* select */
    return rslt

/** _dword v.2 **/
    _dword: procedure expose (globals)
     rslt=translate(word(translate(arg(1),arg(3)||" "," "||arg(3)),arg(2))," "||arg(3),arg(3)||" ")
    return rslt
