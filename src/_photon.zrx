/* REXX _photon.zrx by the reverend (build 33)                                */
/*-       built by rev-builder version 1.3a on 22 Mar 2014 at 00:15:34       -*/
/*- ------------------------------------------------------------------------ -*/
/*- This script is free, and can be modified for your personal use, but you  -*/
/*- cannot copy or distribute this script or any derivative work based upon  -*/
/*- this script without the express permission of the author.                -*/
/*-                                                                          -*/
/*- This script is provided to you WITHOUT ANY WARRANTY, even the implied    -*/
/*- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         -*/
/*-                                                                          -*/
/*-                       Copyright (C) 2009 Ron Wilson                      -*/
/*- ------------------------------------------------------------------------ -*/
/*- ---------------------*/ _g.!sname="_photon.zrx" /*---------------------- -*/
/*- --------------*/ _g.!sbuild=33; _g.!sdate="2014-03-22" /*--------------- -*/
/*- ------------------------------------------------------------------------ -*/

globals=_setglobals("")
call _timeout 15
call zocsynctime 500
call on halt name _halt

debug=0

/* online / prompt check */
   if \_isonline(1) then call _error "you must be online to use this script."
   pmt=_synchronize()

/* load ini variables */
   sl=_ini_load_settings()
   do i=1 to _dwords(sl,";")
    s=_dword(sl,i,";")
    globals=globals||" !"||s
    interpret '!'||s||'="!"||s'
   end;
   f=0; l=""
   load="sd ns fname vname mname gname dname target ignore shipdelay shiplist"
   do i=1 to words(load)
    s=word(load,i)
    x="!"||s
    interpret s||"=_ini.!settings.x"
    interpret 'if '||s||'="##UNDEF##" then do; l=l s; f=1; end'
   end; if f then call _error "missing config variable(s):"||l; drop load s sl x f l

/* GET FIG AND SECTORCIM INFO */
   reclen=_mapinit(mname)
   call _getfigs fname, "file"
   call _getvoids vname, "file"

/* GET PLANET NUMBER */
   if _listin(pmt,"citadel;planet") then do
    if pmt="citadel" then call zocsend "q"
    planetinfo=_planet_get_info("planet")
    if pmt="citadel" then call zocsend "c"
    planet=_dword(planetinfo,1,";")
    citadel=_dword(planetinfo,3,";")
   end /*if*/
   else do
    planet=0
    citadel=0
   end /*else*/
   parse value _getinfo("sect;phot;turns") with csec ";" photons ";" turns

/* DEFINE DELIVER OPTIONS */
   validprompts="command|citadel|planet|bank|class0|port_haggle"
   if \_listin(pmt,validprompts,"|") then call _error "please start at a known prompt."
   if csec=sd & pmt="class0" then call _error "please start in the bank if you want to be on stardock."
   delivermodes=_list_select(pmt, validprompts, "adjacent;twarp|adjacent;twarp;tpad;pwarp|adjacent;twarp|adjacent;twarp|adjacent;twarp|adjacent;twarp","|")
   macrotocommand=_list_select(pmt, validprompts, " |qq|q|qq|q|z0^Mz0^Mz0^M","|")
   macrotohide=_list_select(pmt, validprompts, " |l ^H"||planet||"^M c |l ^H"||planet||"^M |psgyg|pt|pt","|")
   if pmt="class0" & csec=1 then delivermodes="twarp"
   delivermodes="idle;"||delivermodes
   deliverdelay=0

/* EVALUATE MOVE DELAY */
   movedelay.=.250
   if pmt="citadel" then istats=_get_info_i(pmt)
   else do
    call zocsend macrotocommand
    istats=_get_info_i("command")
    call zocsend macrotohide
   end /*else*/
   tpw=_dword(istats,12,";")
   movedelay=_list_select(shipdelay,"Normal Quarter Third Half Double None", tpw*1000 tpw*250 tpw*333 tpw*500 tpw*2000 250, " ")/1000

   do i=1 to _dwords(shiplist,";")
    s=_iniv(!settings,"!ship."||_dword(shiplist,i,";"))
    if _undef(s) then call _error "missing ship description for" s
    tpw.s=_dword(s,6,";")
    movedelay.s=_list_select(shipdelay,"Normal Quarter Third Half Double None", tpw.s*1000 tpw.s*250 tpw.s*333 tpw.s*500 tpw.s*2000 250, " ")/1000
   end /*do*/

myping=_ping(5)/1000
call zocsend "'"||_g.!sname1||" : build "||_g.!sbuild||" : ping "||myping||"^M"

off=1
deliver="idle"
limpetkill=0
hide="f:1;d:1"
capture=0
refuel=""
repeat=0
base=csec
call _mapseek mname, reclen, csec

a.=0; b.=0; c.=0; d.=0
t0=time("L"); ta.=t0; tb.=t0; tc.=t0; td.=t0; eta.=0; etb.=0; etc.=0; etd.=0
em.="unknown"

repings=0

_g.!cmdptr=0
_g.!cmdmax=0
do forever
 if _g.!cmdptr<_g.!cmdmax then do
  _g.!cmdptr=_g.!cmdptr+1; ptr=_g.!cmdptr
  parse value parse_command(_g.!cmdq.ptr) with user ";" cmd ";" args
  select
   when cmd="st" | cmd="status" then do
    photons=_getinfo("phot")
    call zocsend "'^M"||_g.!sname1 ": status : "||word("ON OFF", off+1)||"^M"
    call zocsend " movedelay  :" movedelay*1000%1||"^M"
    call zocsend " ping       :" myping*1000%1||"^M"
    call zocsend " turns      :" _qs.!turns||"^M"
    call zocsend " photons    :" photons||"^M"
    call zocsend " deliver    :" deliver||"^M"
    call zocsend " limpetkill :" word("no yes", limpetkill+1)||"^M"
    call zocsend " hide       :" hide||"^M"
    call zocsend " capture    :" word("no yes", capture+1)||"^M"
    call zocsend " refuel     :" refuel||"^M"
    call zocsend " repeat     :" word("no yes", repeat+1)||"^M^M"
   end /*when*/
   when cmd="q" & user="##OWNER##" then leave
   when cmd="ping" then myping=_ping(5)/1000
   when cmd="off" then do; off=1; call zocsend "'"||_g.!sname1||" : OFF^M"; end
   when cmd="on" then do; off=0; call zocsend "'"||_g.!sname1||" : ON^M"; end
   when cmd="deliver" & args="" then call zocsend "'"||_g.!sname1||" : valid deliver modes : "||delivermodes||"^M"
   when cmd="deliver" then do
    if \_listin(args,delivermodes,";") then call zocsend "'"||_g.!sname1||" : invalid deliver mode^M"
    else do
     deliver=args
     deliverdelay=_list_select(args,"idle adjacent twarp tpad pwarp", 0 0 movedelay 0 0, " ")
    end /*else*/
    call zocsend "'deliver : "||deliver||"^M"
   end /*when*/
   when cmd="limpetkill" then do; limpetkill=abs(limpetkill-1); call zocsend "'"||_g.!sname1||" : "||cmd||" : "||word("no yes", limpetkill+1)||"^M"; end
   when cmd="repeat"     then do; repeat=abs(repeat-1);         call zocsend "'"||_g.!sname1||" : "||cmd||" : "||word("no yes", repeat+1)||"^M";     end
   when cmd="capture"    then do; capture=abs(capture-1);       call zocsend "'"||_g.!sname1||" : "||cmd||" : "||word("no yes", capture+1)||"^M";    end
   when cmd="hide" then nop
   when cmd="refuel" then nop
   otherwise nop
  end /*select*/
 end /*if*/
 else do
  ans=zocwaitmux("::|entered sector.|activated| of your mines in |INACTIVITY WARNING")
  line=_lastline()
  act=0
  select
   /* command entry */
      when ans=0 then call add_command line
   /* sector entry */
      when ans=1 then do
       parse var line temp "Deployed Fighters Report Sector " target ": " player " entered sector." .
       if strip(temp)="" then do
        ship=substr(player,lastpos("'s",player)+3)
        player=left(player,lastpos("'s",player)-1)
        target=_stripint(target)
       end /*if*/
       if target>=11 & target<=ns & target\=sd then act=1
      end /*when*/
   /* limpet activation */
      when ans=2 & \limpetkill then nop
      when ans=2 then do
       parse var line temp "Limpet mine in " target " activated"
       if strip(temp)="" then do
        ship="##UNKNOWN##"
        player="##UNKNOWN##"
        target=_stripint(target)
       end /*if*/
       if target>=11 & target<=ns & target\=sd then act=1
      end /*when*/
   /* mine disruption */
      when ans=3 then do
       target=_stripint(_grabit("^M"))
       parse var line temp 3 player " disrupted" .
       select
        when temp="R " then target=0
        when temp="R " then target=0
        when temp="P " then target=0
        otherwise do
         ship="##UNKNOWN##"
         player=temp||player
         target=_stripint(target)
        end /*otherwise*/
       end /*select*/
       if target>=11 & target<=ns & target\=sd then act=1
      end /*when*/
   /* inactivity */
      when ans=4 then nop
      when ans=640 & dt(t0,time("L"))%120>repings then do
       repings=repings+1
       if \fe(_ping(1,0)/1000,myping) then myping=_ping(5)/1000
      end /*when*/
      when ans=640 then call zocsend "^["
      otherwise nop
  end /*select*/

  if act then do

if debug then call zocsend "'^M" player "in" target "^M"

   /* update globals */
      call _mapseek mname, reclen, target
      _ex.target=1
      _f.target=0

   /* update targeting queue */
      a.player=b.player; b.player=c.player; c.player=d.player; d.player=target
      ta.player=tb.player; tb.player=tc.player; tc.player=td.player; td.player=time("L")
      da.player=db.player; db.player=dc.player; dc.player=dd.player; dd.player=_mapfind(d.player,"d:1",mname,reclen,1,3)
      a=a.player; b=b.player; c=c.player; d=d.player

if debug & dd.player>0 then call zocsend "  nearest deadend" word("+", \fig(dd.player)+1) dd.player dist(d,dd.player) "^M"

   /* evaluate adjacency and timing */
      ab=is_adjacent(b,a); eab=dt(ta.player, tb.player)
      ac=is_adjacent(c,a); eac=dt(ta.player, tc.player)
      ad=is_adjacent(d,a); ead=dt(ta.player, td.player)
      bc=is_adjacent(c,b); ebc=dt(tb.player, tc.player)
      bd=is_adjacent(d,b); ebd=dt(tb.player, td.player)
      cd=is_adjacent(d,c); ecd=dt(tc.player, td.player)

   /* guess enemy grid method */
      select
       when ac & bd & fe(eac, ebd)                        then em.player="twoship"
       when bc & bd                                       then em.player="zone"
       when cd & (ab | bc) & ecd<=movedelay.ship+myping*3 then em.player="lawnmow"
       when cd & (ab | bc)                                then em.player="slowgrid"
       otherwise                                               em.player="unknown"
      end /*select*/

if debug then call zocsend "  adjacency calc"

   /* find adjacent fig, d<-e, for adjacent photon */
if debug & e>0 then call zocsend " : a1" e

   /* find 2 hop adjacent fig, d->e<-f, for lawnmow photon*/
/*
      do i=1 to words(_s.d)
       n=word(_s.d.!num,i)
       wt=word(_s.d.!wt,i)
       select
        when wt=2 then nop /* twarptype = (w_out, w_both, w_in) */
        when n=c then do; if debug then call zocsend " : L" c; end
        otherwise do
         f=_mapfind(n,"f:1;r:1",mname,reclen,1,1)
         if debug & f>0 then call zocsend " : a2" f
        end /*otherwise*/
       end /*select*/
      end /*do*/
*/
if debug then call zocsend "^M" player "." a b c d "." ab bc cd "." format(eab,,2) format(ebc,,2) format(ecd,,2) "." em.player "^M^M"

   /* act */
      select
       when off then nop
       when deliver="idle" then nop

       /* adjacent delivery */
          when deliver="adjacent" & is_adjacent(d,csec) then do
           call zocsend macrotocommand||"cpy "||d||"^M^Mq"||macrotohide
           photons=max(photons-1,0)
           off=\repeat
          end /*when*/
          when deliver="adjacent" & em.player="lawnmow" then do
           do i=1 to words(_s.csec)
            n=word(_s.csec.!num,i)
            call _mapseek mname, reclen, n
            if word(_s.csec.!wt,i)<2 & is_adjacent(d,n) & d\=csec then do
             calctime=dt(td.player,time("L"))
             timetoenter=movedelay.ship - myping - calctime
             if timetoenter>0 then call zocdelay timetoenter
             call zocsend macrotocommand||"cpy "||n||"^M^Mq"||macrotohide||"'photon : "||n||" : "||timetoenter||" delay (" movedelay.ship myping calctime ")^M"
             photons=max(photons-1,0)
             off=\repeat
            end /*if*/
           end /*do*/
          end /*when*/

       /* twarp delivery */
          when deliver="twarp" & em.player="slowgrid" then do
           e=_mapfind(d,"f:1;r:1",mname,reclen,1,1)
           if e>0 then do
            call zocsend macrotocommand
            if \_twarp(e) then call zocsend macrotohide
            else do
             call zocsend "cpy "||d||"^M^Mq'photon "||e||" --> "||d||"^M"
             select
              when hide="" then n=0
              when hide=0 then n=0
              when abs(_stripint(hide))=hide then n=hide
              otherwise n=_mapfind(e,hide,mname,reclen,ore%3)
             end /*select*/
             select
              when n<=0       then do; base=0; macrotocommand=""; macrotohide=""; end
              when \_twarp(n) then do; base=0; macrotocommand=""; macrotohide=""; end
              when n=base     then call zocsend macrotohide
              otherwise            do; base=0; macrotocommand=""; macrotohide=""; end
             end /*select*/
             photons=max(photons-1,0)
             off=\repeat
            end /*else*/
           end /*if*/
          end /*when*/

       /* tpad delivery */
          when deliver="tpad" & em.player="slowgrid" then do
           e=_mapfind(d,"f:1;r:1",mname,reclen,1,1)
           if e>0 then do
            if \_bwarp(e) then nop
            else do
             call zocsend "cpy "||d||"^M^Mq'photon "||e||" --> "||d||"^M"
             if _twarp(base) then call zocsend macrotohide||"qmnt^Mtnt1^Mc"
             else leave
             photons=max(photons-1,0)
             off=\repeat
            end /*else*/
           end /*if*/
          end /*when*/

       /* pwarp delivery */
          when deliver="pwarp" then do
           e=_mapfind(d,"f:1;r:1",mname,reclen,1,1)
           if e>0 then do
            call zocsend "p"||e||"^Mycpy "||d||"^M^Mq'photon "||e||" --> "||d||"^M"
            photons=max(photons-1,0)
            off=\repeat
           end /*if*/
          end /*when*/

       otherwise call zocsend "'"||_g.!sname1||" : "||deliver||" : unable to respond to "||player||" ("||em.player||")^M"
      end /*select*/

  end /*if*/

 end /*else*/
end /*do*/

call zocsend "'"||_g.!sname1||" : goodbye^M"
exit

dist: procedure expose (globals)
 a=arg(1); b=arg(2)
return _dist.a.b

fig: procedure expose (globals)
 n=arg(1)
return _f.n

dt: procedure expose (globals)
 t1=arg(1); t2=arg(2)
 parse var t1 hr1 ":" mn1 ":" sc1 "." ns1
 parse var t2 hr2 ":" mn2 ":" sc2 "." ns2
 ts1=hr1*3600+mn1*60+sc1
 ts2=hr2*3600+mn2*60+sc2
 ns1=format("0."||ns1,,3)
 ns2=format("0."||ns2,,3)
 ds=(ts2-ts1+86400)//86400 + (ns2-ns1)
return ds

fe: procedure expose (globals)
 a=arg(1); b=arg(2); if arg(3,"E") then f=arg(3); else f=1.2
 if b<a*f & a<b*f then return 1
return 0

is_adjacent: procedure expose (globals)
 a=arg(1); b=arg(2)
/* 0=out 1=both 2=in */
 if _listin(20000+a,_s.b," ") then return 1
 if _listin(a,_s.b," ") then return 1
return 0

parse_command: procedure expose (globals)
 line=arg(1)
 select
  when left(line,2)="R " then do
   subname=strip(substr(line,3,7))
   parse value substr(line,10) with cmd args "::"
  end /*when*/
  when left(line,1)="'" then do
   subname="##OWNER##"
   parse value substr(line,2) with cmd args "::"
   if zocwait("^M")=640 then call _error "timeout"
  end /*when*/
  otherwise do
   subname="##INVALID##"
   cmd="##NA##"
   args="##NA##"
  end /*otherwise*/
 end /*select*/
 cmd=lower(strip(cmd))
 args=strip(args)
 rslt=subname||";"||cmd||";"||args
return rslt

add_command: procedure expose (globals)
 _g.!cmdmax=_g.!cmdmax+1; p=_g.!cmdmax
 _g.!cmdq.p=arg(1)
return 1

/* SPECIAL WAIT WRAPPERS */

_wait: procedure expose (globals)
 ans=zocwaitmux("::|"||arg(1))
 do while ans=0
  call add_command _lastline()
  ans=zocwaitmux("::|"||arg(1))
 end /*do*/
 if ans<640 then ans=ans-1
return ans

_waitmux: procedure expose (globals)
 ans=_wait(arg(1))
return ans

/***                 THE REVEREND'S TW LIBRARY FOR ZOC/REXX                 ***/

/** _setglobals v.5 **/
    _setglobals: procedure expose _verbose _monthdays _monthnames _baseday. _g. _msg. _debug (globals)

     _debug=0
     _verbose=0
     _msg.=""; _msg.0=0
     _monthdays="31;28;31;30;31;30;31;31;30;31;30;31"
     _monthnames="jan;feb;mar;apr;may;jun;jul;aug;sep;oct;nov;dec"
     _baseday.2000=730118 + 1 /* +1 added 6/23/2008 */
     _baseday.2001=_baseday.2000+365+1
     _baseday.2002=_baseday.2001+365
     _baseday.2003=_baseday.2002+365
     _baseday.2004=_baseday.2003+365
     _baseday.2005=_baseday.2004+365+1
     _baseday.2006=_baseday.2005+365
     _baseday.2007=_baseday.2006+365
     _baseday.2008=_baseday.2007+365
     _baseday.2009=_baseday.2008+365+1
     _baseday.2010=_baseday.2009+365
     _baseday.2011=_baseday.2010+365
     _baseday.2012=_baseday.2011+365
     _baseday.2013=_baseday.2012+365+1
     _baseday.2014=_baseday.2013+365
     _baseday.2015=_baseday.2014+365
     _baseday.2016=_baseday.2015+365
     _baseday.2017=_baseday.2016+365+1
     _baseday.2018=_baseday.2013+365
     _baseday.2019=_baseday.2014+365
     _baseday.2020=_baseday.2015+365
     _baseday.2021=_baseday.2016+365+1
     _baseday.2022=_baseday.2013+365
     _baseday.2023=_baseday.2014+365
     _baseday.2024=_baseday.2015+365
     _baseday.2025=_baseday.2016+365+1
     _baseday.2026=_baseday.2013+365
     _baseday.2027=_baseday.2014+365
     _baseday.2028=_baseday.2015+365
     _baseday.2029=_baseday.2016+365+1
     _baseday.2030=_baseday.2013+365
     _baseday.2031=_baseday.2014+365
     _baseday.2032=_baseday.2015+365
     _baseday.2033=_baseday.2016+365+1

     i=lastpos(".",_g.!sname)
     if i=0 then _g.!sname1=_g.!sname
            else _g.!sname1=left(_g.!sname,i-1)

     rslt="_g. _ini. _s. _p. _d. _v. _f. _m. _l. _q. _sl. _ex. _qs. "
     rslt=rslt||"_ef. _efc. _es. _et. _ep. _fc. "
     rslt=rslt||"_path. _dist. _dtomsl. _dfrmsl. "
     rslt=rslt||"_bg. _bd. _nwi. _nwo. _nw. _nwt. _od. _sv. _pv. _vs. _vn. _vi. _mcic. _fh. _fhp. "
     rslt=rslt||"_clv. _online. _msg _msg. _debug "
     rslt=rslt||"_verbose _monthdays _monthnames _baseday. "
     rslt=rslt||"globals "
     if arg(1,"E") then rslt=rslt||arg(1)

     rslt=_space(rslt)
    return rslt

/** _timeout v.1 **/
    _timeout: procedure expose (globals)
     if _g.!timeout="_G.!TIMEOUT" then _g.!timeout=60
     rslt=_g.!timeout
     nt=_stripint(arg(1))
     if arg(1,"E") & nt>0 then do
      call zoctimeout nt
      _g.!timeout=nt
     end /*if*/
    return rslt

/** _halt v.4 **/
    _halt: procedure expose (globals)
     call off halt
     call _cleanup
     call zocwriteln "^[[1;33m< user abort >^[[0m "
     exit
    return

/** _isonline v.3 **/
    _isonline: procedure expose (globals)
     if zocgetinfo("ONLINE")="##YES##" then return 1
     if arg(1,"E") then t=arg(1)
     else call _error "missing parameter in _isonline"
     rslt=0
     o="##NO##"
     call time "R"
     do while time("E")<=t & o\="##YES##"
      o=zocgetinfo("ONLINE")
      if o="##YES##" then rslt=1
     end /*do*/
    return rslt

/** _error v.9 **/
    _error: procedure expose (globals)
     call off halt
     call _cleanup
     call zocwrite _ansi("clearline;bt;frd")||"< script error ("||_g.!sname||" b."||_g.!sbuild||")"
     if arg(1,"E") then call zocwrite " : "||arg(1)
     call zocwriteln " >"
     call zocwriteln _ansi("bt;fye")||"< if this is a serious problem, email me at: revhelper_at_thereverend_dot_org > "
     call zocwriteln "< SCRIPT "||_g.!sname||", BUILD "||_g.!sbuild||", DATE "||_g.!sdate||" > "
     call zocwriteln "< ZOC VERSION '"||zocgetinfo("VERSION")||"', OS '"||zocgetinfo("OSYS")||"', LOCATION '"||zocgetinfo("CONNECTEDTO")||"' >"
     if arg(2,"E") then call zocwriteln _ansi("bt;fgr")||"< "||arg(2)||" >"
     call _beep "error.wav"
    exit

/** _synchronize v.5 **/
    _synchronize: procedure expose (globals)

     if arg(1,"E") then checkcitprompts=arg(1); else checkcitprompts=1

     synchw=_synchronize_vars("w")
     synchr=_synchronize_vars("r")

     call zocsend "&&"
     ans=_waitmux("&&|Pausing is")
     select
      when ans=0 then return "unknown_text_entry"
      when ans=1 then nop
      when ans=640 then return "timeout"
      otherwise nop
     end /*select*/

     ans=_waitmux(synchw)
     select
      when ans=640 then rslt="timeout"
      when ans>0 then do
       if _wait("Pausing is")=640 then call _error "timeout"
      end /*when*/
      otherwise nop
     end /*select*/
     rslt=_dword(synchr,ans+1,";")

     select
      when \checkcitprompts then nop
      when rslt="computer" then do
       call zocsend "q"
       ans=_waitmux("Command [|Citadel command")
       select
        when ans=0 then nop
        when ans=1 then rslt="computer_cit"
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
       call zocsend "c"
      end /*when*/
      when rslt="corporate" then do
       call zocsend "q"
       ans=_waitmux("Command [|Citadel command")
       select
        when ans=0 then call zocsend "t"
        when ans=1 then do
         rslt="corporate_cit"
         call zocsend "x"
        end /*when*/
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*when*/
      otherwise nop
     end /*select*/

    return rslt

/** _ini_load_settings v.1 **/
    _ini_load_settings: procedure expose (globals)

     parse value zocgetoption("CaptDefaultName") with . '="' ldefault '"'
     if left(zocgetinfo("VERSION"),1)>4 then ldefault = zocfilename("RESOLV", ldefault)
     parse value zocgetglobaloption("WindowTitle") with . '="' gname '"'

     lpath=_get_log_path()
     spath=_get_script_path()
     dpath=_get_download_path()

     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then gname=_setgame()
     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then exit
     dname=dosfname(lpath||gname||"_data.ini")

     _ini.="##UNDEF##"

     sectionlist=""
     if _fileopenr(dname) then do
      insection=0
      do while \_fileeof(dname)
       line=strip(linein(dname))
       if _ini_is_section(line) then do
        insection=1
        parse var line "[" section "]"
        section=strip(section)
        if sectionlist="" then sectionlist=section; else sectionlist=sectionlist||";"||section
       end /*if*/
       else do
        if insection then do
         parse var line k "=" v
         v=_ini_format_value(v)
         k="!"||section||".!"||strip(k)
         if k\="!"||section||".!" then _ini.k=strip(v)
        end /*if*/
       end /*else*/
      end /*while*/
      call _fileclose dname
     end /*if*/

     call _iniv "!settings", "!ldefault", ldefault
     call _iniv "!settings", "!lpath",  lpath
     call _iniv "!settings", "!spath",  spath
     call _iniv "!settings", "!dpath",  dpath
     call _iniv "!settings", "!dname",  dname
     call _iniv "!settings", "!gname",  gname
     call _iniv "!settings", "!lname",  lpath||gname||"_log.txt"
     call _iniv "!settings", "!fname",  lpath||gname||"_figs.txt"
     call _iniv "!settings", "!vname",  lpath||gname||"_voids.txt"
     call _iniv "!settings", "!vwname", lpath||gname||"_view.txt"
     call _iniv "!settings", "!pname",  lpath||gname||".prt"
     call _iniv "!settings", "!sname",  lpath||gname||".sct"
     call _iniv "!settings", "!rpname", lpath||gname||"_ref.prt"
     call _iniv "!settings", "!rsname", lpath||gname||"_ref.sct"
     call _iniv "!settings", "!mname",  lpath||gname||".map"
     call _iniv "!settings", "!zname",  lpath||gname||".ztm"
     call _iniv "!settings", "!nfname", lpath||gname||"_nearfig.txt"

    return sectionlist

/** _dwords v.2 **/
    _dwords: procedure expose (globals)
     rslt=words(translate(arg(1),arg(2)||" "," "||arg(2)))
    return rslt

/** _dword v.2 **/
    _dword: procedure expose (globals)
     rslt=translate(word(translate(arg(1),arg(3)||" "," "||arg(3)),arg(2))," "||arg(3),arg(3)||" ")
    return rslt

/** _mapinit v.5 **/
    _mapinit: procedure expose (globals)
     fname=arg(1)
     if arg(2,"E") then m=arg(2); else m=0
     select
      when m=0 then nop
      when m=1 then drop _p. _s. _dist. _path. _dtomsl. _dfrmsl. _bg. _bd. _nwt. _nwi. _nwo. _nw. _od. _sv. _pv.
      otherwise nop
     end /*select*/
     if _f.0="_F.0" then _f.=0
     if _l.0="_L.0" then _l.=0
     if _m.0="_M.0" then _m.=0
     if _s.0="_S.0" then _s.=""
     if _p.0="_P.0" then _p.=""
     if _dist.0.0="_DIST.0.0" then _dist.=255
     if _path.0.0="_PATH.0.0" then _path.=""
     if _dtomsl.0="_DTOMSL.0" then _dtomsl.=255
     if _dfrmsl.0="_DFRMSL.0" then _dfrmsl.=255
     if _bg.0="_BG.0" then _bg.=0
     if _bd.0="_BD.0" then _bd.=0 /* bubble door, results from _mapbubbles */
     if _nwt.0="_NWT.0" then _nwt.=0
     if _nwi.0="_NWI.0" then _nwi.=0
     if _nwo.0="_NWO.0" then _nwo.=0
     if _nw.0="_NW.0" then _nw.=0
     if _od.0="_OD.0" then _od.=0
     if _sv.0="_SV.0" then _sv.=0
     if _pv.0="_PV.0" then _pv.=0
     if _sl.0="_SL.0" then _sl.=0
     if _ex.0="_EX.0" then _ex.=0
     if _v.0="_V.0" then _v.=0
     if _vs.0="_VS.0" then _vs.=0
     if _vn.0="_VN.0" then _vn.="(na)"
     if \_fileopenr(fname) then call _error "unable to open map file: "||fname
     recordlen=c2d(charin(fname))
    return recordlen

/** _getfigs v.15 **/
    _getfigs: procedure expose (globals)
     fname=arg(1)
     mode=arg(2)
     report=arg(3)
     _f.=0
     c=0
     if lower(mode)="file" then parse value _figs_load(fname) with c m
     else do
      parse value _figs_get(fname) with c m cf pf df of tf tot dif
      call _figs_save fname, m
     end /*else*/
    select
     when report=0 then return c
     when report=1 then return c cf pf df of tf tot dif
     otherwise return c
    end /*select*/

/** _getvoids v.8 **/
    _getvoids: procedure expose (globals)
     vname=arg(1)
     mode=arg(2)
     _v.=0
     c=0
     if lower(mode)="file" then parse value _voids_load(vname) with c m
     else do
      parse value _voids_get() with c m
      call _voids_save vname, m
     end /*else*/
    return c

/** _listin v.4 **/
    _listin: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _listin"
     find=arg(1)
     list=arg(2)
     if arg(3,"E") then delim=left(arg(3),1); else delim=";"
     if arg(4,"E") then abbrv=arg(4); else abbrv=0;
     rslt=0
     do i=1 to _dwords(list,delim)
      select
       when \abbrv & find==_dword(list,i,delim) then do; rslt=1; leave; end
       when \abbrv then nop
       when pos(_dword(list,i,delim),find)>0 then do; rslt=1; leave; end
       otherwise nop
      end /*if*/
     end /*do*/
    return rslt

/** _planet_get_info v.1 **/
    _planet_get_info: procedure expose (globals)
     if arg(1,"E") then pmt=arg(1); else pmt=_synchronize()
     if pmt="planet" then do
      if _sendwait("d","Planet #")=640 then call _error "timeout"
      parse value _grabit(":") with n . . s ":"
      if _wait("Fuel Ore")=640 then call _error "timeout"
      parse value _stripcomma(_grabit("^M")) with c.1 cb.1 dp.1 pa.1 sa.1 pm.1 .
      if _wait("Organics")=640 then call _error "timeout"
      parse value _stripcomma(_grabit("^M")) with c.2 cb.2 dp.2 pa.2 sa.2 pm.2 .
      if _wait("Equipment")=640 then call _error "timeout"
      parse value _stripcomma(_grabit("^M")) with c.3 cb.3 dp.3 pa.3 sa.3 pm.3 .
      if _wait("Fighters")=640 then call _error "timeout"
      parse value _stripcomma(_grabit("^M")) with c.4 cb.4 dp.4 pa.4 sa.4 pm.4 .
      cit=_waitmux("Planet command (?=help) [D]|level 1 Citadel|level 2 Citadel|level 3 Citadel|level 4 Citadel|level 5 Citadel|level 6 Citadel")
      do i=1 to 4
       if c.i="N/A"  then c.i=0
       if cb.i="N/A" then cb.i=0
      end /*do*/
      rslt=n s cit c.1 cb.1 dp.1 pa.1 sa.1 pm.1 c.2 cb.2 dp.2 pa.2 sa.2 pm.2 c.3 cb.3 dp.3 pa.3 sa.3 pm.3 c.4 cb.4 dp.4 pa.4 sa.4 pm.4
     end /*if*/
     else call _error "wrong prompt in _planet_get_info"
    return rslt

/** _getinfo v.6 **/
    _getinfo: procedure expose (globals)
     args=lower(arg(1))
     bufflen=32*1024

     /* grab a buffer of text containing the quickstats and strip lf/nul */
     call zocreceivebuf bufflen
     call zocsend "/"
     if _wait("Sect ")=640 then call _error "timeout"
     if _wait("Ship ")=640 then call _error "timeout"
     if _wait("^M")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)>=bufflen then call zocwrite "<buffer overflow>"

     /* reduce buffer to just the quickstats info and change bars to semicolons */
     i=pos("Sect ",buff)
     j=pos("Ship",buff,i)
     j=pos(d2c(13),buff,j)
     buff=substr(buff,i,j-i)
     buff=_space(translate(buff, ";", d2c(179)),1)

     /* strip commas from numbers */
     buff=translate(_space(translate(buff,", "," ,"),0),", "," ,")

     /* remove newlines, strip spaces, and condense to semi-delimited string */
     cr=d2c(13)
     buff2=strip(_dword(buff,1,cr))
     do i=2 to _dwords(buff,cr)
      buff2=buff2||";"||strip(_dword(buff,i,cr))
     end
     buff=buff2
     drop buff2

     /* analyze buffer */
     vr.=""
     vl.=""
     c=0
     do j=1 to _dwords(buff,";")
      c=c+1
      vr.c=strip(_dword(buff,j,";"))
      vl.c=word(vr.c,2)
      vr.c=lower(word(vr.c,1))
      if vr.c="ship" then do
       c=c+1
       vr.c=strip(_dword(buff,j,";"))
       vl.c=word(vr.c,3)
       vr.c="shiptype"
      end /*if*/
     end /*do*/
     c=c+1
     vr.c="all"
     vl.c=buff

     /* set global vars */
     _qs.!corp=0
     do i=1 to c
      tag="!"||upper(vr.i)
      _qs.tag=vl.i
     end /*do*/

     /* pass out requested stats */
     rslt=""
     do i=1 to _dwords(args,";")
      found=0
      do j=1 to c
       if vr.j=_dword(args,i,";") then do
        rslt=rslt||";"||vl.j
        found=1
       end /*if*/
      end /*do*/
      if \found then rslt=rslt||";"||"##NA##"
     end /*do*/
     if rslt\="" then rslt=substr(rslt,2)

    return rslt

    /* _list_select v.2 */
    _list_select: procedure expose (globals)
     f=arg(1)
     a=arg(2)
     b=arg(3)
     if arg(4,"E") then d=arg(4); else d=";"
     if arg(5,"E") then rslt=arg(5); else rslt=""
     do i=1 to _dwords(a,d)
      if f=_dword(a,i,d) then do; rslt=_dword(b,i,d); leave; end
     end /*do*/
    return rslt

/** _get_info_i v.1 **/
    _get_info_i: procedure expose (globals)
     if arg(1,"E") then pmt=arg(1); else pmt=_synchronize()
     if arg(2,"E") then shiplist=arg(2); else shiplist=_iniv(!settings,"!shiplist")

     if \_listin(pmt,"command;citadel",";") then return "##UNDEF##"

     /* load ranks */
     if \_undef(_online.!reset) then do
      _online.="##UNDEF##"
      call _online_load_rank_names
     end /*if*/

     buflen=16*1024
     call zocreceivebuf buflen
     if _sendwait("i","<Info>")=640 then call _error "timeout"
     if _waitmux("Command [|Citadel command (")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"   ",d2c(0)||d2c(7)||d2c(10))
     if length(buff)=buflen then call _error "buffer overflow"
     cr=d2c(13)

     i=pos("Trader Name    : ",buff)
     if i=0 then name="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      name=substr(buff,i,j-i)
      parse value _online_split_rank_name(name) with rank ";" name
     end /*else*/

     i=pos("Rank and Exp   : ",buff)
     if i=0 then do; exp=0; aln=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value _stripcomma(substr(buff,i,j-i)) with exp " points Alignment=" aln " " .
     end /*else*/

     i=pos("Corp           # ",buff)
     if i=0 then do; corpnum=0; corpname="##UNDEF##"; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with corpnum ", " corpname .
     end /*else*/

     i=pos("Ship Name      : ",buff)
     if i=0 then shipname="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      shipname=substr(buff,i,j-i)
     end /*else*/

     i=pos("Ship Info      : ",buff)
     if i=0 then do; shiptype="##UNDEF##"; ported=0; kills=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with shiptype " Ported=" ported " Kills=" kills
      shiptype=_attack_strip_manufacturer(translate(shiptype,"____","|;=."), shiplist)
     end /*else*/

     i=pos("Date Built     : ",buff)
     if i=0 then datebuilt="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      datebuilt=substr(buff,i,j-i)
     end /*else*/

     i=pos("Turns to Warp  : ",buff)
     if i=0 then tpw=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      tpw=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Current Sector : ",buff)
     if i=0 then csec=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      csec=substr(buff,i,j-i)
     end /*else*/

     i=pos("Turns left     : ",buff)
     if i=0 then turns=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      turns=strip(substr(buff,i,j-i))
      if turns="Unlimited" then turns=0
     end /*else*/

     i=pos("Total Holds    : ",buff)
     if i=0 then do; holds=0; ore=0; org=0; equ=0; colos=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=substr(buff,i,j-i)
      parse var line holds .                ; if holds="" then holds=0
      parse var line . "Fuel Ore=" ore .    ; if ore=""   then ore=0
      parse var line . "Organics=" org .    ; if org=""   then org=0
      parse var line . "Equipment=" equ .   ; if equ=""   then equ=0
      parse var line . "Colonists=" colos . ; if colos="" then colos=0
     end /*else*/

     i=pos("Fighters       : ",buff)
     if i=0 then figs=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      figs=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     i=pos("Shield points  : ",buff)
     if i=0 then shields=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      shields=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     i=pos("Armid Mines  T1: ",buff)
     if i=0 then armids=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with armids .
     end /*else*/

     i=pos("Limpet Mines T2: ",buff)
     if i=0 then limpets=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      limpets=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Marker Beacons : ",buff)
     if i=0 then beacons=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      beacons=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Photon Missiles: ",buff)
     if i=0 then photons=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with photons .
     end /*else*/

     i=pos("Genesis Torps  : ",buff)
     if i=0 then gens=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      gens=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Atomic Detn.   : ",buff)
     if i=0 then adets=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with adets .
     end /*else*/

     i=pos("Corbomite Level: ",buff)
     if i=0 then corb=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      corb=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Cloaking Device: ",buff)
     if i=0 then cloaks=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with cloaks .
     end /*else*/

     i=pos("Ether Probes   : ",buff)
     if i=0 then probes=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      probes=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Mine Disruptors: ",buff)
     if i=0 then mdis=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      mdis=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Psychic Probe  : ",buff)
     if i=0 then pspr=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with line .
      pspr=(line="Yes")
     end /*else*/

     i=pos("Planet Scanner : ",buff)
     if i=0 then pscanner=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=strip(substr(buff,i,j-i))
      pscanner=(line="Yes")
     end /*else*/

     i=pos("LongRange Scan : ",buff)
     if i=0 then do; dens=0; holo=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=strip(substr(buff,i,j-i))
      holo=(line="Holographic Scanner")
      dens=(line="Density Scanner") | holo
     end /*else*/

     i=pos("  (Type 1 Jump): ",buff)
     if i=0 then t1j=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with t1j .
     end /*else*/

     i=pos("  (Type 2 Jump): ",buff)
     if i=0 then t2j=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with t2j .
     end /*else*/

     i=pos("Credits        : ",buff)
     if i=0 then creds=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      creds=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     rslt=name||";"||rank||";"||exp||";"||aln||";"||corpnum||";"||corpname||";"||shipnamae||";"||shiptype||";"||ported,
              ||";"||kills||";"||datebuilt||";"||tpw||";"||csec||";"||turns||";"||holds||";"||ore||";"||org,
              ||";"||equ||";"||colos||";"||figs||";"||shields||";"||armids||";"||limpets||";"||beacons,
              ||";"||photons||";"||gens||";"||adets||";"||corb||";"||cloaks||";"||probes||";"||mdis||";"||pspr,
              ||";"||pscanner||";"||dens||";"||holo||";"||t1j||";"||t2j||";"||creds
    return rslt
    /*
    1=name
    2=rank
    3=exp
    4=aln
    5=corpnum
    6-corpname
    7=shipname
    8=shiptype
    9=ported
    10=kills
    11=datebuild
    12=tpw
    13=csec
    14=turns
    15=holds
    16=ore
    17=org
    18=equ
    19=colos
    20=figs
    21=shields
    22=armids
    23=limpets
    24=beacons
    25=photons
    26=gens
    27=adets
    28=corb
    29=cloaks
    30=probes
    31=mdis
    32=psprobe
    33=pscanner
    34=dens
    35=holo
    36=t1j
    37=t2j
    38=creds
    */

    _iniv: procedure expose (globals)
     s=arg(1); v=arg(2)
     if arg(3,"E") then _ini.s.v=arg(3)
    return _ini.s.v

    _undef: procedure expose (globals)
     if arg(1)="##UNDEF##" then return 1; else return 0

/** _ping v.3 **/
    _ping: procedure expose (globals)
     if arg(1,"E") then n=arg(1); else n=5
     if arg(2,"E") then summary=arg(2); else summary=1
     if arg(3,"E") then mode=arg(3); else mode=1
     mn=999999999
     mx=0
     t=0
     select
      when mode=2 then do
       do n
        call time "R"
    /*    if _sendwait(d2c(145),d2c(145))=640 then call _error "timeout" */
        if _sendwait("/",d2c(179)||"Turns")=640 then call _error "timeout"
        e=time("E")
        if zocwait("Ship ")=640 then call _error "timeout"
        mn=min(mn,e)
        mx=max(mx,e)
        t=t+e
       end /*do*/
       avg=t/n*1000%1
       if summary then call zocsend "'ping : count="||n||" : min="||mn*1000%1||" : avg="||avg||" : max="||mx*1000%1||"^M"
      end /*when*/
      otherwise do
       if _sendwait("'^m","S:")=640 then call _error "timeout"
       do n
        call time "R"
        if _sendwait("ping","ping")=640 then call _error "timeout"
        e=time("E")
        mn=min(mn,e)
        mx=max(mx,e)
        t=t+e
        if _sendwait(" : "||trunc(e*1000)||" ms^m","S:")=640 then call _error "timeout"
       end /*do*/
       avg=t/n*1000%1
       if summary then call zocsend "ping : count="||n||" : min="||mn*1000%1||" : avg="||avg||" : max="||mx*1000%1||"^m^m"
                  else call zocsend "^M"
      end /*otherwise*/
     end /*select*/
    return avg

/** _mapseek v.4 **/
    _mapseek: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") | \arg(3,"E") then call _error "missing parameter in _mapseek"
     fname=arg(1)
     recordlen=arg(2)
     sector=arg(3)

     if _s.sector="_S."||sector then _s.=""
     if _s.sector="" then do

      call stream fname, "C", "SEEK "||(sector-1)*recordlen+2

      vis=0
      one=0
      prt=0
      pvis=0
      bore=0
      borg=0
      bequ=0
      flags=c2d(charin(fname))
      if flags%128=1 then do
       bequ=1
       flags=flags-128
      end /*if*/
      if flags%64=1 then do
       borg=1
       flags=flags-64
      end /*if*/
      if flags%32=1 then do
       bore=1
       flags=flags-32
      end /*if*/
      if flags%16=1 then do
       _pv.sector=1
       flags=flags-16
      end /*if*/
      if flags%8=1 then do
       prt=1
       flags=flags-8
      end /*if*/
      if flags%4=1 then flags=flags-4
      if flags%2=1 then do
       _od.sector=1
       flags=flags-2
      end /*if*/
      if flags%1=1 then do
       _sv.sector=1
       flags=flags-1
      end /*if*/

      if prt & _undef(_iniv(!port_kills,"!"||sector)) then do
       _p.sector=word("S B",bore+1)||word("S B",borg+1)||word("S B",bequ+1)
       _p.sector.!type=_p.sector
       do i=1 to 3
        ms1=charin(fname)
        ms2=charin(fname)
        ms3=charin(fname)
        quan=c2d(ms1)+c2d(ms2)*256; perc=c2d(ms3)
        _p.sector=_p.sector||";"||quan||","||perc
        x1=word("!pore !porg !pequ",i); x2=word("!qore !qorg !qequ",i)
        _p.sector.x1=perc; _p.sector.x2=quan
       end /*do*/
      end /*if*/
      else do
       _p.sector=""; _p.sector.!type=""
       _p.sector.!pore=0; _p.sector.!porg=0; _p.sector.!pequ=0
       _p.sector.!qore=0; _p.sector.!qorg=0; _p.sector.!qequ=0
       call stream fname, "C", "SEEK "||1+(sector-1)*recordlen+11
      end /*else*/
      _dtomsl.sector=c2d(charin(fname))
      _dfrmsl.sector=c2d(charin(fname))
      _bg.sector=c2d(charin(fname))+c2d(charin(fname))*256
      _nwi.sector=c2d(charin(fname))

      ms1=c2d(charin(fname))+c2d(charin(fname))*256
      if ms1=0 then _s.sector=""
      else do
       _s.sector=ms1
       _nw.sector=1
       wt=ms1%20000
       _s.sector.!num=ms1//20000
       _s.sector.!wt=wt
       _nwt.sector.wt=_nwt.sector.wt+1
       do i=1 to ((recordlen-15)%2-1)
        ms1=c2d(charin(fname))+c2d(charin(fname))*256
        if ms1>0 then do
         _s.sector=_s.sector ms1
         _nw.sector=_nw.sector+1
         wt=ms1%20000
         _s.sector.!num=_s.sector.!num ms1//20000
         _s.sector.!wt=_s.sector.!wt wt
         _nwt.sector.wt=_nwt.sector.wt+1
        end /*if*/
       end /*do*/
      end /*else*/

      _nwo.sector=_nwt.sector.1 + _nwt.sector.0
     end /*if*/
    return

/** _lastline v.3 **/
    _lastline: procedure expose (globals)
     rslt=zoclastline()
     select
      when lower(arg(1))="raw" then nop
      when pos(d2c(7),rslt)>0  then rslt=translate(zocstring("REMOVE", rslt, d2c(7)),"  ",d2c(0)||d2c(10))
      otherwise                     rslt=translate(rslt,"  ",d2c(0)||d2c(10))
     end /*select*/
    return rslt

/** _stripint v.4 **/
    _stripint: procedure expose (globals)
     mask=_space(translate(arg(1)," ","-0123456789,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripint"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if length(rslt)>9 then rslt=left(rslt,9)
      rslt=neg||rslt
     end /*else*/
    return rslt

/** _grabit v.2 **/
    _grabit: procedure expose (globals)
     if _wait(arg(1))=640 then call _error "timeout"
     rslt=_lastline()
     if lower(arg(2))="s" then rslt=reverse(substr(reverse(rslt),length(arg(1))+1))
    return rslt

/** _mapfind v.6 **/
    _mapfind: procedure expose (globals)
     start=arg(1)
     searchstring=arg(2)
     mapname=arg(3)
     recordlen=arg(4)
     maxdist=255; mindist=1
     select
      when arg(5,"E") & arg(6,"E") then do
       mindist=min(max(_stripint(arg(5)),1),255)
       maxdist=max(min(_stripint(arg(6)),255),1)
      end /*when*/
      when arg(6,"E") then maxdist=max(min(_stripint(arg(6)),255),1)
      when arg(5,"E") then maxdist=max(min(_stripint(arg(5)),255),1)
      otherwise nop
     end /*select*/
     if arg(7,"E") then useexclusions=arg(7); else useexclusions=1
     if arg(8,"E") then matchcount=arg(8); else matchcount=1

     usevoids=0
     reverse=0
     secnum=-1
     void=-1
     busted=-1
     figs=-1
     expl=-1
     list=-1
     pvis=-1
     deadend=-1
     bubble=-1
     tomsl=-1; frmsl=-1
     ptype=-1
     pore=-1;  porg=-1;  pequ=-1
     ppore=-1; pporg=-1; ppequ=-1
     viewed=-1
     /* parse search string */
     do i=1 to _dwords(searchstring,";")
      criteria=_dword(searchstring,i,";")
      tag=_dword(criteria,1,":")
      val=_dword(criteria,2,":")
      select
       when tag="mx"  then maxdist=val
       when tag="mn"  then mindist=val
       when tag="ue"  then useexclusions=val
       when tag="mc"  then matchcount=val
       when tag="r"   then reverse=val
       when tag="s"   then secnum=val
       when tag="uv"  then usevoids=val
       when tag="v"   then void=val
       when tag="f"   then figs=val
       when tag="e"   then expl=val
       when tag="sl"  then list=val
       when tag="pt"  then ptype=lower(val)
       when tag="p1"  then pore=val
       when tag="p2"  then porg=val
       when tag="p3"  then pequ=val
       when tag="pp1" then ppore=val
       when tag="pp2" then pporg=val
       when tag="pp3" then ppequ=val
       when tag="pv"  then pvis=val
       when tag="pb"  then busted=val
       when tag="d"   then deadend=val
       when tag="b"   then bubble=val
       when tag="tm"  then tomsl=val
       when tag="fm"  then frmsl=val
       when tag="vw"  then viewed=val
       when tag="nw"  then nw=val
       when tag="nwo" then nwo=val
       when tag="nw0" then nw0=val
       when tag="nw1" then nw1=val
       when tag="nw2" then nw2=val
       otherwise nop
      end /*select*/
     end /*do*/

     call _mapseek mapname, recordlen, start
     _dist.start.start=0
     _path.start.start=start

     /* initialize arrays */
     inqueue.=0
     queue.=""
     queue.1=start
     inqueue.start=1
     tail=1
     do i=1 to words(_s.start)
      code=word(_s.start,i)
      warptype=code%20000
      sector=code//20000
      if ((warptype<2 & \reverse) | (warptype>0 & reverse)) & (usevoids\=1 | \_v.sector) then do
       tail=tail+1
       queue.tail=sector
       inqueue.sector=1
      end /*if*/
     end /*do*/

     rslt=""
     current=start
     head=1
     found=0
     do while tail>=head

      /* have we found the destination? */
      select
       when _dist.start.current>maxdist & \reverse then do; found=0; leave; end
       when _dist.current.start>maxdist &  reverse then do; found=0; leave; end
       when found then do
        rslt=rslt current
        if words(rslt)=matchcount | head=tail then leave
        found=0
        head=head+1
       end /*when*/
       when head=tail then leave
       otherwise head=head+1
      end /*select*/

      current=queue.head
      call _mapseek mapname, recordlen, current

      do i=1 to words(_s.current)

       adjacent=word(_s.current.!num,i)
       warptype=word(_s.current.!wt,i)

       /* add to tail */
       if ((warptype<2 & \reverse) | (warptype>0 & reverse)) & (usevoids\=1 | \_v.adjacent) & \inqueue.adjacent then do
        tail=tail+1
        queue.tail=adjacent
        inqueue.adjacent=1
       end /*if*/

       /* assign shortest warp distance */
       if warptype>0 & \reverse then do
        tdist=_dist.start.current
        _dist.start.current=min(_dist.start.current,_dist.start.adjacent+1)
        if tdist>_dist.start.current then _path.start.current=_path.start.adjacent||";"||current
       end /*if*/

       if warptype<2 & reverse then do
        tdist=_dist.current.start
        _dist.current.start=min(_dist.current.start,_dist.adjacent.start+1)
        if tdist>_dist.current.start then _path.current.start=current||";"||_path.adjacent.start
       end /*if*/

      end /*do*/

      /* evaluate the criteria */
      found=1

      if _dist.start.current<mindist & \reverse then do; found=0; iterate; end
      if _dist.current.start<mindist &  reverse then do; found=0; iterate; end
      if useexclusions & _ex.current            then do; found=0; iterate; end
      if secnum\=-1  & secnum\=current          then do; found=0; iterate; end
      if void\=-1    & void=\_v.current         then do; found=0; iterate; end
      if figs\=-1    & figs=\_f.current         then do; found=0; iterate; end
      if expl\=-1    & expl=\_sv.current        then do; found=0; iterate; end
      if list\=-1    & list=\_sl.current        then do; found=0; iterate; end
      if pvis\=-1    & pvis=\_pv.current        then do; found=0; iterate; end
      if deadend\=-1 & deadend=\_od.current     then do; found=0; iterate; end

      bstamp=_iniv("!bust", "!"||current)
      if busted\=-1  & ((busted=1 & _undef(bstamp)) | (busted=0 & \_undef(bstamp))) then do; found=0; iterate; end

      if bubble\=-1 then do
       if bubble & _bg.current=0 then do; found=0; iterate; end
       if \bubble & _bg.current\=0 then do; found=0; iterate; end
      end /*if*/

      if viewed\=-1 then do
       select
        when left(viewed,2)="<=" & _vs.current>substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="<=" then nop
        when left(viewed,2)=">=" & _vs.current<substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)=">=" then nop
        when left(viewed,2)="\=" & _vs.current=substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="\=" then nop
        when left(viewed,2)="<>" & _vs.current=substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="<>" then nop
        when left(viewed,1)="<"  & _vs.current>=substr(viewed,2) then do; found=0; iterate; end
        when left(viewed,1)=">"  & _vs.current<=substr(viewed,2) then do; found=0; iterate; end
        when left(viewed,1)="="  & _vs.current\=substr(viewed,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if tomsl\=-1 then do
       select
        when left(tomsl,2)="<=" & _dtomsl.current>substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="<=" then nop
        when left(tomsl,2)=">=" & _dtomsl.current<substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)=">=" then nop
        when left(tomsl,2)="\=" & _dtomsl.current=substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="\=" then nop
        when left(tomsl,2)="<>" & _dtomsl.current=substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="<>" then nop
        when left(tomsl,1)="<"  & _dtomsl.current>=substr(tomsl,2) then do; found=0; iterate; end
        when left(tomsl,1)=">"  & _dtomsl.current<=substr(tomsl,2) then do; found=0; iterate; end
        when left(tomsl,1)="="  & _dtomsl.current\=substr(tomsl,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if frmsl\=-1 then do
       select
        when left(frmsl,2)="<=" & _dfrmsl.current>substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="<=" then nop
        when left(frmsl,2)=">=" & _dfrmsl.current<substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)=">=" then nop
        when left(frmsl,2)="\=" & _dfrmsl.current=substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="\=" then nop
        when left(frmsl,2)="<>" & _dfrmsl.current=substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="<>" then nop
        when left(frmsl,1)="<"  & _dfrmsl.current>=substr(frmsl,2) then do; found=0; iterate; end
        when left(frmsl,1)=">"  & _dfrmsl.current<=substr(frmsl,2) then do; found=0; iterate; end
        when left(frmsl,1)="="  & _dfrmsl.current\=substr(frmsl,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if (ptype\=-1 | pore\=-1 | porg\=-1 | pequ\=-1) then cptype=_dword(_p.current,1,";")

      if ptype\=-1 then do
       select
        when ptype=0 & cptype\="" then do; found=0; iterate; end
        when ptype=0 then nop
        when ptype=1 & cptype="" then do; found=0; iterate; end
        when ptype=1 then nop
        when \_portmatch(cptype,ptype) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if pore\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpore=_dword(_dword(_p.current,2,";"),1,",")
        select
         when left(pore,2)="<=" & cpore>substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="<=" then nop
         when left(pore,2)=">=" & cpore<substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)=">=" then nop
         when left(pore,2)="\=" & cpore=substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="\=" then nop
         when left(pore,2)="<>" & cpore=substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="<>" then nop
         when left(pore,1)="<"  & cpore>=substr(pore,2) then do; found=0; iterate; end
         when left(pore,1)=">"  & cpore<=substr(pore,2) then do; found=0; iterate; end
         when left(pore,1)="="  & cpore\=substr(pore,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if porg\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cporg=_dword(_dword(_p.current,3,";"),1,",")
        select
         when left(porg,2)="<=" & cporg>substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="<=" then nop
         when left(porg,2)=">=" & cporg<substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)=">=" then nop
         when left(porg,2)="\=" & cporg=substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="\=" then nop
         when left(porg,2)="<>" & cporg=substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="<>" then nop
         when left(porg,1)="<"  & cporg>=substr(porg,2) then do; found=0; iterate; end
         when left(porg,1)=">"  & cporg<=substr(porg,2) then do; found=0; iterate; end
         when left(porg,1)="="  & cporg\=substr(porg,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if pequ\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpequ=_dword(_dword(_p.current,4,";"),1,",")
        select
         when left(pequ,2)="<=" & cpequ>substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="<=" then nop
         when left(pequ,2)=">=" & cpequ<substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)=">=" then nop
         when left(pequ,2)="\=" & cpequ=substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="\=" then nop
         when left(pequ,2)="<>" & cpequ=substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="<>" then nop
         when left(pequ,1)="<"  & cpequ>=substr(pequ,2) then do; found=0; iterate; end
         when left(pequ,1)=">"  & cpequ<=substr(pequ,2) then do; found=0; iterate; end
         when left(pequ,1)="="  & cpequ\=substr(pequ,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if ppore\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cppore=_dword(_dword(_p.current,2,";"),2,",")
        select
         when left(ppore,2)="<=" & cppore>substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="<=" then nop
         when left(ppore,2)=">=" & cppore<substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)=">=" then nop
         when left(ppore,2)="\=" & cppore=substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="\=" then nop
         when left(ppore,2)="<>" & cppore=substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="<>" then nop
         when left(ppore,1)="<"  & cppore>=substr(ppore,2) then do; found=0; iterate; end
         when left(ppore,1)=">"  & cppore<=substr(ppore,2) then do; found=0; iterate; end
         when left(ppore,1)="="  & cppore\=substr(ppore,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if pporg\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpporg=_dword(_dword(_p.current,3,";"),2,",")
        select
         when left(pporg,2)="<=" & cpporg>substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="<=" then nop
         when left(pporg,2)=">=" & cpporg<substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)=">=" then nop
         when left(pporg,2)="\=" & cpporg=substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="\=" then nop
         when left(pporg,2)="<>" & cpporg=substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="<>" then nop
         when left(pporg,1)="<"  & cpporg>=substr(pporg,2) then do; found=0; iterate; end
         when left(pporg,1)=">"  & cpporg<=substr(pporg,2) then do; found=0; iterate; end
         when left(pporg,1)="="  & cpporg\=substr(pporg,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if ppequ\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cppequ=_dword(_dword(_p.current,4,";"),2,",")
        select
         when left(ppequ,2)="<=" & cppequ>substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="<=" then nop
         when left(ppequ,2)=">=" & cppequ<substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)=">=" then nop
         when left(ppequ,2)="\=" & cppequ=substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="\=" then nop
         when left(ppequ,2)="<>" & cppequ=substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="<>" then nop
         when left(ppequ,1)="<"  & cppequ>=substr(ppequ,2) then do; found=0; iterate; end
         when left(ppequ,1)=">"  & cppequ<=substr(ppequ,2) then do; found=0; iterate; end
         when left(ppequ,1)="="  & cppequ\=substr(ppequ,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if nw\=-1 then do
       select
        when left(nw,2)="<=" & _nw.current>substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="<=" then nop
        when left(nw,2)=">=" & _nw.current<substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)=">=" then nop
        when left(nw,2)="\=" & _nw.current=substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="\=" then nop
        when left(nw,2)="<>" & _nw.current=substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="<>" then nop
        when left(nw,1)="<"  & _nw.current>=substr(nw,2) then do; found=0; iterate; end
        when left(nw,1)=">"  & _nw.current<=substr(nw,2) then do; found=0; iterate; end
        when left(nw,1)="="  & _nw.current\=substr(nw,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nwo\=-1 then do
       select
        when left(nwo,2)="<=" & _nwo.current>substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="<=" then nop
        when left(nwo,2)=">=" & _nwo.current<substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)=">=" then nop
        when left(nwo,2)="\=" & _nwo.current=substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="\=" then nop
        when left(nwo,2)="<>" & _nwo.current=substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="<>" then nop
        when left(nwo,1)="<"  & _nwo.current>=substr(nwo,2) then do; found=0; iterate; end
        when left(nwo,1)=">"  & _nwo.current<=substr(nwo,2) then do; found=0; iterate; end
        when left(nwo,1)="="  & _nwo.current\=substr(nwo,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw0\=-1 then do
       select
        when left(nw0,2)="<=" & _nwt.current.0>substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="<=" then nop
        when left(nw0,2)=">=" & _nwt.current.0<substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)=">=" then nop
        when left(nw0,2)="\=" & _nwt.current.0=substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="\=" then nop
        when left(nw0,2)="<>" & _nwt.current.0=substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="<>" then nop
        when left(nw0,1)="<"  & _nwt.current.0>=substr(nw0,2) then do; found=0; iterate; end
        when left(nw0,1)=">"  & _nwt.current.0<=substr(nw0,2) then do; found=0; iterate; end
        when left(nw0,1)="="  & _nwt.current.0\=substr(nw0,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw1\=-1 then do
       select
        when left(nw1,2)="<=" & _nwt.current.1>substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="<=" then nop
        when left(nw1,2)=">=" & _nwt.current.1<substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)=">=" then nop
        when left(nw1,2)="\=" & _nwt.current.1=substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="\=" then nop
        when left(nw1,2)="<>" & _nwt.current.1=substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="<>" then nop
        when left(nw1,1)="<"  & _nwt.current.1>=substr(nw1,2) then do; found=0; iterate; end
        when left(nw1,1)=">"  & _nwt.current.1<=substr(nw1,2) then do; found=0; iterate; end
        when left(nw1,1)="="  & _nwt.current.1\=substr(nw1,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw2\=-1 then do
       select
        when left(nw2,2)="<=" & _nwt.current.2>substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="<=" then nop
        when left(nw2,2)=">=" & _nwt.current.2<substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)=">=" then nop
        when left(nw2,2)="\=" & _nwt.current.2=substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="\=" then nop
        when left(nw2,2)="<>" & _nwt.current.2=substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="<>" then nop
        when left(nw2,1)="<"  & _nwt.current.2>=substr(nw2,2) then do; found=0; iterate; end
        when left(nw2,1)=">"  & _nwt.current.2<=substr(nw2,2) then do; found=0; iterate; end
        when left(nw2,1)="="  & _nwt.current.2\=substr(nw2,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

     end /*do*/

     rslt=strip(rslt)
     if rslt="" then rslt=0

    return rslt

/** _twarp v.4 **/
    _twarp: procedure expose (globals)
     success=0
     sector=arg(1)
     cr=arg(2)

     if cr="" then call zocsend "m"||sector||"^M"
     else do
      if sector<cr then call zocsend sector||"^M"
      else call zocsend sector
     end /*else*/
     if _wait("<Move>")=640 then call _error "timeout"

     ans=_waitmux("Command [",
               ||"|(ADR) (Y/N)",
               ||"|Avoid this sector in the future? (Y/N)",
               ||"|already in that sector!",
               ||"|Engage the Autopilot?",
               ||"|engage the TransWarp drive?")
     select
      when ans=0 then do
       if _wait("(?=Help)?")=640 then call _error "timeout"
       parse value _lastline() with . "]:[" check "] (?=Help)?" .
       if check=sector then success=1
      end /*when*/
      when ans=1 then do /* twarping next door can hit figs */
       call zocsend "a999^M ^M ^M "
       if _wait("(?=Help)?")=640 then call _error "timeout"
       parse value _lastline() with . "]:[" check "] (?=Help)?" .
       if check=sector then success=1
      end /*when*/
      when ans=2 then do /* twarping next door can hit mines */
       call zocsend "^M ^M "
       if _wait("(?=Help)?")=640 then call _error "timeout"
       parse value _lastline() with . "]:[" check "] (?=Help)?" .
       if check=sector then success=1
      end /*when*/
      when ans=3 then nop
      when ans=4 then do
       call zocsend "n"
       if _wait("Command [")=640 then call _error "timeout"
       success=0
      end /*when*/
      when ans=5 then do
       call zocsend "y"
       ans2=_waitmux("not have enough Fuel Ore",
                  ||"|make this jump blind?",
                  ||"|shall we engage?")
       select
        when ans2=0 then if _wait("Command [")=640 then call _error "timeout"
        when ans2=1 then do
         call zocsend "n"
         if _wait("Command [")=640 then call _error "timeout"
        end /*when*/
        when ans2=2 then do
         call zocsend "y ^M za999^M ^M ^M "
         if _wait("Command [")=640 then call _error "timeout"
         success=1
        end /*when*/
        when ans2=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*when*/
      when ans=640 then call _error "timeout"
      otherwise nop
     end /*select*/

    return success

/** _bwarp v.1 **/
    _bwarp: procedure expose (globals)
     if arg(1,"E") then target=arg(1); else return 0
     if _sendwait("b"||target||"^m","Beam to what sector?")=640 then call _error "timeout"
     ans=_waitmux("order for one? (Y/N)|not have the range.|Fuel|blind?|to be avoided!|engage?")
     success=1
     select
      when ans=0 then success=0
      when ans=1 then success=0
      when ans=2 then success=0
      when ans=3 then do; call zocsend "n"; success=0; end;
      when ans=4 then do; call zocsend "n"; success=0; end;
      when ans=5 then call zocsend "y ^M za999^M ^M ^M "
      when ans=640 then call _error "timeout"
      otherwise nop
     end /*select*/
    return success

/** _debug v.5 **/
    _debug: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _debug"
     mode=strip(left(lower(arg(1)),3))
     msg=arg(2)
     if arg(3,"E") then logname=strip(arg(3))
     else logname="_debug.txt"
     select
      when mode="scr" then call zocwriteln "^[[1;34mREV-DEBUG <"||msg||">^[[0m"
      when mode="fed" then call zocsend "`REV-DEBUG <"||msg||">^M"
      when mode="sub" then call zocsend "'REV-DEBUG <"||msg||">^M"
      when mode="log" then do
       if _fileopenw(logname) then do
        call lineout logname, msg
        call _fileclose logname
       end /*if*/
       else call _error "unable to open rev-log.txt."
      end /*when*/
      otherwise nop
     end /*select*/
    return

/** _space v.1 **/
    _space: procedure expose (globals)
     str=strip(arg(1))
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then pad=arg(3); else pad=" "
     rslt=word(str,1)
     do i=2 to words(str)
      rslt=rslt||copies(pad,n)||word(str,i)
     end /*do*/
    return rslt

/** _cleanup v.1 **/
    _cleanup: procedure expose (globals)
     /* put code here to do custom cleanup
        for specific scripts and override
        it in your main program */
    return 1

/** _ansi v.3 **/
    _ansi: procedure expose (globals)
     rslt="0"
     pre=""
     do i=1 to _dwords(arg(1),";")
      w=_dword(arg(1),i,";")
      select
       when w="clearline" then pre=pre||"^[[100D^[[K"
       when w="dl"  then rslt=rslt||";"||0  /* dull               */
       when w="bt"  then rslt=rslt||";"||1  /* bright             */
       when w="ul"  then rslt=rslt||";"||4  /* underlined         */
       when w="blk" then rslt=rslt||";"||5  /* blinking           */
       when w="fbk" then rslt=rslt||";"||30 /* black foreground   */
       when w="frd" then rslt=rslt||";"||31 /* red foreground     */
       when w="fgr" then rslt=rslt||";"||32 /* green foreground   */
       when w="fye" then rslt=rslt||";"||33 /* yellow foreground  */
       when w="fbl" then rslt=rslt||";"||34 /* blue foreground    */
       when w="fmg" then rslt=rslt||";"||35 /* magenta foreground */
       when w="fcy" then rslt=rslt||";"||36 /* cyan foreground    */
       when w="fwh" then rslt=rslt||";"||37 /* white foreground   */
       when w="bbk" then rslt=rslt||";"||40 /* black background   */
       when w="brd" then rslt=rslt||";"||41 /* red background     */
       when w="bgr" then rslt=rslt||";"||42 /* green background   */
       when w="bye" then rslt=rslt||";"||43 /* yellow background  */
       when w="bbl" then rslt=rslt||";"||44 /* blue background    */
       when w="bmg" then rslt=rslt||";"||45 /* magenta background */
       when w="bcy" then rslt=rslt||";"||46 /* cyan background    */
       when w="bwh" then rslt=rslt||";"||47 /* white background   */
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=pre||"^[["||rslt||"m"
    return rslt

/** _beep v.2 **/
    _beep: procedure expose (globals)
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then d=arg(3); else d=0
     select
      when arg(1,"O") then call zocwrite copies(d2c(7),n)
      when _fileexists(arg(1)) then do
       do i=1 to n
        call zocplaysound arg(1)
        if i\=n & d>0 then call zocdelay d
       end /*do*/
      end /*when*/
      otherwise call zocwrite copies(d2c(7),n)
     end /*select*/
    return

/** _synchronize_vars v.1 **/
    _synchronize_vars: procedure expose (globals)
     select
      when arg(1)="w" then rslt="Pausing",
                              ||"|Command [",
                              ||"|Citadel command",
                              ||"|Planet command",
                              ||"|<StarDock>",
                              ||"|ship to sell",
                              ||"|Still interested ?",
                              ||"|wish to buy? (A,B,C,Q,?)",
                              ||"|<Galactic Bank>",
                              ||"|<Hardware Emporium>",
                              ||"|<Shipyards>",
                              ||"|<Tavern>",
                              ||"|Enter your choice [T] ?",
                              ||"|do you want to sell [",
                              ||"|do you want to buy [",
                              ||"|Computer command",
                              ||"|Corporate command",
                              ||"|Colonists? [T]",
                              ||"|Stop in this sector (Y,N,E,I,R,S,D,P,?) (?=Help) [N]",
                              ||"|`",
                              ||"|F: ",
                              ||"|'",
                              ||"|S: ",
                              ||"|M: ",
                              ||"|P: "
      when arg(1)="r" then rslt="unknown;command;citadel;planet;stardock;ship_sell;ship_sell_interested;class_0",
                             ||";bank;hardware;shipyards;tavern;port_menu;port_haggle;port_haggle;computer",
                             ||";corporate;terra;stop_in_this_sector?;fedcom_text_entry_1;fedcom_text_entry_2",
                             ||";subspace_text_entry_1;subspace_text_entry_2;mail_text_entry;private_text_entry",
                             ||";corporate_cit;computer_cit;unknown_text_entry" /* <-- these unmatched in the wait string above */
      when arg(1)="command" then rslt=" ; ;qq;q;q;qqq;nqq;q;qq;qq;qq;qq;q;0^Mz0^Mz0^M;0^Mz0^Mz0^M;q;q;q;y;^H;^M;^H;^M;^M;^M;qqq;qqq; "
      when arg(1)="computer" then rslt=" ;c;c;qc;qc;qqqc;nqqc;qc;qqc;qqc;qqc;qqc;qc;0^Mz0^Mz0^Mc;0^Mz0^Mz0^Mc; ;qc;qc;yc;^Hc;^Mc;^Hc;^Mc;^Mc;^Mc;qc;qc; "
      otherwise call _error "unknown argument in _synchronize_vars"
     end /*select*/
    return rslt

/** _get_log_path v.2 **/
    _get_log_path: procedure expose (globals)
     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then lpath = zocfilename("RESOLV", lpath)
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid path in _get_log_path"
    return lpath

/** _get_script_path v.1 **/
    _get_script_path: procedure expose (globals)
     parse value zocgetglobaloption("ScriptPath") with . '="' spath '"'
     if left(zocgetinfo("VERSION"),1)>4 then spath = zocfilename("RESOLV", spath)
     spath=dosfname(spath)
     if right(spath,1)\="\" then spath=spath||"\"
     if \dosisdir(spath) then call _error "invalid path in _get_script_path"
    return spath

/** _get_download_path v.2 **/
    _get_download_path: procedure expose (globals)
     parse value zocgetglobaloption("DownloadAltPath") with . '="' dpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then dpath = zocfilename("RESOLV", dpath)
     dpath=dosfname(dpath)
     if right(dpath,1)\="\" then dpath=dpath||"\"
     if \dosisdir(dpath) then call _error "invalid path in _get_download_path"
    return dpath

/** _setgame v.6 **/
    _setgame: procedure expose (globals)

     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then lpath = zocfilename("RESOLV", lpath)
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid log path in _setgame"

     if arg(1,"E") then gname=arg(1)
     else do
      list=_ini_list_games(lpath)
      if c=0 then gname="CLEAR"
      else gname=_drequestlist("select a game:", list||";CLEAR", ";", "c")
     end /*if*/
     if gname="CLEAR" | gname="" then do
      gname="%ZOCORHOST% %OPTIONS%"
      call zoclogging 0, 1
      call zoclogname "zoc_log_^3^2^1_^8.txt"
      call zocsetoption 'CaptDefaultName="zoc_log_^3^2^1_^8.txt"'
      call zoclogging 1, 1
     end/*if*/
     else do
      call zoclogging 0, 1
      call zoclogname gname||"_log_^3^2^1_^8.txt"
      call zocsetoption 'CaptDefaultName="'||gname||'_log_^3^2^1_^8.txt"'
      call zoclogging 1, 1
     end /*else*/
     call zocsetglobaloption 'WindowTitle="'||gname||'"'
    return gname

/** _fileopenr v.4 **/
    _fileopenr: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenr"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN READ"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

/** _fileeof v.4 **/
    _fileeof: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileeof"
      when arg(1)="" then rslt=0
      otherwise rslt=\lines(arg(1))
     end /*select*/
    return rslt

    _ini_is_section: procedure expose (globals)
     s=strip(arg(1))
     if left(s,1)="[" & left(reverse(s),1)="]" then return 1
    return 0

/** _ini_format_value **/
    _ini_format_value: procedure expose (globals)
     v=arg(1)
     if _dwords(v,"=")=2 then do
      t=lower(_dword(v,1,"="))
      v=_dword(v,2,"=")
      select
       when t="i" then v=_stripint(v)
       when t="f" then v=_stripnum(v)
       when t="b" then do; v=_stripint(v); if v>0 then v=1; else v=0; end
       when t="s" then nop
       otherwise nop
      end /*select*/
     end /*if*/
    return v

/** _fileclose v.3 **/
    _fileclose: procedure expose (globals)
     if \arg(1,"E") then call _error "missing argument in _fileclose"
     select
      when arg(1)="" then nop
      otherwise call stream arg(1), "C", "CLOSE"
     end /*select*/
    return

/** _figs_load v.1 **/
    _figs_load: procedure expose (globals)
     infile=arg(1)
     _f.=0
     c=0; n=1
     if _fileopenr(infile) then do
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||"loading figs from" infile "... "
      do while \_fileeof(infile)
       n=word(strip(linein(infile)),1)
       select
        when _stripint(n)\=n then nop
        when n<1 then nop
        otherwise do
         _f.n=1
         c=c+1
        end /*otherwise*/
       end /*select*/
      end /*do*/
      call _fileclose(infile)
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||c||" figs loaded. "
     end /*if*/
     rslt=c n
    return rslt

/** _figs_get v.2 **/
    _figs_get: procedure expose (globals)
     c1=0
     if arg(1,"E") then do
      fname=arg(1)
      parse value _figs_load(fname) with c1 m .
     end /*if*/
     _f.=0
     c=0 /* total count */
     cf=0 /* crp figs */
     pf=0 /* per figs */
     df=0 /* def figs */
     of=0 /* off figs */
     tf=0 /* tol figs */
     tot=0 /* amount */
     buflen=2048*1024
     call zocreceivebuf buflen
     call zocsend "g"
     if _wait("Deployed  Fighter  Scan")=640 then call _error "timeout"
     ans=0
     do while ans=0
      ans=_waitmux("r|Total|deployed")
     end /*do*/
     if ans=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)=buflen then call _error "buffer overflow"
     m=0; i=0; j=0
     i=pos(d2c(13),buff,pos("==",buff)+1)+1
     if i>1 then j=pos(d2c(13),buff,i)
     finish=pos("Total",buff,i)
     do while j>0 & j<finish
      line=strip(substr(buff,i,j-i))
      parse var line s1 amt type mode .
      if (type="Corp" | type="Personal") & _stripint(s1)=s1 then do
       amt=zocstring("REPLACE",amt,"T","000")
       amt=zocstring("REPLACE",amt,"M","000000")
       if datatype(amt,'N') then tot=tot+amt
       if (type="Personal") then pf=pf+1
       else cf=cf+1
       if (mode="Defensive") then df=df+1
       if (mode="Offensive") then of=of+1
       if (mode="Toll") then tf=tf+1
       _f.s1=1
       c=c+1
       m=max(m,s1)
      end /*if*/
      i=j+1
      j=pos(d2c(13),buff,i)
     end /*do*/
     if _verbose then call zocwrite _ansi("clearline;bt;fwh")||c||" figs read. "
     rslt=c m cf pf df of tf tot c-c1
    return rslt

/** _figs_save v.1 **/
    _figs_save: procedure expose (globals)
     outfile=arg(1)
     m=arg(2)
     c=0
     if outfile\="" then do
      if _filenew(outfile, "delete") then do
       if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||"saving figs to" outfile "... "
       do i=1 to m
        if _f.i then do
         c=c+1
         call lineout outfile, i
        end /*if*/
       end /*do*/
       call _fileclose(outfile)
       if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||c||" figs saved. "
      end /*if*/
     end /*if*/
    return c

/** _voids_load v.1 **/
    _voids_load: procedure expose (globals)
     infile=arg(1)
     _v.=0
     c=0; n=1
     if _fileopenr(infile) then do
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||"loading voids from" infile "... "
      do while \_fileeof(infile)
       n=word(strip(linein(infile)),1)
       select
        when _stripint(n)\=n then nop
        when n<1 then nop
        otherwise do
         _v.n=1
         c=c+1
        end /*otherwise*/
       end /*select*/
      end /*do*/
      call _fileclose(infile)
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||c||" voids loaded. "
     end /*if*/
     rslt=c n
    return rslt

/** _voids_get v.1 **/
    _voids_get: procedure expose (globals)
     _v.=0
     c=0
     buflen=32*1024
     call zocreceivebuf buflen
     if _sendwait("cx","<List Avoided Sectors>")=640 then call _error "timeout"
     if _wait("Computer command")=640 then call _error "timeout"
     call zocsend "q"
     if _waitmux("Command [|Citadel command")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"  ",d2c(10)||d2c(0))
     if length(buff)=buflen then call _error "buffer overflow"
     m=0; i=0; j=0
     i=pos("<List Avoided Sectors>",buff)
     i=pos(d2c(13),buff,i)+1
     i=pos(d2c(13),buff,i)+1
     j=pos(d2c(13),buff,i)
     do while j>0
      line=_space(substr(buff,i,j-i),1)
      if line="" then leave
      if line="No Sectors are currently being avoided." then leave
      do k=1 to words(line)
       s1=word(line,k)
       if _stripint(s1)=s1 then do
        _v.s1=1
        c=c+1
        m=max(m,s1)
       end /*if*/
      end /*do*/
      i=j+1
      j=pos(d2c(13),buff,i)
     end /*do*/
     if _verbose then call zocwrite _ansi("clearline;bt;fwh")||c||" voids read. "
     rslt=c m
    return rslt

/** _voids_save v.1 **/
    _voids_save: procedure expose (globals)
     outfile=arg(1)
     m=arg(2)
     c=0
     if outfile\="" then do
      if _filenew(outfile, "delete") then do
       if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||"saving voids to" outfile "... "
       do i=1 to m
        if _v.i then do
         c=c+1
         call lineout outfile, i
        end /*if*/
       end /*do*/
       call _fileclose(outfile)
       if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||c||" voids saved. "
      end /*if*/
     end /*if*/
    return c

/** _sendwait v.1 **/
    _sendwait: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _sendwait"
     call zocsend arg(1)
     rslt=_wait(arg(2))
     select
      when \arg(3,"E") | arg(3)=""             then nop
      when lower(arg(3))="timeout"  & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline" & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline"            then rslt=_lastline()
      otherwise nop
     end /*select*/
    return rslt

/** _stripcomma v.1 **/
    _stripcomma: procedure expose (globals)
     rslt=translate(_space(translate(arg(1),", "," ,"),0)," ",",")
    return rslt

/** _online_load_rank_names v.1 **/
    _online_load_rank_names: procedure expose (globals)
     _online.!red.0="12 10 7 8 9 11 22 13 1 2 3 15 4 5 6 14 21 17 18 19 20 16"
     _online.!red.1="Nuisance 3rd Class"
     _online.!red.2="Nuisance 2nd Class"
     _online.!red.3="Nuisance 1st Class"
     _online.!red.4="Menace 3rd Class"
     _online.!red.5="Menace 2nd Class"
     _online.!red.6="Menace 1st Class"
     _online.!red.7="Smuggler 3rd Class"
     _online.!red.8="Smuggler 2nd Class"
     _online.!red.9="Smuggler 1st Class"
     _online.!red.10="Smuggler Savant"
     _online.!red.11="Robber"
     _online.!red.12="Terrorist"
     _online.!red.13="Pirate"
     _online.!red.14="Infamous Pirate"
     _online.!red.15="Notorious Pirate"
     _online.!red.16="Dread Pirate"
     _online.!red.17="Galactic Scourge"
     _online.!red.18="Enemy of the State"
     _online.!red.19="Enemy of the People"
     _online.!red.20="Enemy of Humankind"
     _online.!red.21="Heinous Overlord"
     _online.!red.22="Prime Evil"

     _online.!blue.0="11 21 7 10 6 20 3 2 14 16 15 4 8 23 13 5 19 17 1 12 18 22 9"
     _online.!blue.1="Civilian"
     _online.!blue.2="Private"            /* match 2 */
     _online.!blue.3="Private 1st Class"  /* match 1 */
     _online.!blue.4="Lance Corporal"
     _online.!blue.5="Corporal"
     _online.!blue.6="Sergeant"           /* match 9 */
     _online.!blue.7="Staff Sergeant"
     _online.!blue.8="Gunnery Sergeant"
     _online.!blue.9="1st Sergeant"
     _online.!blue.10="Sergeant Major"     /* match 5 */
     _online.!blue.11="Warrant Officer"
     _online.!blue.12="Chief Warrant Officer"
     _online.!blue.13="Ensign"
     _online.!blue.14="Lieutenant J.G."      /* match 14 */
     _online.!blue.15="Lieutenant"           /* match 13,15 */
     _online.!blue.16="Lieutenant Commander" /* match 14 */
     _online.!blue.17="Commander"
     _online.!blue.18="Captain"
     _online.!blue.19="Commodore"
     _online.!blue.20="Rear Admiral"
     _online.!blue.21="Vice Admiral"
     _online.!blue.22="Admiral"
     _online.!blue.23="Fleet Admiral"
    return

    /*
    Nuisance 3rd Class
    Nuisance 2nd Class
    Nuisance 1st Class
    Menace 3rd Class
    Menace 2nd Class
    Menace 1st Class
    Smuggler 3rd Class
    Smuggler 2nd Class
    Smuggler 1st Class
    Smuggler Savant
    Robber
    Terrorist
    Pirate
    Infamous Pirate
    Notorious Pirate
    Dread Pirate
    Galactic Scourge
    Enemy of the State
    Enemy of the People
    Enemy of Humankind
    Heinous Overlord
    Prime Evil

    Private
    Private 1st Class
    Lance Corporal
    Corporal
    Sergeant
    Staff Sergeant
    Gunnery Sergeant
    1st Sergeant
    Sergeant Major
    Warrant Officer
    Chief Warrant Officer
    Ensign
    Lieutenant J.G.
    Lieutenant
    Lieutenant Commander
    Commander
    Captain
    Commodore
    Rear Admiral
    Vice Admiral
    Admiral
    Fleet Admiral
    */

    _online_split_rank_name: procedure expose (globals)
     line=arg(1)
     if \_undef(_online.!reset) then call _error "rankings list not loaded"
     do j=1 to 23
      k=word(_online.!blue.0,j)
      if left(line,length(_online.!blue.k))=_online.!blue.k then leave
     end /*do*/
     if j<24 then do
      rank=k-1
      name=substr(line,length(_online.!blue.k)+2)
     end /*if*/
     else do
      do j=1 to 22
       k=word(_online.!red.0,j)
       if left(line,length(_online.!red.k))=_online.!red.k then leave
      end /*do*/
      if j<23 then do
       rank=-k
       name=substr(line,length(_online.!red.k)+2)
      end /*if*/
      else do
       k=0
       rank=0
       name=line
      end /*else*/
     end /*else*/
     rslt=rank";"name
    return rslt

    _attack_strip_manufacturer: procedure expose (globals)
     line=arg(1)
     shiplist=arg(2)
     rslt=line
     do i=1 to _dwords(shiplist,";")
      n=reverse(_dword(shiplist,i,";"))
      if pos(n||" ",reverse(line))=1 then do
       rslt=reverse(n)
       leave
      end /*if*/
     end /*do*/
    return rslt

    _set_msg: procedure expose (globals)
     i=_msg.0
     if i="_MSG.0" then do; _msg.=""; _msg.0=0; i=0; end
     i=i+1; _msg.0=i; _msg=""
     if arg(1,"E") then do; _msg.i=arg(1); _msg=arg(1); end;
     if arg(2,"E") then _msg.i.!source=arg(2)
     if arg(3,"E") then _msg.i.!comment=arg(3)
    return i

/** _portmatch v.1 **/
    _portmatch: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _portmatch"
     m1=lower(strip(arg(1)))
     m2=lower(strip(arg(2)))
     rslt=0
     select
      when length(m1)\=3 then nop
      when length(m2)\=3 then nop
      when m1=m2 then rslt=1
      otherwise do
       mm1=0
       if left(m1,1)="x" then mm1=1
       if left(m2,1)="x" then mm1=1
       if left(m1,1)=left(m2,1) then mm1=1
       mm2=0
       if substr(m1,2,1)="x" then mm2=1
       if substr(m2,2,1)="x" then mm2=1
       if substr(m1,2,1)=substr(m2,2,1) then mm2=1
       mm3=0
       if substr(m1,3,1)="x" then mm3=1
       if substr(m2,3,1)="x" then mm3=1
       if substr(m1,3,1)=substr(m2,3,1) then mm3=1
       if mm1 & mm2 & mm3 then rslt=1
      end /*otherwise*/
     end /*select*/
    return rslt

/** _fileopenw v.3 **/
    _fileopenw: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenw"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN WRITE"
       call stream arg(1), "C", "SEEK <0"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

/** _fileexists v.4 **/
    _fileexists: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileexists"
      when arg(1)="" then rslt=0
      when stream(arg(1), "C", "QUERY EXISTS")="" then rslt=0
      otherwise rslt=1
     end /*select*/
    return rslt

/** _ini_list_games v.1 **/
    _ini_list_games: procedure expose (globals)
     lpath=arg(1)
     parse value zoclistfiles(lpath||"*_data.ini", ";") with c list
     if c=0 then rslt=""
     else do
      n=_dword(list,1,";")
      rslt=left(n,lastpos("_data.ini",n)-1)
      do i=2 to c
       n=_dword(list,i,";")
       rslt=rslt||";"||left(n,lastpos("_data.ini",n)-1)
      end /*do*/
     end /*else*/
    return rslt

/** _drequestlist v.3 **/
    _drequestlist: procedure expose (globals)
     i=zocrequestlist(arg(1),translate(arg(2),"|"||arg(3),arg(3)||"|"))
     select
      when i<0 & lower(arg(4))="c" then call _quit "script cancelled by user.", "nocopy"
      when i<0 then rslt="##CANCEL##"
      otherwise rslt=_dword(arg(2),i+1,arg(3))
     end /*select*/
    return rslt

/** _fileready v.2 **/
    _fileready: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileready"
      when arg(1)="" then rslt=0
      when stream(arg(1), "S")\="NOTREADY" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt

/** _filenew v.4 **/
    _filenew: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _filenew"
      when arg(1)="" then rslt=0
      otherwise do
       if arg(2,"E") & lower(arg(2))="delete" then call dosdel arg(1)
       if _fileexists(arg(1)) then rslt=0
       else do
        call stream arg(1), "C", "OPEN WRITE"
        rslt=_fileready(arg(1))
        if \rslt then call _fileclose arg(1)
       end /*else*/
      end /*otherwise*/
     end /*select*/
    return rslt

/** _stripnum v.3 **/
    _stripnum: procedure expose (globals)
     w=9
     mask=_space(translate(arg(1)," ","-0123456789.,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripnum"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if left(rslt,1)="." then rslt="0"||rslt
      r=_dword(rslt,1,".")
      m=_dword(rslt,2,".")
      select
       when r=0 & length(m)>w then m=left(m,w)
       when length(r)>w then do; r=left(r,w); m=""; end
       when length(r)=w then m=""
       when length(m)>(w-length(r)) then m=left(m,w-length(r))
       otherwise nop
      end /*select*/
      if m="" then rslt=neg||r; else rstl=neg||r||"."||m
     end /*else*/
    return rslt

/** _quit v.7 **/
    _quit: procedure expose (globals)
     lcpy=1
     arg1=""
     do i=1 to 2 /* manage arguments */
      select
       when arg(i,"E") & lower(arg(i))="nocopy" then lcpy=0
       when arg(i,"E") & arg1="" then arg1=arg(i)
       otherwise nop
      end /*select*/
     end /*do*/
     line=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
     select /* define message */
      when  lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m^M^J"||line
      when \lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m "
      when  lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m^M^J"||line
      when \lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m "
      otherwise nop
     end /*select*/
     call zocwrite msg
     select /* choose a beep */
      when lower(arg1)="script cancelled by user." then call _beep "cancel.wav"
      otherwise call _beep "quit.wav"
     end /*select*/
     exit
    return 1
