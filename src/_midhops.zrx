/* REXX _midhops.zrx by the reverend (build 14)                               */
/*-       built by rev-builder version 1.3a on 22 Mar 2014 at 00:15:33       -*/
/*- ------------------------------------------------------------------------ -*/
/*- This script is free, and can be modified for your personal use, but you  -*/
/*- cannot copy or distribute this script or any derivative work based upon  -*/
/*- this script without the express permission of the author.                -*/
/*-                                                                          -*/
/*- This script is provided to you WITHOUT ANY WARRANTY, even the implied    -*/
/*- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         -*/
/*-                                                                          -*/
/*-                       Copyright (C) 2009 Ron Wilson                      -*/
/*- ------------------------------------------------------------------------ -*/
/*- ---------------------*/ _g.!sname="_midhops.zrx" /*--------------------- -*/
/*- --------------*/ _g.!sbuild=14; _g.!sdate="2014-03-22" /*--------------- -*/
/*- ------------------------------------------------------------------------ -*/
/* rev. 0 - initial release                                                   */

globals=_setglobals()
call _timeout 60
call zocsynctime 500
call on halt name _halt
_verbose=1

/* load ini variables */
   load="sd ns pname fname vname lname vwname mname gname spath lpath"
   sl=_ini_load_settings()
   do i=1 to _dwords(sl,";")
    s=_dword(sl,i,";")
    globals=globals||" !"||s
    interpret '!'||s||'="!"||s'
   end;
   f=0; l=""
   do i=1 to words(load)
    s=word(load,i)
    x="!"||s
    interpret s||"=_ini.!settings.x"
    interpret 'if '||s||'="##UNDEF##" then do; l=l s; f=1; end'
   end; if f then call _error "missing config variable(s):"||l; drop load s sl x f l

pmt=_synchronize()
istats=_get_info_i(pmt)
aln=_dword(istats,4,";")
tpw=_dword(istats,12,";")
csec=_dword(istats,13,";")
holds=_dword(istats,15,";")
ore=_dword(istats,16,";")
creds=_dword(istats,38,";")

csec=_askint("FROM?",csec,"c")
target=_askint("TO?",0,"c")
if target<1 then exit
towing=_yesno("are you towing?")

reclen=_mapinit(mname)
call _figs_load fname
call zocsend "'"||_g.!sname1||" : build "||_g.!sbuild||" : "||csec||"->"||target"^M"

c=0; mid.=0
do forever
 if towing then range=ore%6; else range=ore%3
 call _mapdist csec, target, mname, reclen, 0, 255
 dist=_dist.csec.target
 path=_path.csec.target
 _ex.=0; do i=1 to _dwords(path,";"); s=_dword(path,i,";"); _ex.s=1; end
 if dist<=range then leave
 c=c+1
 do i=range+1 to 2 by -1
  s=_dword(path,i,";")
  if _f.s & left(_p.s.!type,1)="S" then do; mid.c=s; leave; end
  if i<range & i>3 then do
   op=_mapfind(s,"f:1;pt:sxx",mname,reclen,1,2)
   if op>0 then do; mid.c=op; leave; end
  end /*if*/
 end /*do*/
 if mid.c=0 then leave
 csec=mid.c
 ore=holds
end /*do*/
if mid.c>0 & aln<1000 & (target=sd | target<11) then do
 c=c+1
 mid.c=_mapfind(target,"f:1;r:1",mname,reclen,1,1)
end /*if*/
list=""; do i=1 to c; list=list mid.i; end
list=strip(list)
if mid.c>0 & mid.c\=target then list=list target
call zocsend "'try this path:" list "^M"

exit

/***                 THE REVEREND'S TW LIBRARY FOR ZOC/REXX                 ***/

/** _setglobals v.5 **/
    _setglobals: procedure expose _verbose _monthdays _monthnames _baseday. _g. _msg. _debug (globals)

     _debug=0
     _verbose=0
     _msg.=""; _msg.0=0
     _monthdays="31;28;31;30;31;30;31;31;30;31;30;31"
     _monthnames="jan;feb;mar;apr;may;jun;jul;aug;sep;oct;nov;dec"
     _baseday.2000=730118 + 1 /* +1 added 6/23/2008 */
     _baseday.2001=_baseday.2000+365+1
     _baseday.2002=_baseday.2001+365
     _baseday.2003=_baseday.2002+365
     _baseday.2004=_baseday.2003+365
     _baseday.2005=_baseday.2004+365+1
     _baseday.2006=_baseday.2005+365
     _baseday.2007=_baseday.2006+365
     _baseday.2008=_baseday.2007+365
     _baseday.2009=_baseday.2008+365+1
     _baseday.2010=_baseday.2009+365
     _baseday.2011=_baseday.2010+365
     _baseday.2012=_baseday.2011+365
     _baseday.2013=_baseday.2012+365+1
     _baseday.2014=_baseday.2013+365
     _baseday.2015=_baseday.2014+365
     _baseday.2016=_baseday.2015+365
     _baseday.2017=_baseday.2016+365+1
     _baseday.2018=_baseday.2013+365
     _baseday.2019=_baseday.2014+365
     _baseday.2020=_baseday.2015+365
     _baseday.2021=_baseday.2016+365+1
     _baseday.2022=_baseday.2013+365
     _baseday.2023=_baseday.2014+365
     _baseday.2024=_baseday.2015+365
     _baseday.2025=_baseday.2016+365+1
     _baseday.2026=_baseday.2013+365
     _baseday.2027=_baseday.2014+365
     _baseday.2028=_baseday.2015+365
     _baseday.2029=_baseday.2016+365+1
     _baseday.2030=_baseday.2013+365
     _baseday.2031=_baseday.2014+365
     _baseday.2032=_baseday.2015+365
     _baseday.2033=_baseday.2016+365+1

     i=lastpos(".",_g.!sname)
     if i=0 then _g.!sname1=_g.!sname
            else _g.!sname1=left(_g.!sname,i-1)

     rslt="_g. _ini. _s. _p. _d. _v. _f. _m. _l. _q. _sl. _ex. _qs. "
     rslt=rslt||"_ef. _efc. _es. _et. _ep. _fc. "
     rslt=rslt||"_path. _dist. _dtomsl. _dfrmsl. "
     rslt=rslt||"_bg. _bd. _nwi. _nwo. _nw. _nwt. _od. _sv. _pv. _vs. _vn. _vi. _mcic. _fh. _fhp. "
     rslt=rslt||"_clv. _online. _msg _msg. _debug "
     rslt=rslt||"_verbose _monthdays _monthnames _baseday. "
     rslt=rslt||"globals "
     if arg(1,"E") then rslt=rslt||arg(1)

     rslt=_space(rslt)
    return rslt

/** _timeout v.1 **/
    _timeout: procedure expose (globals)
     if _g.!timeout="_G.!TIMEOUT" then _g.!timeout=60
     rslt=_g.!timeout
     nt=_stripint(arg(1))
     if arg(1,"E") & nt>0 then do
      call zoctimeout nt
      _g.!timeout=nt
     end /*if*/
    return rslt

/** _halt v.4 **/
    _halt: procedure expose (globals)
     call off halt
     call _cleanup
     call zocwriteln "^[[1;33m< user abort >^[[0m "
     exit
    return

/** _ini_load_settings v.1 **/
    _ini_load_settings: procedure expose (globals)

     parse value zocgetoption("CaptDefaultName") with . '="' ldefault '"'
     if left(zocgetinfo("VERSION"),1)>4 then ldefault = zocfilename("RESOLV", ldefault)
     parse value zocgetglobaloption("WindowTitle") with . '="' gname '"'

     lpath=_get_log_path()
     spath=_get_script_path()
     dpath=_get_download_path()

     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then gname=_setgame()
     if gname="" | gname="%ZOCORHOST% %OPTIONS%" then exit
     dname=dosfname(lpath||gname||"_data.ini")

     _ini.="##UNDEF##"

     sectionlist=""
     if _fileopenr(dname) then do
      insection=0
      do while \_fileeof(dname)
       line=strip(linein(dname))
       if _ini_is_section(line) then do
        insection=1
        parse var line "[" section "]"
        section=strip(section)
        if sectionlist="" then sectionlist=section; else sectionlist=sectionlist||";"||section
       end /*if*/
       else do
        if insection then do
         parse var line k "=" v
         v=_ini_format_value(v)
         k="!"||section||".!"||strip(k)
         if k\="!"||section||".!" then _ini.k=strip(v)
        end /*if*/
       end /*else*/
      end /*while*/
      call _fileclose dname
     end /*if*/

     call _iniv "!settings", "!ldefault", ldefault
     call _iniv "!settings", "!lpath",  lpath
     call _iniv "!settings", "!spath",  spath
     call _iniv "!settings", "!dpath",  dpath
     call _iniv "!settings", "!dname",  dname
     call _iniv "!settings", "!gname",  gname
     call _iniv "!settings", "!lname",  lpath||gname||"_log.txt"
     call _iniv "!settings", "!fname",  lpath||gname||"_figs.txt"
     call _iniv "!settings", "!vname",  lpath||gname||"_voids.txt"
     call _iniv "!settings", "!vwname", lpath||gname||"_view.txt"
     call _iniv "!settings", "!pname",  lpath||gname||".prt"
     call _iniv "!settings", "!sname",  lpath||gname||".sct"
     call _iniv "!settings", "!rpname", lpath||gname||"_ref.prt"
     call _iniv "!settings", "!rsname", lpath||gname||"_ref.sct"
     call _iniv "!settings", "!mname",  lpath||gname||".map"
     call _iniv "!settings", "!zname",  lpath||gname||".ztm"
     call _iniv "!settings", "!nfname", lpath||gname||"_nearfig.txt"

    return sectionlist

/** _dwords v.2 **/
    _dwords: procedure expose (globals)
     rslt=words(translate(arg(1),arg(2)||" "," "||arg(2)))
    return rslt

/** _dword v.2 **/
    _dword: procedure expose (globals)
     rslt=translate(word(translate(arg(1),arg(3)||" "," "||arg(3)),arg(2))," "||arg(3),arg(3)||" ")
    return rslt

/** _error v.9 **/
    _error: procedure expose (globals)
     call off halt
     call _cleanup
     call zocwrite _ansi("clearline;bt;frd")||"< script error ("||_g.!sname||" b."||_g.!sbuild||")"
     if arg(1,"E") then call zocwrite " : "||arg(1)
     call zocwriteln " >"
     call zocwriteln _ansi("bt;fye")||"< if this is a serious problem, email me at: revhelper_at_thereverend_dot_org > "
     call zocwriteln "< SCRIPT "||_g.!sname||", BUILD "||_g.!sbuild||", DATE "||_g.!sdate||" > "
     call zocwriteln "< ZOC VERSION '"||zocgetinfo("VERSION")||"', OS '"||zocgetinfo("OSYS")||"', LOCATION '"||zocgetinfo("CONNECTEDTO")||"' >"
     if arg(2,"E") then call zocwriteln _ansi("bt;fgr")||"< "||arg(2)||" >"
     call _beep "error.wav"
    exit

/** _synchronize v.5 **/
    _synchronize: procedure expose (globals)

     if arg(1,"E") then checkcitprompts=arg(1); else checkcitprompts=1

     synchw=_synchronize_vars("w")
     synchr=_synchronize_vars("r")

     call zocsend "&&"
     ans=_waitmux("&&|Pausing is")
     select
      when ans=0 then return "unknown_text_entry"
      when ans=1 then nop
      when ans=640 then return "timeout"
      otherwise nop
     end /*select*/

     ans=_waitmux(synchw)
     select
      when ans=640 then rslt="timeout"
      when ans>0 then do
       if _wait("Pausing is")=640 then call _error "timeout"
      end /*when*/
      otherwise nop
     end /*select*/
     rslt=_dword(synchr,ans+1,";")

     select
      when \checkcitprompts then nop
      when rslt="computer" then do
       call zocsend "q"
       ans=_waitmux("Command [|Citadel command")
       select
        when ans=0 then nop
        when ans=1 then rslt="computer_cit"
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
       call zocsend "c"
      end /*when*/
      when rslt="corporate" then do
       call zocsend "q"
       ans=_waitmux("Command [|Citadel command")
       select
        when ans=0 then call zocsend "t"
        when ans=1 then do
         rslt="corporate_cit"
         call zocsend "x"
        end /*when*/
        when ans=640 then call _error "timeout"
        otherwise nop
       end /*select*/
      end /*when*/
      otherwise nop
     end /*select*/

    return rslt

/** _get_info_i v.1 **/
    _get_info_i: procedure expose (globals)
     if arg(1,"E") then pmt=arg(1); else pmt=_synchronize()
     if arg(2,"E") then shiplist=arg(2); else shiplist=_iniv(!settings,"!shiplist")

     if \_listin(pmt,"command;citadel",";") then return "##UNDEF##"

     /* load ranks */
     if \_undef(_online.!reset) then do
      _online.="##UNDEF##"
      call _online_load_rank_names
     end /*if*/

     buflen=16*1024
     call zocreceivebuf buflen
     if _sendwait("i","<Info>")=640 then call _error "timeout"
     if _waitmux("Command [|Citadel command (")=640 then call _error "timeout"
     buff=translate(zocreceivebuf(0),"   ",d2c(0)||d2c(7)||d2c(10))
     if length(buff)=buflen then call _error "buffer overflow"
     cr=d2c(13)

     i=pos("Trader Name    : ",buff)
     if i=0 then name="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      name=substr(buff,i,j-i)
      parse value _online_split_rank_name(name) with rank ";" name
     end /*else*/

     i=pos("Rank and Exp   : ",buff)
     if i=0 then do; exp=0; aln=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value _stripcomma(substr(buff,i,j-i)) with exp " points Alignment=" aln " " .
     end /*else*/

     i=pos("Corp           # ",buff)
     if i=0 then do; corpnum=0; corpname="##UNDEF##"; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with corpnum ", " corpname .
     end /*else*/

     i=pos("Ship Name      : ",buff)
     if i=0 then shipname="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      shipname=substr(buff,i,j-i)
     end /*else*/

     i=pos("Ship Info      : ",buff)
     if i=0 then do; shiptype="##UNDEF##"; ported=0; kills=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with shiptype " Ported=" ported " Kills=" kills
      shiptype=_attack_strip_manufacturer(translate(shiptype,"____","|;=."), shiplist)
     end /*else*/

     i=pos("Date Built     : ",buff)
     if i=0 then datebuilt="##UNDEF##"
     else do
      i=i+17
      j=pos(cr,buff,i)
      datebuilt=substr(buff,i,j-i)
     end /*else*/

     i=pos("Turns to Warp  : ",buff)
     if i=0 then tpw=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      tpw=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Current Sector : ",buff)
     if i=0 then csec=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      csec=substr(buff,i,j-i)
     end /*else*/

     i=pos("Turns left     : ",buff)
     if i=0 then turns=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      turns=strip(substr(buff,i,j-i))
      if turns="Unlimited" then turns=0
     end /*else*/

     i=pos("Total Holds    : ",buff)
     if i=0 then do; holds=0; ore=0; org=0; equ=0; colos=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=substr(buff,i,j-i)
      parse var line holds .                ; if holds="" then holds=0
      parse var line . "Fuel Ore=" ore .    ; if ore=""   then ore=0
      parse var line . "Organics=" org .    ; if org=""   then org=0
      parse var line . "Equipment=" equ .   ; if equ=""   then equ=0
      parse var line . "Colonists=" colos . ; if colos="" then colos=0
     end /*else*/

     i=pos("Fighters       : ",buff)
     if i=0 then figs=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      figs=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     i=pos("Shield points  : ",buff)
     if i=0 then shields=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      shields=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     i=pos("Armid Mines  T1: ",buff)
     if i=0 then armids=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with armids .
     end /*else*/

     i=pos("Limpet Mines T2: ",buff)
     if i=0 then limpets=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      limpets=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Marker Beacons : ",buff)
     if i=0 then beacons=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      beacons=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Photon Missiles: ",buff)
     if i=0 then photons=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with photons .
     end /*else*/

     i=pos("Genesis Torps  : ",buff)
     if i=0 then gens=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      gens=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Atomic Detn.   : ",buff)
     if i=0 then adets=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with adets .
     end /*else*/

     i=pos("Corbomite Level: ",buff)
     if i=0 then corb=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      corb=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Cloaking Device: ",buff)
     if i=0 then cloaks=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with cloaks .
     end /*else*/

     i=pos("Ether Probes   : ",buff)
     if i=0 then probes=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      probes=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Mine Disruptors: ",buff)
     if i=0 then mdis=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      mdis=strip(substr(buff,i,j-i))
     end /*else*/

     i=pos("Psychic Probe  : ",buff)
     if i=0 then pspr=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with line .
      pspr=(line="Yes")
     end /*else*/

     i=pos("Planet Scanner : ",buff)
     if i=0 then pscanner=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=strip(substr(buff,i,j-i))
      pscanner=(line="Yes")
     end /*else*/

     i=pos("LongRange Scan : ",buff)
     if i=0 then do; dens=0; holo=0; end
     else do
      i=i+17
      j=pos(cr,buff,i)
      line=strip(substr(buff,i,j-i))
      holo=(line="Holographic Scanner")
      dens=(line="Density Scanner") | holo
     end /*else*/

     i=pos("  (Type 1 Jump): ",buff)
     if i=0 then t1j=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with t1j .
     end /*else*/

     i=pos("  (Type 2 Jump): ",buff)
     if i=0 then t2j=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      parse value substr(buff,i,j-i) with t2j .
     end /*else*/

     i=pos("Credits        : ",buff)
     if i=0 then creds=0
     else do
      i=i+17
      j=pos(cr,buff,i)
      creds=_stripcomma(strip(substr(buff,i,j-i)))
     end /*else*/

     rslt=name||";"||rank||";"||exp||";"||aln||";"||corpnum||";"||corpname||";"||shipnamae||";"||shiptype||";"||ported,
              ||";"||kills||";"||datebuilt||";"||tpw||";"||csec||";"||turns||";"||holds||";"||ore||";"||org,
              ||";"||equ||";"||colos||";"||figs||";"||shields||";"||armids||";"||limpets||";"||beacons,
              ||";"||photons||";"||gens||";"||adets||";"||corb||";"||cloaks||";"||probes||";"||mdis||";"||pspr,
              ||";"||pscanner||";"||dens||";"||holo||";"||t1j||";"||t2j||";"||creds
    return rslt
    /*
    1=name
    2=rank
    3=exp
    4=aln
    5=corpnum
    6-corpname
    7=shipname
    8=shiptype
    9=ported
    10=kills
    11=datebuild
    12=tpw
    13=csec
    14=turns
    15=holds
    16=ore
    17=org
    18=equ
    19=colos
    20=figs
    21=shields
    22=armids
    23=limpets
    24=beacons
    25=photons
    26=gens
    27=adets
    28=corb
    29=cloaks
    30=probes
    31=mdis
    32=psprobe
    33=pscanner
    34=dens
    35=holo
    36=t1j
    37=t2j
    38=creds
    */

/** _askint v.2 **/
    _askint: procedure expose (globals)
     do i=1 to 3
      select
       when i=1 & arg(i,"E") then msg=arg(i)
       when i=1              then msg="enter an integer:"
       when i=2 & arg(i,"E") then default=arg(i)
       when i=2              then default=""
       when i=3 & arg(i,"E") then cflag=min(verify(lower(arg(i)),"c","M"),1)
       when i=3              then cflag=0
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=strip(zocask(msg, default))
     do while _stripint(rslt)\=rslt | rslt=""
      default=rslt||" [please enter an integer or ESC to cancel.]"
      if rslt="##CANCEL##" then leave
      else rslt=strip(zocask(msg, default))
     end /*do*/
     if cflag & rslt="##CANCEL##" then call _quit "script cancelled by user.", "nocopy"
    return rslt

/** _yesno v.3 **/
    _yesno: procedure expose (globals)
     if arg(1,"E") then msg=arg(1)
     else msg="yes or no"
     if arg(2)="yn" then rslt=zocrequest(msg||" (ESC=no)", "yes", "no")
                    else rslt=zocrequest(msg, "yes", "no", "cancel")
     select
      when rslt="cancel" then call _quit "script cancelled by user.", "nocopy"
      when rslt="##CANCEL##" & arg(2)\="yn" then call _quit "script cancelled by user.", "nocopy"
      when rslt="yes" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt

/** _mapinit v.5 **/
    _mapinit: procedure expose (globals)
     fname=arg(1)
     if arg(2,"E") then m=arg(2); else m=0
     select
      when m=0 then nop
      when m=1 then drop _p. _s. _dist. _path. _dtomsl. _dfrmsl. _bg. _bd. _nwt. _nwi. _nwo. _nw. _od. _sv. _pv.
      otherwise nop
     end /*select*/
     if _f.0="_F.0" then _f.=0
     if _l.0="_L.0" then _l.=0
     if _m.0="_M.0" then _m.=0
     if _s.0="_S.0" then _s.=""
     if _p.0="_P.0" then _p.=""
     if _dist.0.0="_DIST.0.0" then _dist.=255
     if _path.0.0="_PATH.0.0" then _path.=""
     if _dtomsl.0="_DTOMSL.0" then _dtomsl.=255
     if _dfrmsl.0="_DFRMSL.0" then _dfrmsl.=255
     if _bg.0="_BG.0" then _bg.=0
     if _bd.0="_BD.0" then _bd.=0 /* bubble door, results from _mapbubbles */
     if _nwt.0="_NWT.0" then _nwt.=0
     if _nwi.0="_NWI.0" then _nwi.=0
     if _nwo.0="_NWO.0" then _nwo.=0
     if _nw.0="_NW.0" then _nw.=0
     if _od.0="_OD.0" then _od.=0
     if _sv.0="_SV.0" then _sv.=0
     if _pv.0="_PV.0" then _pv.=0
     if _sl.0="_SL.0" then _sl.=0
     if _ex.0="_EX.0" then _ex.=0
     if _v.0="_V.0" then _v.=0
     if _vs.0="_VS.0" then _vs.=0
     if _vn.0="_VN.0" then _vn.="(na)"
     if \_fileopenr(fname) then call _error "unable to open map file: "||fname
     recordlen=c2d(charin(fname))
    return recordlen

/** _figs_load v.1 **/
    _figs_load: procedure expose (globals)
     infile=arg(1)
     _f.=0
     c=0; n=1
     if _fileopenr(infile) then do
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||"loading figs from" infile "... "
      do while \_fileeof(infile)
       n=word(strip(linein(infile)),1)
       select
        when _stripint(n)\=n then nop
        when n<1 then nop
        otherwise do
         _f.n=1
         c=c+1
        end /*otherwise*/
       end /*select*/
      end /*do*/
      call _fileclose(infile)
      if _verbose then call zocwriteln _ansi("clearline;bt;fwh")||c||" figs loaded. "
     end /*if*/
     rslt=c n
    return rslt

/** _mapdist v.2 **/
    _mapdist: procedure expose (globals)
     start=arg(1)
     finish=arg(2)
     mapname=arg(3)
     recordlen=arg(4)
     reverse=arg(5)
     if reverse="" then reverse=0
     maxdist=arg(6)
     if maxdist="" | maxdist<1 then maxdist=255

     call _mapseek mapname, recordlen, start
     _dist.start.start=0
     _path.start.start=start

     /* initialize arrays */
     inqueue.=0
     queue.=""
     queue.1=start
     inqueue.start=1
     tail=1
     do i=1 to words(_s.start)
      code=word(_s.start,i)
      warptype=code%20000
      sector=code//20000
      if (warptype<2 & \reverse) | (warptype>0 & reverse) then do
       tail=tail+1
       queue.tail=sector
       inqueue.sector=1
      end /*if*/
     end /*do*/
     head=2

     done=0
     do while \done & tail>=head

      current=queue.head
      call _mapseek mapname, recordlen, current

      do i=1 to words(_s.current)

       code=word(_s.current,i)
       warptype=code%20000
       adjacent=code//20000

       /* if adjacent not in queue, then add to tail */
       if ((warptype<2 & \reverse) | (warptype>0 & reverse)) & \inqueue.adjacent then do
        tail=tail+1
        queue.tail=adjacent
        inqueue.adjacent=1
       end /*if*/

       /* assign shortest warp distance */
       if warptype>0 & \reverse then do
        tdist=_dist.start.current
        _dist.start.current=min(_dist.start.current,_dist.start.adjacent+1)
        if tdist>_dist.start.current then _path.start.current=_path.start.adjacent||";"||current
       end /*if*/

       if warptype<2 & reverse then do
        tdist=_dist.current.start
        _dist.current.start=min(_dist.current.start,_dist.adjacent.start+1)
        if tdist>_dist.current.start then _path.current.start=current||";"||_path.adjacent.start
       end /*if*/

      end /*do*/

      /* have we found the destination? */
      select
       when current=finish then done=1
       when _dist.start.current>maxdist & \reverse then done=1
       when _dist.current.start>maxdist & reverse then done=1
       when head=tail then done=1
       otherwise head=head+1
      end /*select*/

     end /*do*/

    return _dist.start.finish

/** _mapfind v.6 **/
    _mapfind: procedure expose (globals)
     start=arg(1)
     searchstring=arg(2)
     mapname=arg(3)
     recordlen=arg(4)
     maxdist=255; mindist=1
     select
      when arg(5,"E") & arg(6,"E") then do
       mindist=min(max(_stripint(arg(5)),1),255)
       maxdist=max(min(_stripint(arg(6)),255),1)
      end /*when*/
      when arg(6,"E") then maxdist=max(min(_stripint(arg(6)),255),1)
      when arg(5,"E") then maxdist=max(min(_stripint(arg(5)),255),1)
      otherwise nop
     end /*select*/
     if arg(7,"E") then useexclusions=arg(7); else useexclusions=1
     if arg(8,"E") then matchcount=arg(8); else matchcount=1

     usevoids=0
     reverse=0
     secnum=-1
     void=-1
     busted=-1
     figs=-1
     expl=-1
     list=-1
     pvis=-1
     deadend=-1
     bubble=-1
     tomsl=-1; frmsl=-1
     ptype=-1
     pore=-1;  porg=-1;  pequ=-1
     ppore=-1; pporg=-1; ppequ=-1
     viewed=-1
     /* parse search string */
     do i=1 to _dwords(searchstring,";")
      criteria=_dword(searchstring,i,";")
      tag=_dword(criteria,1,":")
      val=_dword(criteria,2,":")
      select
       when tag="mx"  then maxdist=val
       when tag="mn"  then mindist=val
       when tag="ue"  then useexclusions=val
       when tag="mc"  then matchcount=val
       when tag="r"   then reverse=val
       when tag="s"   then secnum=val
       when tag="uv"  then usevoids=val
       when tag="v"   then void=val
       when tag="f"   then figs=val
       when tag="e"   then expl=val
       when tag="sl"  then list=val
       when tag="pt"  then ptype=lower(val)
       when tag="p1"  then pore=val
       when tag="p2"  then porg=val
       when tag="p3"  then pequ=val
       when tag="pp1" then ppore=val
       when tag="pp2" then pporg=val
       when tag="pp3" then ppequ=val
       when tag="pv"  then pvis=val
       when tag="pb"  then busted=val
       when tag="d"   then deadend=val
       when tag="b"   then bubble=val
       when tag="tm"  then tomsl=val
       when tag="fm"  then frmsl=val
       when tag="vw"  then viewed=val
       when tag="nw"  then nw=val
       when tag="nwo" then nwo=val
       when tag="nw0" then nw0=val
       when tag="nw1" then nw1=val
       when tag="nw2" then nw2=val
       otherwise nop
      end /*select*/
     end /*do*/

     call _mapseek mapname, recordlen, start
     _dist.start.start=0
     _path.start.start=start

     /* initialize arrays */
     inqueue.=0
     queue.=""
     queue.1=start
     inqueue.start=1
     tail=1
     do i=1 to words(_s.start)
      code=word(_s.start,i)
      warptype=code%20000
      sector=code//20000
      if ((warptype<2 & \reverse) | (warptype>0 & reverse)) & (usevoids\=1 | \_v.sector) then do
       tail=tail+1
       queue.tail=sector
       inqueue.sector=1
      end /*if*/
     end /*do*/

     rslt=""
     current=start
     head=1
     found=0
     do while tail>=head

      /* have we found the destination? */
      select
       when _dist.start.current>maxdist & \reverse then do; found=0; leave; end
       when _dist.current.start>maxdist &  reverse then do; found=0; leave; end
       when found then do
        rslt=rslt current
        if words(rslt)=matchcount | head=tail then leave
        found=0
        head=head+1
       end /*when*/
       when head=tail then leave
       otherwise head=head+1
      end /*select*/

      current=queue.head
      call _mapseek mapname, recordlen, current

      do i=1 to words(_s.current)

       adjacent=word(_s.current.!num,i)
       warptype=word(_s.current.!wt,i)

       /* add to tail */
       if ((warptype<2 & \reverse) | (warptype>0 & reverse)) & (usevoids\=1 | \_v.adjacent) & \inqueue.adjacent then do
        tail=tail+1
        queue.tail=adjacent
        inqueue.adjacent=1
       end /*if*/

       /* assign shortest warp distance */
       if warptype>0 & \reverse then do
        tdist=_dist.start.current
        _dist.start.current=min(_dist.start.current,_dist.start.adjacent+1)
        if tdist>_dist.start.current then _path.start.current=_path.start.adjacent||";"||current
       end /*if*/

       if warptype<2 & reverse then do
        tdist=_dist.current.start
        _dist.current.start=min(_dist.current.start,_dist.adjacent.start+1)
        if tdist>_dist.current.start then _path.current.start=current||";"||_path.adjacent.start
       end /*if*/

      end /*do*/

      /* evaluate the criteria */
      found=1

      if _dist.start.current<mindist & \reverse then do; found=0; iterate; end
      if _dist.current.start<mindist &  reverse then do; found=0; iterate; end
      if useexclusions & _ex.current            then do; found=0; iterate; end
      if secnum\=-1  & secnum\=current          then do; found=0; iterate; end
      if void\=-1    & void=\_v.current         then do; found=0; iterate; end
      if figs\=-1    & figs=\_f.current         then do; found=0; iterate; end
      if expl\=-1    & expl=\_sv.current        then do; found=0; iterate; end
      if list\=-1    & list=\_sl.current        then do; found=0; iterate; end
      if pvis\=-1    & pvis=\_pv.current        then do; found=0; iterate; end
      if deadend\=-1 & deadend=\_od.current     then do; found=0; iterate; end

      bstamp=_iniv("!bust", "!"||current)
      if busted\=-1  & ((busted=1 & _undef(bstamp)) | (busted=0 & \_undef(bstamp))) then do; found=0; iterate; end

      if bubble\=-1 then do
       if bubble & _bg.current=0 then do; found=0; iterate; end
       if \bubble & _bg.current\=0 then do; found=0; iterate; end
      end /*if*/

      if viewed\=-1 then do
       select
        when left(viewed,2)="<=" & _vs.current>substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="<=" then nop
        when left(viewed,2)=">=" & _vs.current<substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)=">=" then nop
        when left(viewed,2)="\=" & _vs.current=substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="\=" then nop
        when left(viewed,2)="<>" & _vs.current=substr(viewed,3)  then do; found=0; iterate; end
        when left(viewed,2)="<>" then nop
        when left(viewed,1)="<"  & _vs.current>=substr(viewed,2) then do; found=0; iterate; end
        when left(viewed,1)=">"  & _vs.current<=substr(viewed,2) then do; found=0; iterate; end
        when left(viewed,1)="="  & _vs.current\=substr(viewed,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if tomsl\=-1 then do
       select
        when left(tomsl,2)="<=" & _dtomsl.current>substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="<=" then nop
        when left(tomsl,2)=">=" & _dtomsl.current<substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)=">=" then nop
        when left(tomsl,2)="\=" & _dtomsl.current=substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="\=" then nop
        when left(tomsl,2)="<>" & _dtomsl.current=substr(tomsl,3)  then do; found=0; iterate; end
        when left(tomsl,2)="<>" then nop
        when left(tomsl,1)="<"  & _dtomsl.current>=substr(tomsl,2) then do; found=0; iterate; end
        when left(tomsl,1)=">"  & _dtomsl.current<=substr(tomsl,2) then do; found=0; iterate; end
        when left(tomsl,1)="="  & _dtomsl.current\=substr(tomsl,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if frmsl\=-1 then do
       select
        when left(frmsl,2)="<=" & _dfrmsl.current>substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="<=" then nop
        when left(frmsl,2)=">=" & _dfrmsl.current<substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)=">=" then nop
        when left(frmsl,2)="\=" & _dfrmsl.current=substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="\=" then nop
        when left(frmsl,2)="<>" & _dfrmsl.current=substr(frmsl,3)  then do; found=0; iterate; end
        when left(frmsl,2)="<>" then nop
        when left(frmsl,1)="<"  & _dfrmsl.current>=substr(frmsl,2) then do; found=0; iterate; end
        when left(frmsl,1)=">"  & _dfrmsl.current<=substr(frmsl,2) then do; found=0; iterate; end
        when left(frmsl,1)="="  & _dfrmsl.current\=substr(frmsl,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if (ptype\=-1 | pore\=-1 | porg\=-1 | pequ\=-1) then cptype=_dword(_p.current,1,";")

      if ptype\=-1 then do
       select
        when ptype=0 & cptype\="" then do; found=0; iterate; end
        when ptype=0 then nop
        when ptype=1 & cptype="" then do; found=0; iterate; end
        when ptype=1 then nop
        when \_portmatch(cptype,ptype) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if pore\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpore=_dword(_dword(_p.current,2,";"),1,",")
        select
         when left(pore,2)="<=" & cpore>substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="<=" then nop
         when left(pore,2)=">=" & cpore<substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)=">=" then nop
         when left(pore,2)="\=" & cpore=substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="\=" then nop
         when left(pore,2)="<>" & cpore=substr(pore,3)  then do; found=0; iterate; end
         when left(pore,2)="<>" then nop
         when left(pore,1)="<"  & cpore>=substr(pore,2) then do; found=0; iterate; end
         when left(pore,1)=">"  & cpore<=substr(pore,2) then do; found=0; iterate; end
         when left(pore,1)="="  & cpore\=substr(pore,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if porg\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cporg=_dword(_dword(_p.current,3,";"),1,",")
        select
         when left(porg,2)="<=" & cporg>substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="<=" then nop
         when left(porg,2)=">=" & cporg<substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)=">=" then nop
         when left(porg,2)="\=" & cporg=substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="\=" then nop
         when left(porg,2)="<>" & cporg=substr(porg,3)  then do; found=0; iterate; end
         when left(porg,2)="<>" then nop
         when left(porg,1)="<"  & cporg>=substr(porg,2) then do; found=0; iterate; end
         when left(porg,1)=">"  & cporg<=substr(porg,2) then do; found=0; iterate; end
         when left(porg,1)="="  & cporg\=substr(porg,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if pequ\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpequ=_dword(_dword(_p.current,4,";"),1,",")
        select
         when left(pequ,2)="<=" & cpequ>substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="<=" then nop
         when left(pequ,2)=">=" & cpequ<substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)=">=" then nop
         when left(pequ,2)="\=" & cpequ=substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="\=" then nop
         when left(pequ,2)="<>" & cpequ=substr(pequ,3)  then do; found=0; iterate; end
         when left(pequ,2)="<>" then nop
         when left(pequ,1)="<"  & cpequ>=substr(pequ,2) then do; found=0; iterate; end
         when left(pequ,1)=">"  & cpequ<=substr(pequ,2) then do; found=0; iterate; end
         when left(pequ,1)="="  & cpequ\=substr(pequ,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if ppore\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cppore=_dword(_dword(_p.current,2,";"),2,",")
        select
         when left(ppore,2)="<=" & cppore>substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="<=" then nop
         when left(ppore,2)=">=" & cppore<substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)=">=" then nop
         when left(ppore,2)="\=" & cppore=substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="\=" then nop
         when left(ppore,2)="<>" & cppore=substr(ppore,3)  then do; found=0; iterate; end
         when left(ppore,2)="<>" then nop
         when left(ppore,1)="<"  & cppore>=substr(ppore,2) then do; found=0; iterate; end
         when left(ppore,1)=">"  & cppore<=substr(ppore,2) then do; found=0; iterate; end
         when left(ppore,1)="="  & cppore\=substr(ppore,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if pporg\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cpporg=_dword(_dword(_p.current,3,";"),2,",")
        select
         when left(pporg,2)="<=" & cpporg>substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="<=" then nop
         when left(pporg,2)=">=" & cpporg<substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)=">=" then nop
         when left(pporg,2)="\=" & cpporg=substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="\=" then nop
         when left(pporg,2)="<>" & cpporg=substr(pporg,3)  then do; found=0; iterate; end
         when left(pporg,2)="<>" then nop
         when left(pporg,1)="<"  & cpporg>=substr(pporg,2) then do; found=0; iterate; end
         when left(pporg,1)=">"  & cpporg<=substr(pporg,2) then do; found=0; iterate; end
         when left(pporg,1)="="  & cpporg\=substr(pporg,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if ppequ\=-1 then do
       if cptype="" then do; found=0; iterate; end
       else do
        cppequ=_dword(_dword(_p.current,4,";"),2,",")
        select
         when left(ppequ,2)="<=" & cppequ>substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="<=" then nop
         when left(ppequ,2)=">=" & cppequ<substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)=">=" then nop
         when left(ppequ,2)="\=" & cppequ=substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="\=" then nop
         when left(ppequ,2)="<>" & cppequ=substr(ppequ,3)  then do; found=0; iterate; end
         when left(ppequ,2)="<>" then nop
         when left(ppequ,1)="<"  & cppequ>=substr(ppequ,2) then do; found=0; iterate; end
         when left(ppequ,1)=">"  & cppequ<=substr(ppequ,2) then do; found=0; iterate; end
         when left(ppequ,1)="="  & cppequ\=substr(ppequ,2) then do; found=0; iterate; end
         otherwise nop
        end /*select*/
       end /*else*/
      end /*if*/

      if nw\=-1 then do
       select
        when left(nw,2)="<=" & _nw.current>substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="<=" then nop
        when left(nw,2)=">=" & _nw.current<substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)=">=" then nop
        when left(nw,2)="\=" & _nw.current=substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="\=" then nop
        when left(nw,2)="<>" & _nw.current=substr(nw,3)  then do; found=0; iterate; end
        when left(nw,2)="<>" then nop
        when left(nw,1)="<"  & _nw.current>=substr(nw,2) then do; found=0; iterate; end
        when left(nw,1)=">"  & _nw.current<=substr(nw,2) then do; found=0; iterate; end
        when left(nw,1)="="  & _nw.current\=substr(nw,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nwo\=-1 then do
       select
        when left(nwo,2)="<=" & _nwo.current>substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="<=" then nop
        when left(nwo,2)=">=" & _nwo.current<substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)=">=" then nop
        when left(nwo,2)="\=" & _nwo.current=substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="\=" then nop
        when left(nwo,2)="<>" & _nwo.current=substr(nwo,3)  then do; found=0; iterate; end
        when left(nwo,2)="<>" then nop
        when left(nwo,1)="<"  & _nwo.current>=substr(nwo,2) then do; found=0; iterate; end
        when left(nwo,1)=">"  & _nwo.current<=substr(nwo,2) then do; found=0; iterate; end
        when left(nwo,1)="="  & _nwo.current\=substr(nwo,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw0\=-1 then do
       select
        when left(nw0,2)="<=" & _nwt.current.0>substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="<=" then nop
        when left(nw0,2)=">=" & _nwt.current.0<substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)=">=" then nop
        when left(nw0,2)="\=" & _nwt.current.0=substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="\=" then nop
        when left(nw0,2)="<>" & _nwt.current.0=substr(nw0,3)  then do; found=0; iterate; end
        when left(nw0,2)="<>" then nop
        when left(nw0,1)="<"  & _nwt.current.0>=substr(nw0,2) then do; found=0; iterate; end
        when left(nw0,1)=">"  & _nwt.current.0<=substr(nw0,2) then do; found=0; iterate; end
        when left(nw0,1)="="  & _nwt.current.0\=substr(nw0,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw1\=-1 then do
       select
        when left(nw1,2)="<=" & _nwt.current.1>substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="<=" then nop
        when left(nw1,2)=">=" & _nwt.current.1<substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)=">=" then nop
        when left(nw1,2)="\=" & _nwt.current.1=substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="\=" then nop
        when left(nw1,2)="<>" & _nwt.current.1=substr(nw1,3)  then do; found=0; iterate; end
        when left(nw1,2)="<>" then nop
        when left(nw1,1)="<"  & _nwt.current.1>=substr(nw1,2) then do; found=0; iterate; end
        when left(nw1,1)=">"  & _nwt.current.1<=substr(nw1,2) then do; found=0; iterate; end
        when left(nw1,1)="="  & _nwt.current.1\=substr(nw1,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

      if nw2\=-1 then do
       select
        when left(nw2,2)="<=" & _nwt.current.2>substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="<=" then nop
        when left(nw2,2)=">=" & _nwt.current.2<substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)=">=" then nop
        when left(nw2,2)="\=" & _nwt.current.2=substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="\=" then nop
        when left(nw2,2)="<>" & _nwt.current.2=substr(nw2,3)  then do; found=0; iterate; end
        when left(nw2,2)="<>" then nop
        when left(nw2,1)="<"  & _nwt.current.2>=substr(nw2,2) then do; found=0; iterate; end
        when left(nw2,1)=">"  & _nwt.current.2<=substr(nw2,2) then do; found=0; iterate; end
        when left(nw2,1)="="  & _nwt.current.2\=substr(nw2,2) then do; found=0; iterate; end
        otherwise nop
       end /*select*/
      end /*if*/

     end /*do*/

     rslt=strip(rslt)
     if rslt="" then rslt=0

    return rslt

/** _debug v.5 **/
    _debug: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _debug"
     mode=strip(left(lower(arg(1)),3))
     msg=arg(2)
     if arg(3,"E") then logname=strip(arg(3))
     else logname="_debug.txt"
     select
      when mode="scr" then call zocwriteln "^[[1;34mREV-DEBUG <"||msg||">^[[0m"
      when mode="fed" then call zocsend "`REV-DEBUG <"||msg||">^M"
      when mode="sub" then call zocsend "'REV-DEBUG <"||msg||">^M"
      when mode="log" then do
       if _fileopenw(logname) then do
        call lineout logname, msg
        call _fileclose logname
       end /*if*/
       else call _error "unable to open rev-log.txt."
      end /*when*/
      otherwise nop
     end /*select*/
    return

/** _space v.1 **/
    _space: procedure expose (globals)
     str=strip(arg(1))
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then pad=arg(3); else pad=" "
     rslt=word(str,1)
     do i=2 to words(str)
      rslt=rslt||copies(pad,n)||word(str,i)
     end /*do*/
    return rslt

/** _stripint v.4 **/
    _stripint: procedure expose (globals)
     mask=_space(translate(arg(1)," ","-0123456789,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripint"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if length(rslt)>9 then rslt=left(rslt,9)
      rslt=neg||rslt
     end /*else*/
    return rslt

/** _cleanup v.1 **/
    _cleanup: procedure expose (globals)
     /* put code here to do custom cleanup
        for specific scripts and override
        it in your main program */
    return 1

/** _get_log_path v.2 **/
    _get_log_path: procedure expose (globals)
     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then lpath = zocfilename("RESOLV", lpath)
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid path in _get_log_path"
    return lpath

/** _get_script_path v.1 **/
    _get_script_path: procedure expose (globals)
     parse value zocgetglobaloption("ScriptPath") with . '="' spath '"'
     if left(zocgetinfo("VERSION"),1)>4 then spath = zocfilename("RESOLV", spath)
     spath=dosfname(spath)
     if right(spath,1)\="\" then spath=spath||"\"
     if \dosisdir(spath) then call _error "invalid path in _get_script_path"
    return spath

/** _get_download_path v.2 **/
    _get_download_path: procedure expose (globals)
     parse value zocgetglobaloption("DownloadAltPath") with . '="' dpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then dpath = zocfilename("RESOLV", dpath)
     dpath=dosfname(dpath)
     if right(dpath,1)\="\" then dpath=dpath||"\"
     if \dosisdir(dpath) then call _error "invalid path in _get_download_path"
    return dpath

/** _setgame v.6 **/
    _setgame: procedure expose (globals)

     parse value zocgetglobaloption("CapturePath") with . '="' lpath '"'
     if left(zocgetinfo("VERSION"),1)>4 then lpath = zocfilename("RESOLV", lpath)
     lpath=dosfname(lpath)
     if right(lpath,1)\="\" then lpath=lpath||"\"
     if \dosisdir(lpath) then call _error "invalid log path in _setgame"

     if arg(1,"E") then gname=arg(1)
     else do
      list=_ini_list_games(lpath)
      if c=0 then gname="CLEAR"
      else gname=_drequestlist("select a game:", list||";CLEAR", ";", "c")
     end /*if*/
     if gname="CLEAR" | gname="" then do
      gname="%ZOCORHOST% %OPTIONS%"
      call zoclogging 0, 1
      call zoclogname "zoc_log_^3^2^1_^8.txt"
      call zocsetoption 'CaptDefaultName="zoc_log_^3^2^1_^8.txt"'
      call zoclogging 1, 1
     end/*if*/
     else do
      call zoclogging 0, 1
      call zoclogname gname||"_log_^3^2^1_^8.txt"
      call zocsetoption 'CaptDefaultName="'||gname||'_log_^3^2^1_^8.txt"'
      call zoclogging 1, 1
     end /*else*/
     call zocsetglobaloption 'WindowTitle="'||gname||'"'
    return gname

/** _fileopenr v.4 **/
    _fileopenr: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenr"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN READ"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

/** _fileeof v.4 **/
    _fileeof: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileeof"
      when arg(1)="" then rslt=0
      otherwise rslt=\lines(arg(1))
     end /*select*/
    return rslt

    _ini_is_section: procedure expose (globals)
     s=strip(arg(1))
     if left(s,1)="[" & left(reverse(s),1)="]" then return 1
    return 0

/** _ini_format_value **/
    _ini_format_value: procedure expose (globals)
     v=arg(1)
     if _dwords(v,"=")=2 then do
      t=lower(_dword(v,1,"="))
      v=_dword(v,2,"=")
      select
       when t="i" then v=_stripint(v)
       when t="f" then v=_stripnum(v)
       when t="b" then do; v=_stripint(v); if v>0 then v=1; else v=0; end
       when t="s" then nop
       otherwise nop
      end /*select*/
     end /*if*/
    return v

/** _fileclose v.3 **/
    _fileclose: procedure expose (globals)
     if \arg(1,"E") then call _error "missing argument in _fileclose"
     select
      when arg(1)="" then nop
      otherwise call stream arg(1), "C", "CLOSE"
     end /*select*/
    return

    _iniv: procedure expose (globals)
     s=arg(1); v=arg(2)
     if arg(3,"E") then _ini.s.v=arg(3)
    return _ini.s.v

/** _ansi v.3 **/
    _ansi: procedure expose (globals)
     rslt="0"
     pre=""
     do i=1 to _dwords(arg(1),";")
      w=_dword(arg(1),i,";")
      select
       when w="clearline" then pre=pre||"^[[100D^[[K"
       when w="dl"  then rslt=rslt||";"||0  /* dull               */
       when w="bt"  then rslt=rslt||";"||1  /* bright             */
       when w="ul"  then rslt=rslt||";"||4  /* underlined         */
       when w="blk" then rslt=rslt||";"||5  /* blinking           */
       when w="fbk" then rslt=rslt||";"||30 /* black foreground   */
       when w="frd" then rslt=rslt||";"||31 /* red foreground     */
       when w="fgr" then rslt=rslt||";"||32 /* green foreground   */
       when w="fye" then rslt=rslt||";"||33 /* yellow foreground  */
       when w="fbl" then rslt=rslt||";"||34 /* blue foreground    */
       when w="fmg" then rslt=rslt||";"||35 /* magenta foreground */
       when w="fcy" then rslt=rslt||";"||36 /* cyan foreground    */
       when w="fwh" then rslt=rslt||";"||37 /* white foreground   */
       when w="bbk" then rslt=rslt||";"||40 /* black background   */
       when w="brd" then rslt=rslt||";"||41 /* red background     */
       when w="bgr" then rslt=rslt||";"||42 /* green background   */
       when w="bye" then rslt=rslt||";"||43 /* yellow background  */
       when w="bbl" then rslt=rslt||";"||44 /* blue background    */
       when w="bmg" then rslt=rslt||";"||45 /* magenta background */
       when w="bcy" then rslt=rslt||";"||46 /* cyan background    */
       when w="bwh" then rslt=rslt||";"||47 /* white background   */
       otherwise nop
      end /*select*/
     end /*do*/
     rslt=pre||"^[["||rslt||"m"
    return rslt

/** _beep v.2 **/
    _beep: procedure expose (globals)
     if arg(2,"E") then n=arg(2); else n=1
     if arg(3,"E") then d=arg(3); else d=0
     select
      when arg(1,"O") then call zocwrite copies(d2c(7),n)
      when _fileexists(arg(1)) then do
       do i=1 to n
        call zocplaysound arg(1)
        if i\=n & d>0 then call zocdelay d
       end /*do*/
      end /*when*/
      otherwise call zocwrite copies(d2c(7),n)
     end /*select*/
    return

/** _synchronize_vars v.1 **/
    _synchronize_vars: procedure expose (globals)
     select
      when arg(1)="w" then rslt="Pausing",
                              ||"|Command [",
                              ||"|Citadel command",
                              ||"|Planet command",
                              ||"|<StarDock>",
                              ||"|ship to sell",
                              ||"|Still interested ?",
                              ||"|wish to buy? (A,B,C,Q,?)",
                              ||"|<Galactic Bank>",
                              ||"|<Hardware Emporium>",
                              ||"|<Shipyards>",
                              ||"|<Tavern>",
                              ||"|Enter your choice [T] ?",
                              ||"|do you want to sell [",
                              ||"|do you want to buy [",
                              ||"|Computer command",
                              ||"|Corporate command",
                              ||"|Colonists? [T]",
                              ||"|Stop in this sector (Y,N,E,I,R,S,D,P,?) (?=Help) [N]",
                              ||"|`",
                              ||"|F: ",
                              ||"|'",
                              ||"|S: ",
                              ||"|M: ",
                              ||"|P: "
      when arg(1)="r" then rslt="unknown;command;citadel;planet;stardock;ship_sell;ship_sell_interested;class_0",
                             ||";bank;hardware;shipyards;tavern;port_menu;port_haggle;port_haggle;computer",
                             ||";corporate;terra;stop_in_this_sector?;fedcom_text_entry_1;fedcom_text_entry_2",
                             ||";subspace_text_entry_1;subspace_text_entry_2;mail_text_entry;private_text_entry",
                             ||";corporate_cit;computer_cit;unknown_text_entry" /* <-- these unmatched in the wait string above */
      when arg(1)="command" then rslt=" ; ;qq;q;q;qqq;nqq;q;qq;qq;qq;qq;q;0^Mz0^Mz0^M;0^Mz0^Mz0^M;q;q;q;y;^H;^M;^H;^M;^M;^M;qqq;qqq; "
      when arg(1)="computer" then rslt=" ;c;c;qc;qc;qqqc;nqqc;qc;qqc;qqc;qqc;qqc;qc;0^Mz0^Mz0^Mc;0^Mz0^Mz0^Mc; ;qc;qc;yc;^Hc;^Mc;^Hc;^Mc;^Mc;^Mc;qc;qc; "
      otherwise call _error "unknown argument in _synchronize_vars"
     end /*select*/
    return rslt

/** _waitmux v.1 **/
    _waitmux: procedure expose (globals)
     rslt=zocwaitmux(arg(1))
    return rslt

/** _wait v.1 **/
    _wait: procedure expose (globals)
     rslt=zocwait(arg(1))
    return rslt

/** _listin v.4 **/
    _listin: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _listin"
     find=arg(1)
     list=arg(2)
     if arg(3,"E") then delim=left(arg(3),1); else delim=";"
     if arg(4,"E") then abbrv=arg(4); else abbrv=0;
     rslt=0
     do i=1 to _dwords(list,delim)
      select
       when \abbrv & find==_dword(list,i,delim) then do; rslt=1; leave; end
       when \abbrv then nop
       when pos(_dword(list,i,delim),find)>0 then do; rslt=1; leave; end
       otherwise nop
      end /*if*/
     end /*do*/
    return rslt

    _undef: procedure expose (globals)
     if arg(1)="##UNDEF##" then return 1; else return 0

/** _online_load_rank_names v.1 **/
    _online_load_rank_names: procedure expose (globals)
     _online.!red.0="12 10 7 8 9 11 22 13 1 2 3 15 4 5 6 14 21 17 18 19 20 16"
     _online.!red.1="Nuisance 3rd Class"
     _online.!red.2="Nuisance 2nd Class"
     _online.!red.3="Nuisance 1st Class"
     _online.!red.4="Menace 3rd Class"
     _online.!red.5="Menace 2nd Class"
     _online.!red.6="Menace 1st Class"
     _online.!red.7="Smuggler 3rd Class"
     _online.!red.8="Smuggler 2nd Class"
     _online.!red.9="Smuggler 1st Class"
     _online.!red.10="Smuggler Savant"
     _online.!red.11="Robber"
     _online.!red.12="Terrorist"
     _online.!red.13="Pirate"
     _online.!red.14="Infamous Pirate"
     _online.!red.15="Notorious Pirate"
     _online.!red.16="Dread Pirate"
     _online.!red.17="Galactic Scourge"
     _online.!red.18="Enemy of the State"
     _online.!red.19="Enemy of the People"
     _online.!red.20="Enemy of Humankind"
     _online.!red.21="Heinous Overlord"
     _online.!red.22="Prime Evil"

     _online.!blue.0="11 21 7 10 6 20 3 2 14 16 15 4 8 23 13 5 19 17 1 12 18 22 9"
     _online.!blue.1="Civilian"
     _online.!blue.2="Private"            /* match 2 */
     _online.!blue.3="Private 1st Class"  /* match 1 */
     _online.!blue.4="Lance Corporal"
     _online.!blue.5="Corporal"
     _online.!blue.6="Sergeant"           /* match 9 */
     _online.!blue.7="Staff Sergeant"
     _online.!blue.8="Gunnery Sergeant"
     _online.!blue.9="1st Sergeant"
     _online.!blue.10="Sergeant Major"     /* match 5 */
     _online.!blue.11="Warrant Officer"
     _online.!blue.12="Chief Warrant Officer"
     _online.!blue.13="Ensign"
     _online.!blue.14="Lieutenant J.G."      /* match 14 */
     _online.!blue.15="Lieutenant"           /* match 13,15 */
     _online.!blue.16="Lieutenant Commander" /* match 14 */
     _online.!blue.17="Commander"
     _online.!blue.18="Captain"
     _online.!blue.19="Commodore"
     _online.!blue.20="Rear Admiral"
     _online.!blue.21="Vice Admiral"
     _online.!blue.22="Admiral"
     _online.!blue.23="Fleet Admiral"
    return

    /*
    Nuisance 3rd Class
    Nuisance 2nd Class
    Nuisance 1st Class
    Menace 3rd Class
    Menace 2nd Class
    Menace 1st Class
    Smuggler 3rd Class
    Smuggler 2nd Class
    Smuggler 1st Class
    Smuggler Savant
    Robber
    Terrorist
    Pirate
    Infamous Pirate
    Notorious Pirate
    Dread Pirate
    Galactic Scourge
    Enemy of the State
    Enemy of the People
    Enemy of Humankind
    Heinous Overlord
    Prime Evil

    Private
    Private 1st Class
    Lance Corporal
    Corporal
    Sergeant
    Staff Sergeant
    Gunnery Sergeant
    1st Sergeant
    Sergeant Major
    Warrant Officer
    Chief Warrant Officer
    Ensign
    Lieutenant J.G.
    Lieutenant
    Lieutenant Commander
    Commander
    Captain
    Commodore
    Rear Admiral
    Vice Admiral
    Admiral
    Fleet Admiral
    */

/** _sendwait v.1 **/
    _sendwait: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _sendwait"
     call zocsend arg(1)
     rslt=_wait(arg(2))
     select
      when \arg(3,"E") | arg(3)=""             then nop
      when lower(arg(3))="timeout"  & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline" & rslt=640 then call _error "timeout"
      when lower(arg(3))="lastline"            then rslt=_lastline()
      otherwise nop
     end /*select*/
    return rslt

    _online_split_rank_name: procedure expose (globals)
     line=arg(1)
     if \_undef(_online.!reset) then call _error "rankings list not loaded"
     do j=1 to 23
      k=word(_online.!blue.0,j)
      if left(line,length(_online.!blue.k))=_online.!blue.k then leave
     end /*do*/
     if j<24 then do
      rank=k-1
      name=substr(line,length(_online.!blue.k)+2)
     end /*if*/
     else do
      do j=1 to 22
       k=word(_online.!red.0,j)
       if left(line,length(_online.!red.k))=_online.!red.k then leave
      end /*do*/
      if j<23 then do
       rank=-k
       name=substr(line,length(_online.!red.k)+2)
      end /*if*/
      else do
       k=0
       rank=0
       name=line
      end /*else*/
     end /*else*/
     rslt=rank";"name
    return rslt

/** _stripcomma v.1 **/
    _stripcomma: procedure expose (globals)
     rslt=translate(_space(translate(arg(1),", "," ,"),0)," ",",")
    return rslt

    _attack_strip_manufacturer: procedure expose (globals)
     line=arg(1)
     shiplist=arg(2)
     rslt=line
     do i=1 to _dwords(shiplist,";")
      n=reverse(_dword(shiplist,i,";"))
      if pos(n||" ",reverse(line))=1 then do
       rslt=reverse(n)
       leave
      end /*if*/
     end /*do*/
    return rslt

/** _quit v.7 **/
    _quit: procedure expose (globals)
     lcpy=1
     arg1=""
     do i=1 to 2 /* manage arguments */
      select
       when arg(i,"E") & lower(arg(i))="nocopy" then lcpy=0
       when arg(i,"E") & arg1="" then arg1=arg(i)
       otherwise nop
      end /*select*/
     end /*do*/
     line=zocgetscreen(0, zocgetinfo("CURSOR-Y"), zocgetinfo("CURSOR-X"))
     select /* define message */
      when  lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m^M^J"||line
      when \lcpy & arg1="" then msg="^[[1;32m< end script >^[[0m "
      when  lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m^M^J"||line
      when \lcpy           then msg="^[[1;32m^M^J< end script: "||arg1||" >^[[0m "
      otherwise nop
     end /*select*/
     call zocwrite msg
     select /* choose a beep */
      when lower(arg1)="script cancelled by user." then call _beep "cancel.wav"
      otherwise call _beep "quit.wav"
     end /*select*/
     exit
    return 1

/** _mapseek v.4 **/
    _mapseek: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") | \arg(3,"E") then call _error "missing parameter in _mapseek"
     fname=arg(1)
     recordlen=arg(2)
     sector=arg(3)

     if _s.sector="_S."||sector then _s.=""
     if _s.sector="" then do

      call stream fname, "C", "SEEK "||(sector-1)*recordlen+2

      vis=0
      one=0
      prt=0
      pvis=0
      bore=0
      borg=0
      bequ=0
      flags=c2d(charin(fname))
      if flags%128=1 then do
       bequ=1
       flags=flags-128
      end /*if*/
      if flags%64=1 then do
       borg=1
       flags=flags-64
      end /*if*/
      if flags%32=1 then do
       bore=1
       flags=flags-32
      end /*if*/
      if flags%16=1 then do
       _pv.sector=1
       flags=flags-16
      end /*if*/
      if flags%8=1 then do
       prt=1
       flags=flags-8
      end /*if*/
      if flags%4=1 then flags=flags-4
      if flags%2=1 then do
       _od.sector=1
       flags=flags-2
      end /*if*/
      if flags%1=1 then do
       _sv.sector=1
       flags=flags-1
      end /*if*/

      if prt & _undef(_iniv(!port_kills,"!"||sector)) then do
       _p.sector=word("S B",bore+1)||word("S B",borg+1)||word("S B",bequ+1)
       _p.sector.!type=_p.sector
       do i=1 to 3
        ms1=charin(fname)
        ms2=charin(fname)
        ms3=charin(fname)
        quan=c2d(ms1)+c2d(ms2)*256; perc=c2d(ms3)
        _p.sector=_p.sector||";"||quan||","||perc
        x1=word("!pore !porg !pequ",i); x2=word("!qore !qorg !qequ",i)
        _p.sector.x1=perc; _p.sector.x2=quan
       end /*do*/
      end /*if*/
      else do
       _p.sector=""; _p.sector.!type=""
       _p.sector.!pore=0; _p.sector.!porg=0; _p.sector.!pequ=0
       _p.sector.!qore=0; _p.sector.!qorg=0; _p.sector.!qequ=0
       call stream fname, "C", "SEEK "||1+(sector-1)*recordlen+11
      end /*else*/
      _dtomsl.sector=c2d(charin(fname))
      _dfrmsl.sector=c2d(charin(fname))
      _bg.sector=c2d(charin(fname))+c2d(charin(fname))*256
      _nwi.sector=c2d(charin(fname))

      ms1=c2d(charin(fname))+c2d(charin(fname))*256
      if ms1=0 then _s.sector=""
      else do
       _s.sector=ms1
       _nw.sector=1
       wt=ms1%20000
       _s.sector.!num=ms1//20000
       _s.sector.!wt=wt
       _nwt.sector.wt=_nwt.sector.wt+1
       do i=1 to ((recordlen-15)%2-1)
        ms1=c2d(charin(fname))+c2d(charin(fname))*256
        if ms1>0 then do
         _s.sector=_s.sector ms1
         _nw.sector=_nw.sector+1
         wt=ms1%20000
         _s.sector.!num=_s.sector.!num ms1//20000
         _s.sector.!wt=_s.sector.!wt wt
         _nwt.sector.wt=_nwt.sector.wt+1
        end /*if*/
       end /*do*/
      end /*else*/

      _nwo.sector=_nwt.sector.1 + _nwt.sector.0
     end /*if*/
    return

/** _portmatch v.1 **/
    _portmatch: procedure expose (globals)
     if \arg(1,"E") | \arg(2,"E") then call _error "missing parameter in _portmatch"
     m1=lower(strip(arg(1)))
     m2=lower(strip(arg(2)))
     rslt=0
     select
      when length(m1)\=3 then nop
      when length(m2)\=3 then nop
      when m1=m2 then rslt=1
      otherwise do
       mm1=0
       if left(m1,1)="x" then mm1=1
       if left(m2,1)="x" then mm1=1
       if left(m1,1)=left(m2,1) then mm1=1
       mm2=0
       if substr(m1,2,1)="x" then mm2=1
       if substr(m2,2,1)="x" then mm2=1
       if substr(m1,2,1)=substr(m2,2,1) then mm2=1
       mm3=0
       if substr(m1,3,1)="x" then mm3=1
       if substr(m2,3,1)="x" then mm3=1
       if substr(m1,3,1)=substr(m2,3,1) then mm3=1
       if mm1 & mm2 & mm3 then rslt=1
      end /*otherwise*/
     end /*select*/
    return rslt

/** _fileopenw v.3 **/
    _fileopenw: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileopenw"
      when arg(1)="" then rslt=0
      when _fileexists(arg(1)) then do
       call stream arg(1), "C", "OPEN WRITE"
       call stream arg(1), "C", "SEEK <0"
       rslt=_fileready(arg(1))
       if \rslt then call _fileclose arg(1)
      end /*when*/
      otherwise rslt=_filenew(arg(1))
     end /*select*/
    return rslt

    _set_msg: procedure expose (globals)
     i=_msg.0
     if i="_MSG.0" then do; _msg.=""; _msg.0=0; i=0; end
     i=i+1; _msg.0=i; _msg=""
     if arg(1,"E") then do; _msg.i=arg(1); _msg=arg(1); end;
     if arg(2,"E") then _msg.i.!source=arg(2)
     if arg(3,"E") then _msg.i.!comment=arg(3)
    return i

/** _ini_list_games v.1 **/
    _ini_list_games: procedure expose (globals)
     lpath=arg(1)
     parse value zoclistfiles(lpath||"*_data.ini", ";") with c list
     if c=0 then rslt=""
     else do
      n=_dword(list,1,";")
      rslt=left(n,lastpos("_data.ini",n)-1)
      do i=2 to c
       n=_dword(list,i,";")
       rslt=rslt||";"||left(n,lastpos("_data.ini",n)-1)
      end /*do*/
     end /*else*/
    return rslt

/** _drequestlist v.3 **/
    _drequestlist: procedure expose (globals)
     i=zocrequestlist(arg(1),translate(arg(2),"|"||arg(3),arg(3)||"|"))
     select
      when i<0 & lower(arg(4))="c" then call _quit "script cancelled by user.", "nocopy"
      when i<0 then rslt="##CANCEL##"
      otherwise rslt=_dword(arg(2),i+1,arg(3))
     end /*select*/
    return rslt

/** _fileexists v.4 **/
    _fileexists: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileexists"
      when arg(1)="" then rslt=0
      when stream(arg(1), "C", "QUERY EXISTS")="" then rslt=0
      otherwise rslt=1
     end /*select*/
    return rslt

/** _fileready v.2 **/
    _fileready: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _fileready"
      when arg(1)="" then rslt=0
      when stream(arg(1), "S")\="NOTREADY" then rslt=1
      otherwise rslt=0
     end /*select*/
    return rslt

/** _filenew v.4 **/
    _filenew: procedure expose (globals)
     select
      when \arg(1,"E") then call _error "missing parameter in _filenew"
      when arg(1)="" then rslt=0
      otherwise do
       if arg(2,"E") & lower(arg(2))="delete" then call dosdel arg(1)
       if _fileexists(arg(1)) then rslt=0
       else do
        call stream arg(1), "C", "OPEN WRITE"
        rslt=_fileready(arg(1))
        if \rslt then call _fileclose arg(1)
       end /*else*/
      end /*otherwise*/
     end /*select*/
    return rslt

/** _stripnum v.3 **/
    _stripnum: procedure expose (globals)
     w=9
     mask=_space(translate(arg(1)," ","-0123456789.,"," "),0)
     rslt=word(_space(translate(_stripcomma(arg(1))," ",mask," ")),1)
     if rslt="" | rslt="-" then do; call _set_msg "##NAN##", "_stripnum"; rslt=0; end
     else do
      if left(rslt,1)="-" then neg="-"; else neg=""
      rslt=_space(translate(rslt," ","-"),0)
      if left(rslt,1)="." then rslt="0"||rslt
      r=_dword(rslt,1,".")
      m=_dword(rslt,2,".")
      select
       when r=0 & length(m)>w then m=left(m,w)
       when length(r)>w then do; r=left(r,w); m=""; end
       when length(r)=w then m=""
       when length(m)>(w-length(r)) then m=left(m,w-length(r))
       otherwise nop
      end /*select*/
      if m="" then rslt=neg||r; else rstl=neg||r||"."||m
     end /*else*/
    return rslt

/** _lastline v.3 **/
    _lastline: procedure expose (globals)
     rslt=zoclastline()
     select
      when lower(arg(1))="raw" then nop
      when pos(d2c(7),rslt)>0  then rslt=translate(zocstring("REMOVE", rslt, d2c(7)),"  ",d2c(0)||d2c(10))
      otherwise                     rslt=translate(rslt,"  ",d2c(0)||d2c(10))
     end /*select*/
    return rslt
